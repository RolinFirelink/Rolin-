RDB我们已经讲完了，接下来我们来讲解AOF

- AOF实现持久化

首先我们来讲RDB存储的弊端，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9ee99a33782072e4d8b68f991ae4c552.png)

为了解决这个问题，我们就是使用到AOF来进行数据持久化，其主要作用是解决数据持久化的实时性，目前已经是Redis持久化的主流方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7659e7d9d67b47bde44228d5cc877551.png)

然后我们来看看AOF写数据的过程，每当用户写入一个数据，AOF就将写入的命令刷新至缓存区，当缓存区的命令达到一定数量之后，就将其同步到AOF文件中，以此来提高效率，而不是每做一个命令就同步一次

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4621dd49228bcc1393be7ebfe606f714.png)

接着我们来启动AOF的相关配置，需要在配置文件里写入以下四个参数

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE11d57c73dae19a904f1eec76767e06fe.png)

第一个是开启AOF持久化功能，我们写个yes就完了这里。第二个是取名，第三个是指定保存地址

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE11cf3ad502c51a6bfc77f4ca37f1b9d8.png)

最后一个配置值得我们特别提一提，我们可以设置三个参数，一个是always，其代表每次写入操作均同步到AOF文件中，其数据能达到零误差，但是效率比较低。然后是everysec，其代表每秒将缓冲区的指令同步到AOF文件中，会丢失一秒的数据，其数据准确性较高，性能比较好，我们推荐使用这个，同时这也是默认配置。最后一种由操作系统控制，整体过程不可能，几乎不会使用，不多提了

最后我们写入其配置如下，注意，这里的bind后面连接的地址并不是我们真正要填入的地址，我们要填入的地址是10.0.8.11，这点不要搞错了，然后我们使用Jedis连接时要使用我们的远程ip地址。

另外如果我们设置了密码，那么在对应的java连接中，要调用其auth方法并传入密码才能正确连接，同时在Linux程序中连接了Redis之后还需要调用auth 密码，这样的命令才能正确连接进去。

Redis设置密码的方式就是进入下面的配置文件，并写入requirepass 你想指定的密码，然后保存就可以了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE069c30c3c41fdc1050f5048b094b27a9.png)

然后我们去查看内部保存的日志的内容的时候，我们可以看到如下的内容

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEceba49e2b97033ec524fd65b576a5234.png)

这里连个星号之间的内容表示的是我们执行的语句，星号后面的数字表示的执行的语句数量，而$符后面的数字表示我们执行的语句的长度，就这样了

- 手动AOF重写机制与工作原理

我们先来讲讲什么是AOF重写，AOF重写简单来说，就是如果我们的命令最终的效果是一个，前面的动作都可以被省略，那么其就会将其省略，直接写到最后一个结果，比如说我们对一个数执行三次+1操作，那其实还原的时候没必要这样啊，直接+3不就完了，那么此时就可以使用AOF重写机制

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8f8d8069e12c104cb15ca6baa6f515b0.png)

该机制可以提高我们的持久化效率，并且降低磁盘占用量

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2e3fefd3c94b800b5065c1118363e022.png)

最后我们来看看其重写规则

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE618ce1de7a35ea18e535cca819ffbb14.png)

AOF的重写方式有两种，一种是手动重写，一种是自动重写

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbb376f966ea54ff1510e32b7ccc71dbf.png)

这里值得一提的是，自动重写调用的都是手动重写的方式。还有一点是，重写后的内容是乱码的形式，也就是最开始我们的直接保存数据的形式，而后续的内容则会以命令的形式继续往下保存，这点了解一下

最后我们来看看手动重写的原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdd07dc3a75241c98826af77b0d75e067.png)

- 自动AOF重写机制与工作原理

AOF自动重写的除法条件设置有两种，一种是设置大小，当我们的aof文件超过一定大小时就执行重写，另外一种是设置百分比，当aof文件占到我们内存中的百分之几时就执行重写。这两个条件的执行依赖于其下面的两个函数

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb91fc8a173ec94a6ff27c8867ee157dd.png)

接着我们来看看AOF的重写流程，首先我们来看不进行重写的两个不同AOF方式的执行过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd9b8e7b48945b2475515563de87e2e01.png)

接着是会重写的过程，或重写的过程里会将aof放置于aof重写缓存区，其会提供数据用于重写，然后会有子进程来执行重写，当重写完毕后会产生新的aof文件，该aof文件会替代原先的文件，同时替换后的文件就没有存在的必要了，此时原先的文件消失

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7c817f7823ab4147908be0d6b6aa4486.png)

- RDB与AOF优缺点分析

先来看看对比

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9d594b4abc78a40f604fcfefe7ee9f4d.png)

然后我们来看看我们应该选择哪个好

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1cdad923817ad45f405b822ebf33842e.png)

