- 翻转二叉树

先来看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4c52bd3f4fbf4e8b51de915e15dedd97.png)

同样的，我们也有递归和迭代两种解法，先来看看递归的代码

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        dfs(root);
        return root;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        if(root.left!=null && root.right!=null){
            TreeNode node = root.left;
            root.left=root.right;
            root.right=node;
        }else if(root.right==null){
            root.right=root.left;
            root.left=null;
        }else {
            root.left=root.right;
            root.right=null;
        }
        dfs(root.left);
        dfs(root.right);
    }
}
```

递归代码的思路非常简单，我们将情况分为三类，第一种情况是左右均不为空，此时我们反转两边的左右子树，第二种情况是左为空右不为空，此时我们将右赋为左，同时我们将右赋为null，右为空左不为空则反过来。这里由于我们首先已经判断过左右一定不为空了，所以我们后面的判断只需要拿出其中的一个条件就可以进入判断了，不需要把另外的条件也拿出来，因为判断不到。

不过事实上，我们这个代码还可以进一步完善，一个简单想法就是我们可以不必反这么多条件， 每到一个结点就让其左右子树交换就可以了，请看代码

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        dfs(root);
        return root;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        TreeNode node;
        node=root.left;
        root.left=root.right;
        root.right=node;
        dfs(root.left);
        dfs(root.right);
    }
}
```

还可以将dfs方法也省略掉，进一步优化我们的递归代码

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode node;
        node=root.left;
        root.left=root.right;
        root.right=node;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

然后我们来看看迭代代码

```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            while (size-->0){
                TreeNode node = deque.pop();
                if(node==null) continue;
                TreeNode temp;
                temp = node.left;
                node.left=node.right;
                node.right=temp;
                deque.add(node.left);
                deque.add(node.right);
            }
        }
        return root;
    }
}
```

迭代代码的思路很简单，就是利用层序遍历，每到一个结点就反转其左右子节点，没啥值得说的。

- 对称二叉树

接着我们来学习对称二叉树，先看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa672b3ad85f1bca4973e240e29b84904.png)

先来看看递归代码

```
class Solution {
    boolean judge = true;
    public boolean isSymmetric(TreeNode root) {
        dfs(root.left,root.right);
        return judge;
    }

    private void dfs(TreeNode left, TreeNode right) {
        if(judge==false || left==null && right==null) return;
        if(left==null || right==null || left.val!=right.val){
            judge=false;
            return;
        }
        dfs(left.right,right.left);
        dfs(left.left,right.right);
    }
}
```

我们这里新创造了一个dfs函数，这个函数的作用在于我们每次要传入左右结点，我们将对称分为两种一种，一种是左右两个子树都在往左右扩大的方向走，另一种是都在往缩小的方向走，我们通过这两个分步来做到模拟是否对称的递归，然后每次我们比较左右的值，如果左右都为空则无事发生，如果有一个为空那么说明另一个不为空，此时必然不符合条件，最后再判断值是否相等，不相等也是错的，将我们的judge值赋为false，最后我们能够得到我们所需要的答案。

我们还有直接递归的版本，不需要给对应的judge赋值，请看代码

```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return dfs(root.left,root.right);
    }

    private boolean dfs(TreeNode left, TreeNode right) {
        if(left==null && right==null) return true;
        if(right==null || left==null || left.val!=right.val) return false;
        return dfs(left.left,right.right) && dfs(left.right,right.left);
    }
}
```

最后我们来看看迭代的代码

```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> dequeLeft = new LinkedList<>();
        Deque<TreeNode> dequeRight = new LinkedList<>();
        dequeLeft.add(root.left);dequeRight.add(root.right);
        while (!dequeLeft.isEmpty() && !dequeRight.isEmpty()){
            TreeNode nodeLeft = dequeLeft.pollLast();
            TreeNode nodeRight = dequeRight.pollLast();
            if(nodeLeft == null && nodeRight==null) continue;
            if(nodeLeft==null || nodeRight==null || nodeLeft.val!=nodeRight.val) return false;
            dequeLeft.add(nodeLeft.left);
            dequeLeft.add(nodeLeft.right);
            dequeRight.add(nodeRight.right);
            dequeRight.add(nodeRight.left);
        }
        return dequeLeft.isEmpty() && dequeRight.isEmpty();
    }
}
```

迭代的代码是利用两个栈来模拟左右遍历结点的过程，其本质思路和我们之前的递归代码差不多其实。

这两道题给我们的总结时什么？第一点总结是，我们可以将我们的情况普遍化，就像是在翻转二叉树里，其实根本没有必要分这么多的情况，直接嗯翻转就可以了。第二个启示是我们如果想要模拟某个对比的功能，我们可以自己创建一个新的方法去模拟，就比如在对称二叉树里，如果我们直接传root，而非left和right，那么我们肯定很难去模拟对称的情况，同时我们可以将一个复杂的过程简化为一个最基本的步骤然后去实现这个基本逻辑，利用递归去实现整体过程的对比，当然，这个本来就属于是递归的必要步骤和思想。最后一点是我们可以利用前面的已判断结果来简化我们后面的判断条件，就像我们在这两题里，每次都先判断是否为空，只要判断过其都不为空，那么剩下的一个空一个不为空的情况就可以只判断一个结果来实现整体判断、

接下来我们再来做做这题的进阶题目，请看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa51c985b344e4bec2e354c3ca7221ccc.png)

我们做这题的思路其实跟上一题的思路差不多，如果我们想歪了那就不好整，但是思路对了的话，那么这题就很简单。我们的解题的核心思想基于三点，那就是如果一棵树是另一颗树的子树，那么其有三种情况，第一种其该子树就是他自身，第二种是其为该结点的左子树，第三种是右子树，那么我们就可以根据这个思路，拿我们的每一个结点去和可能的子树比较，直到比较出相同的为止

那么我们的代码可以写成如下形式

```
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            boolean judge = isSameTree(node,subRoot);
            if(judge) return true;
            if(node.left!=null) deque.add(node.left);
            if(node.right!=null) deque.add(node.right);
        }
        return false;
    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null) return true;
        if(p!=null && q==null || p==null || p.val!=q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
}
```

我们这个代码的思路大体就是这样的，不断拿结点去和可能的子树比较，直到所有的结点比较完毕。这里采用了递归和迭代组合的方式，实际上我们也可以把第一个迭代也改成递归，请看代码

```
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if(root==null) return false;
        return isSameTree(root,subRoot) || isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);
    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null) return true;
        if(p!=null && q==null || p==null || p.val!=q.val) return false;
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
}
```

可以看到我们这里代码就精简很多了，我们这里代码是每次都进入判断代码，然后得到结果之后若为真就直接返回，若为否我们则递归执行我们的原来的判断例程，令其往左和往右前进，这样就能达到跟迭代一样的效果了，而且我们的代码还精简了不少