接着我们来学习结构型模式，结构型模式分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。而由于组合关系或聚合关系比继承关系的耦合度低，满足合成复用原则，因此对象结构型模式比类结构型模式具有更大的灵活性

结构性模式总分为七种，分别是代理模式、适配器模式、装饰者模式、桥接模式、外观模式、组合模式、享元模式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa2758355782b3e43a00b8be67714b953.png)

我们先来学习第一个模式，代理模式，先来看看代理模式的概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1a63a51452bb131f502fde8893f4a102.png)

代理模式简单来说就是给某个对象提供一个中介对象，由该对象来处理其他对该对象的访问，这就好像是卖电脑的商家一般不直接把电脑卖给客户，一般都是由电脑代理商来卖出的，这里电脑代理商就可以理解为是中介对象

而在java中代理按照代理类的生成时机不同又分为静态代理和动态代理，前者在编译器时就生成，而后者则是在java运行时动态生成的，而动态代理又分为JDK代理和CGLib代理

接着我们来看看代理模式里的结构，共有抽象主题类、真实主题类、代理类三种，这个光看定义有些云里雾里的，我们来做一个火车案例加深理解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9eb1c6891ea391f857284fc1efc1d091.png)

我们首先来说说代理模式里面的静态代理的方法，在此之前我们先来看看的案例内容

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5f6afb40028df1c2c8140aedfc6120be.png)

我们要使用静态代理，首先我们应该要创建一个具有卖票方法的接口

```
public interface SellTickets {
    void sell();
}
```

然后我们创建一个火车站类，令其实现卖票方法

```
public class TrainStation implements SellTickets{
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
}
```

然后我们再创建一个代售点类，同样令其实现卖票方法的接口，然后由于我们的代售点调用的火车站的卖票方法，所以此处要注入我们的火车站对象，然后在卖票方法中再次调用我们的火车站的卖票方法，当然，我们这里对原来的方法做了一些增强

```
public class ProxyPoint implements SellTickets{
    private TrainStation trainStation = new TrainStation();
    @Override
    public void sell() {
        System.out.println("代售点收取一些服务费用");
        trainStation.sell();
    }
}
```

最后我们在对应的测试类中创建对应的代售点类然后调用其卖票方法进行买票即可

```
public class Client {
    public static void main(String[] args) {
        //创建代售点类对象
        ProxyPoint proxyPoint = new ProxyPoint();
        //调用方法进行买票
        proxyPoint.sell();
    }
}
```

这里有两点需要提及，第一点是，似乎我们的代售点类即使不实现卖票方法的接口，我们也同样可以对原来的方法进行增强，并不妨碍。事实的确是如此，但是我们的规范要求我们的代理类和真实主题类都必须要实现抽象主题类接口，这是规范，我们必须这样做，这样做是有目的的，最简单的，我们后面的测试类里不是顺理成章地调用了代售点的卖票方法么？如果我们不实现这个卖票的接口，那么可能这个卖票就被定义成各种各样的名字了，到时候就失去了统一规范了，这样会徒增其他程序员的理解成本

第二点则是我们我们这里代售点和火车站的关联关系是组合，如果判断呢？有两种方式，第一种是我们可以看到我们这里是采用new对象的方式来注入火车站对象的，那么就是组合。第二点我们可以根据口诀“聚合可有可无，组合同生共死”来理解，我们分析其生命周期，容易知道代售点和被注入的火车站对象的生命周期是一致的，因此其关联关系是组合关系。这里为什么用组合而不用聚合呢？答案是因为课程就是这样做的，实际上当然是用聚合更好，毕竟代售点即使离开了火车站他也可以去卖冰红茶，并不是说一定要只能卖票，离开了火车站他就啥也做不了了

- JDK动态代理

接着我们来使用动态代理来实现上面的案例，先来讲解JDK提供的动态代理，在java中提供了一个动态代理类Proxy，该类提供了一个创建代理对象的静态方法newProxyInstance方法，我们可以用该方法来获取代理对象

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb6ec7a3b6c17edb4814b4c774d3cada1.png)

这个内容其实我们学习之前即已经学习过了，首先我们创建一个ProxyFactory类，在其下我们注入我们要进行代理的真实主题类，在这里是TrainStation对象，接着我们在此提供一个获取代理对象的方法，这里我们返回的代理对象本质是一个接口，这个接口就是我们抽象出来的具有卖票方法的接口

接着我们嗲用Proxy里的newProxyInstance方法来蝴蝶代理对象，由于返回的Object对象，因此此处我们需要进行强转，其下我们要传入真实主题类的类加载器以及代理类和真实主题类的共同接口，这些我们都可以通过真实主题类的一些方法获得对应的对象并传入，最后需要传入的是代理对象的调用处理程序

此处我们直接new其子类来传入对象，而其子类下又有三个变量，第一个变量proxy是要代理对象，也是我们后面要返回的代理类的对象，基本不用，忽略就行。第二个method则是我们对接口中的方法进行封装的method对象，第三个args则是我们方法中的实际参数，返回值如果有，则返回对应的返回值，若没有则返回null

最后值得一提的是，如果我们要动态代理中执行被代理对象的某些方法，我们要使用反射的方式来执行这些方法，否则是无法执行的

```
public class ProxyFactory {

    protected TrainStation station = new TrainStation();

    //获取代理对象的方法
    public SellTickets getProxyObject() {
        //返回代理对象
        /*
        * ClassLoader loader : 类加载器，用于加载代理类，可以通过目标对象获取类加载器
        * Class<?>[] interfaces : 代理类实现的接口的字节码对象
        * InvocationHandler h : 代理对象的调用处理程序
        */
        SellTickets proxyObject = (SellTickets) Proxy.newProxyInstance(
                station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 代理对象的调用处理程序，此处是实现其子类对象的方式来传入所需的对象
                     * @param proxy 代理对象，和proxyObject对象是同一个对象，在invoke方法中基本不用
                     * @param method 对接口中的方法进行封装的method对象
                     * @param args 调用方法的实际参数
                     * @return 方法的返回值，如果方法无返回值，则返回null
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("代售点收取一定的服务费用（jdk动态代理）");
                        //执行目标对象的方法
                        Object invoke = method.invoke(station, args);
                        return invoke;
                    }
                }
        );
        return proxyObject;
    }
}

```

最后我们在测试类中写入对应的代码，可以得到我们想要的结果

```
public class Client {
    public static void main(String[] args) {
        //1.获取代理对象
        ProxyFactory factory = new ProxyFactory();
        //2.使用factory对象的方法获取代理对象
        SellTickets proxyObject = factory.getProxyObject();
        //3.调用卖票的方法
        proxyObject.sell();
    }
}
```

接着我们来学习下动态代理的原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe56681743a38c59cbbd968d589994e5c.png)

虽然上面说我们可以使用java诊断工具阿尔萨斯来查看代理类的结构，但是我们这里就懒得自己再查一遍了，资料里有，咱们直接拿资料里的东东拿来学吧

我们直接来看重点代码（此处的代码是省略了一部分的代码，只留下我们要学习的重点部分）

然后我们来讲解下这部分的代码，首先我们可以看到其下有对应的方法属性，这个方法属性通过static静态代码块获得对应的接口对象然后将接口的方法赋予到这个方法属性中，接着代理类$Proxy0的父类Proxy还有一个InvocationHandler属性，该属性用protected修饰，因此子类可以正常调用，此处我们可以看到其构造方法下就有一个InvocationHandler对象，该对象通过调用父类的方法将该对象的值设置到对应的属性中，该对象就是我们在构造的方法中自己手动new出来的其子类对象，然后我们在sell方法中可以看到其调用就是该对象的invoke方法，那其实就是我们自己new出的子类的invoke方法，由于我们又在该方法中进行了对代理对象的方法的再调用，所以我们最后能够正确调用我们的自己设置的方法

```
//程序运行过程中动态生成的代理类
public final class $Proxy0 extends Proxy implements SellTickets {
    private static Method m3;

    public $Proxy0(InvocationHandler invocationHandler) {
        super(invocationHandler);
    }

    static {
        m3 = Class.forName("com.itheima.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);
    }

    public final void sell() {
        this.h.invoke(this, m3, null);
    }
}

//Java提供的动态代理相关类
public class Proxy implements java.io.Serializable {
    protected InvocationHandler h;

    protected Proxy(InvocationHandler h) {
        this.h = h;
    }
}
```

从上面的类中，我们可以看到以下几个信息：

- 代理类（$Proxy0）实现了SellTickets，这也就印证了我们之前说的真实类和代理类实现同样的接口。

- 代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。

其总体的执行流程如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb3f67e32de1c9ec76c03e3a129e50af9.png)

- CGLib代理

接着我们来用CGLib代理的方式来实现之前的案例，我们之前的JDK代理是面对接口的动态代理，其要执行代理要求代理对象必须实现一个接口，而我们的CGLib代理则没有这个要求，其为JDK代理提供了很好的补充

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb4ec22fdcdf7f1f314f367c64c5980f.png)

要使用CGLib，我们首先要导入其对应的包

```
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>2.2.2</version>
</dependency>
```

接着我们的代理类必须要实现MethodInterceptor接口，实现该接口要求实现intercept方法，这个方法其实就是我们的回调方法，当然，目前我们不知道回调方法是个啥，这没关系，我们先按下不表。我们首先往其下设置注入火车站对象，也就是原始的代理类，这样方便我们之后调用对应的方法，然后我们创建一个获得代理类的方法，其下我们要先创建一个Enhance对象，然后设置其父类的字节码对象，这里我们直接设置原始主题的字节码对象，也就是火车站的字节码对象，接着我们要设置回调函数，其实回调函数就是我们之前实现的方法，我们这里只要求传入具有回调方法的对象即可，那么就直接传入当前的对象，其就有我们实现的回调方法。接着我们调用其中的创建代理对象的方法，将创建的代理对象返回即可。

最后我们在回调方法中执行我们的代理对象的售票方法，此处我们实现调用真实主题的售票的方法仍然是通过反射的方式

```
public class ProxyFactory implements MethodInterceptor {

    //声明火车站对象
    private TrainStation station = new TrainStation();

    public TrainStation getProxyObjet() {
        //创建Enhancer对象，类似于JDK代理中的Proxy类
        Enhancer enhancer = new Enhancer();
        //设置父类的字节码对象
        enhancer.setSuperclass(TrainStation.class);
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        TrainStation proxyObject = (TrainStation) enhancer.create();
        return proxyObject;
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        //System.out.println("方法执行了");
        System.out.println("代售点收取一定的服务费用(CGLib代理)");
        //要调用目标对象的方法
        Object invoke = method.invoke(station, objects);
        return invoke;
    }
}

```

最后我们可以写入我们的测试类如下，这里我们的第八行调用代理类的售票方法其实调用的就是代理类中的回调函数，这也是为什么我们一定要设置回调函数和我们要在回调函数中实现代理对象的售票功能的原因

```
public class Client {
    public static void main(String[] args) {
        //创建代理工厂对象
        ProxyFactory factory = new ProxyFactory();
        //获取代理对象
        TrainStation proxyObject = factory.getProxyObjet();
        //调用代理对象中的sell方法卖票
        proxyObject.sell();
    }
}
```

- 三种代理模式的对比及代理模式的优缺点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE01207fa85a4ed73049940b752d32f39e.png)

简单来说，我们推荐有接口的时候使用jdk动态代理，没有接口就使用CGLIB代理，其中能用动态代理就用动态代理，而不要用静态代理

接着我们来看看代理模式的优缺点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc3deac06b1afe2481072539488eb97a3.png)

最后我们来看看其使用场景，我们的远程代理、防火墙代理以及保护代理都可以使用动态代理的方式来实现其功能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE89a6cfa8c3f8602afd09b160e207d722.png)

