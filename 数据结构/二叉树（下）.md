查找最大键和最小键

那此时我们的二叉树已经实现了，但是我们为了让我们的二叉树使用方便，最好再提供一个找出二叉树中最大键和最小键的方法，那我们应该怎么构造这两个方法呢？

我们先来看看查找最小键的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15c717ffdd68e732d715849a90fdb9d9.png)

再来看看最大键的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdf4a6c773ec41383b2784d6916d23419.png)

由上面的API设计我们可以构建最大键和最小键的方法代码如下

```javascript
/*
 * 调用该方法会继续调用重载的min(Node)方法，而重载的方法会返回
 * 最小键所在的结点回来，此时直接取该结点的key就是我们所需要的
 * 最小值了
 */
//查找整个树中最小键的方法
public Key min(){
    //min(Node x)方法
    return min(root).key;
}

/*
 * 其最小键所在的结点无非就是在树中的最左结点，这是根据左小右大
 * 原则推理就能够得来的，这里使用了递归的方法，如果左节点不为空
 * 则继续调用该重载方法进入左节点直到为空时返回x的结点。其实我
 * 个人觉得用迭代的方式也可以，而且应该比这个方法更加容易想到
 * 但是用递归也是可以的，没有什么问题
 */
//在指定的树x中找到最小键所在的结点
private Node min(Node x){

    //判断x还有无左节点，若无则是x最小键所在的结点
    if(x.left!=null){
        return min(x.left);
    }else {
        return x;
    }
}

//查找整个树中最大键的方法
//其原理和上面的一样，不多赘述了
public Key max(){
    return max(root).key;
}

//在指定的树x中找到最大键所在的结点
private Node max(Node x){

    //判断x还有无右节点，若无则是x最大键所在的结点
    if(x.right!=null){
        return max(x.right);
    }else {
        return x;
    }
}
```



遍历概述

那我们完成了上面的方法之后，应该要给我们的二叉树增加遍历的方法，在构造这样的代码之前，我们要先学习其二叉树基础遍历的相关方式

二叉树的相关遍历有以下三种

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE71a26842e4a2d73aefd4e9935345424b.png)

这三种方式无非就是按照根来分的，而且左必然在右的前面，那么前序遍历就是根左右，中序遍历是左根右，后序遍历是左右根

为了便于我们的遍历，我们可以将树简化成如下结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd3d647de25b03de679555f97aef9446b.png)

这样无论哪个结点都有左子树和右子树，那么有同学就会问了，不是说叶结点是没有左右子树的吗？其实是有的，只不过它的两个左右子树的值为null

接下来让我们来看看分别使用三种遍历方式会得到什么结果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfa0094e66c1c3da4512636da94727bca.png)

前序遍历是根左右，所以BG必然在E后面，实际也是如此。但是为什么它们不是连续的呢？这是因为我们的遍历方式是按照根左右的形式来遍历的，我们的将E看作为根左右，那么先出E，之后就进入左子树B，但是左子树B又是根左右，于是出了B之后进入A左子树出A，之后进入右子树D，然后又是根左右，先进左子树C，然后右子树没有就不用了，此时E的左子树全部遍历完了，于是进入右子树G，G又分根左右，于是出G，再出左子树F，然后出右子树H，至此就全部遍历完了，最后的结果是EBADCGFH

另外两个遍历方式其实也是一样的，这里就不多赘述了



前序遍历

那么讲完了原理之后，现在我们先来实现前序遍历，我们前来看看前序遍历的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE29e7804a956be32f5f2749b96b3fffe2.png)

这里值得一提的是第二个方法，第二个方法里需要传入一个根结点，以及一个队列，它要使用这样一个前序遍历的方式把指定树x中的所有键放到keys的队列中，而第一个方法是要求返回一个队列的，这里的一个设计方法是用第二个方法将键的值放入队列中，然后在第一个方法里将队列返回，这里需要用代码将两个方法联系起来

那么我们可以实现前序遍历的代码如下

```javascript
/*
 * 因为要求要返回一个队列，因此在这个方法里先创建一个队列
 * 然后调用第二个方法将队列树中的元素按照前序遍历方式放入
 * 队列中，接着将该队列返回
 */
//获取整个树中所有的键
public Queue<Key> preErgodic(){
    Queue<Key> keys = new Queue<>();//创建队列
    preErgodic(root,keys);//调用第二个方法来修改队列
    return keys;
}

/*
 * 该方法是使用递归实现的，理论上我认为也可以用迭代实现，前序遍历的方式是根左右
 * 因此这里我们的代码的构造形式是先将结点中的值放入队列，此处代表先取出根中的值
 * 接着是先判断左子树是否为空，这里递归调用时若左子树不为空也是先进入左子树里去
 * 查找的，接着左子树查找完了再继续进行右子树的判断。说实话，我觉得这种方式并不
 * 好去想得到，起码我就肯定想不到，但是是可以理解的
 * 最后队列的元素放好之后再逐个取出队列中的元素就是我们所需要的排序后的值了
 */
//获取指定树x的所有键并放到keys队列中
private void preErgodic(Node x,Queue<Key> keys){
    //先判断传入的结点是否为空
    if(x==null){
        //若为空则结点结束方法
        return;
    }

    //每次调用都把x结点的key放入到keys中
    keys.enqueue(x.key);

    //递归遍历x结点的左子树
    if(x.left!=null){
        //若左子树不为空则重复调用该方法并将队列传入
        preErgodic(x.left,keys);
    }

    //递归遍历x结点的右子树
    if(x.right!=null){
        //若右子树不为空则重复调用此方法并将队列传入
        preErgodic(x.right,keys);
    }
}
```



中序遍历

接着我们来实现中序遍历，同样的我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE14d828015e95f519541b8a679b8ad2f1.png)

其原理其实和前序遍历差不多，这里不赘述了，直接构造代码

```javascript
//获取整个树中所有的键，此处是中序遍历的方式
public Queue<Key> midErgodic(){
    Queue<Key> keys = new Queue<>();//创建队列
    midErgodic(root,keys);//调用第二个方法来修改队列
    return keys;
}

/*
 * 同样用递归的方法实现这个代码，与之不同的是中序遍历的方式是左根右
 * 所以这里先进入进行左子树是否为空的判断，如果是则不断进入左子树，
 * 然后再取出其根的值，接着在进行右子树的判断，其实本质差不多，无非
 * 是顺序变换了而已，于是乎对应现实逻辑，我们的代码逻辑也是只换了位置
 */
//获取指定树x的所有键并放到keys队列中
private void midErgodic(Node x,Queue<Key> keys){
    //先判断传入的结点是否为空
    if(x==null){
        //若为空则结点结束方法
        return;
    }

    //递归遍历x结点的左子树
    if(x.left!=null){
        //若左子树不为空则重复调用该方法并将队列传入
        midErgodic(x.left,keys);
    }

    //每次调用都把x结点的key放入到keys中
    keys.enqueue(x.key);

    //递归遍历x结点的右子树
    if(x.right!=null){
        //若右子树不为空则重复调用此方法并将队列传入
        midErgodic(x.right,keys);
    }
}
```



后序遍历

API我都懒得放了，其实就是mid改成了after，直接看代码吧

```javascript
//获取整个树中所有的键，此处是后序遍历的方式
public Queue<Key> afterErgodic(){
    Queue<Key> keys = new Queue<>();//创建队列
    afterErgodic(root,keys);//调用第二个方法来修改队列
    return keys;
}

//获取指定树x的所有键并放到keys队列中
private void afterErgodic(Node x,Queue<Key> keys){
    //先判断传入的结点是否为空
    if(x==null){
        //若为空则结点结束方法
        return;
    }

    //递归遍历x结点的左子树
    if(x.left!=null){
        //若左子树不为空则重复调用该方法并将队列传入
        afterErgodic(x.left,keys);
    }

    //递归遍历x结点的右子树
    if(x.right!=null){
        //若右子树不为空则重复调用此方法并将队列传入
        afterErgodic(x.right,keys);
    }

    //每次调用都把x结点的key放入到keys中
    keys.enqueue(x.key);
}

```



层序遍历

接着我们来实现二叉树中一个名为层序遍历的遍历方式，正所谓百闻不如一见，直接来看图理解什么是层序遍历吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEde189d3107c530cc77653c9cd08c96df.png)

没错，所谓层序遍历就这样，按照一行一行的方式来把二叉树全部遍历完，那么我们要如何去实现这个层序遍历呢？我们先来看看其原理图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE53611c6e56f7a62c5159141be5deb4bb.png)

首先我们要完成层序遍历需要两个队列，第一个队列用于存放键，第二个队列用于存放二叉树的结点，我们实现这个层序遍历的方式非常简单，首先先将根结点存放于结点队列中，然后弹出该结点并将该结点的值放入到另一个键队列中，然后我们查看其是否有左右子树，若有则将其左右子树的结点放到结点队列中，然后再继续弹出一个结点，同样将其值存入到键队列中之后我们查看其左右子树的结点，若有，则继续将左右字数的结点压入到节点队列中，就这样周而复始最终我们存储到键队列中的元素就是我们所需要的层序遍历之后的元素了

了解了其原理之后，我们来看看其实现步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe2637196acf2f07c975f0b91fdb71199.png)

最后我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7ae4a68413a395e2699d3266b6a36332.png)

那么根据其实现步骤和API设计，我们可以构建层序遍历的代码如下

```javascript
/*
 * 层序遍历无非是使用了两个队列来辅助完成排序，不过这里并没有
 * 使用递归的方式，而是使用迭代的方式，我猜想也可以使用递归来
 * 完成这个方法
 */
//使用层序遍历，获取整个树中所有的键
public Queue<Key> layerErgodic(){
    //定义两个分别存储结点和键的队列
    Queue<Key> keys = new Queue<>();//存放键的队列
    Queue<Node> nodes = new Queue<>();//存放节点的队列

    //默认要往队列中先放入根结点，这是必然的，根结点都没有怎么遍历啊
    nodes.enqueue(root);//将结点压入到结点队列

    //只要结点队列不为空就继续执行循环
    while (!nodes.isEmpty()){
        //从结点队列中弹出结点并将其key放入到键队列中
        Node n = nodes.dequeue();//弹出结点
        keys.enqueue(n.key);//将弹出结点的值压入到键队列

        //判断当前结点还有无左子树，若有则将左子树放入到结点队列中
        if(n.left!=null){
            nodes.enqueue(n.left);//压入左子树结点到节点队列
        }

        //判断当前结点还有无右子树，若有则将右子树放入到结点队列中
        if(n.right!=null){
            nodes.enqueue(n.right);//压入右子树结点到节点队列
        }
    }
    return keys;//最后返回键队列
}
```

其实讲到这里，我们二叉树的入门就已经讲完了，接下来我们来讲关于二叉树的两个应用问题



二叉树的最大深度问题

先来看看需求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb9768eeeb08e3e39306b5b15aeb5fb52.png)

再来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3a5737d123842e5d8ecdb32a5f1e7f20.png)

接下来我们再来看看其实现步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa20c99bb48eefdb41a009ac1a00f4edd.png)

简而言之其实我们计算其深度的方法是我们将任何结点都视作为根加上左子树和右子树，我们先计算左子树和右子树的最大深度，然后当前树的最大深度就等于左子树和右子树最大深度的较大值+1，其方式是调用递归来实现的，光说其实不太好理解，我们来把代码构造出来

```javascript
//获取整个树的最大深度
public int maxDepth(){
    return maxDepth(root);
}

/*
 * 主要发挥查询最大深度的方法是这个方法，上一个方法说是调用树的最大深度，其实本质是传入树的根
 * 然后调用这个方法，而这个方法是可以查询指定树的最大的深度。其原理是利用递归达成的，为了安全
 * 性所以首先判断传入结点是否为空，若为空就直接返回0就完了
 * 这个方法的主要思想是对每一个结点都进行左右深度的判断，谁大就返回谁并+1，经过不断地递归最终
 * 在我们一开始传入的结点里我们能够得到两个深度值，对其进行左右值的判断并返回+1即可。这里我们
 * 定义三个变量的原因是我们需要这三个变量来保存和判断，max是保存其深度的最大值，而maxL则是每
 * 次都记录其左子树的最大值而maxR则是右子树的最大值。说实话要我想我真想不到，但是可以理解
 */
//获取指定树x的最大深度
private int maxDepth(Node x){
    //结点的安全性判断，若为空则直接返回0
    if(x==null){
        return 0;
    }
    //定义max来保存x的最大深度
    int max=0;
    //定义maxL来保存左子树的最大深度
    int maxL=0;
    //定义maxR来保存右子树的最大深度
    int maxR=0;

    //计算x结点左子树的最大深度
    if(x.left!=null){
        //因为要用maxL进行判断所以每次递归时都要将最大值传给maxL，每次重复调用将左子树传入
        maxL = maxDepth(x.left);
    }
    //计算x结点右子树的最大深度
    if(x.right!=null){
        //因为要用maxR进行判断所以每次递归时都要将最大值传给maxR，每次重复调用将右子树传入
        maxR = maxDepth(x.right);
    }
    //比较左右子树的最大深度，取较大值+1并赋给max，这里运用三元运算符，其意思是判断maxL是否
    //大于maxR，若大于则返回maxL+1，小于则返回maxR+1。这里之所以用>符号就可以了是因为无论
    //让谁+1最后都会赋给max，都一样的其实，但之所以使用大于号，是为了便于最后的根结点的比较
    //如果用小于号的话，最后根结点返回的深度会是较小的那个，而我们的思路是返回较大的那个，因此
    //这里必须用大于号
    max = maxL>maxR?maxL+1:maxR+1;
    return max;
}
```



折纸问题

先来看看折纸问题到底是啥

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7b3b2cc16d315eca432a964978b8cdca.png)

简单来说就是折纸产生的折痕朝下就叫down，朝上就叫up，要属实想不明白就照着图自己那张纸恩折就明白了，很快的其实。

但是这跟我们的二叉树有什么关系？虽然看起来没什么关系，但是如果分析下就会发现其实是有关系的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9e6cb4beb0d0478a3ac8b8f2fb5fc642.png)

其实就可以理解成我们每次对折都产生一层的新结点，第一次对折产生一个根结点，该结点为down，第二次对折产生两个新结点，这两个新结点都是第一个结点的子节点，其中左子树为down，右子树为up，再次对折也是如此，产生四个新结点，分别为down，up，down，up

可以分析出每次产生的左节点都为down，右节点都为up

而按照我们的题目要求对该树进行输出的话，就应该使用中序遍历方式，因为本来中序遍历方式也是我们说的能够按顺序输出的我们的结点元素的一种遍历方式，这样我们所输出的就是我们题目所要求了的，实际我们去对照也会发现中序遍历的结果的确就是跟纸张上从上往下数折痕的结果是一致的

然后我们来看看我们实现解决折纸问题的方法的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb3ef1bcd7cf2fd07f0af1b9d91db8699.png)

这里我们的1.3步骤问题都不是很大，我们前面已经学习过了，问题比较大的在于第二个步骤，我们先来看看第二个步骤的具体实现

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf13230127bd25c390d87ba7df81b5d6c.png)

这里的步骤简而言之是利用队列辅助完成，先对对折的情况进行判断，如果是第一次对折则只创建根结点，若不是第一次对折，则利用循环和队列定位到最后的叶结点，然后将每个结点都添加两个子树就完了

那么根据上面所说的步骤，我们现在可以实现其代码如下

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        //模拟折纸过程，产生树
        Node<String> tree = createTree(8);
        //遍历树，打印每个结点
        printTree(tree);
    }

    /*
     * 本方法的主要作用是为了模拟产生树，这里我们要应用到之前我们所学习的层序遍历的思想
     * 按照层序遍历的思想，我们先创造一个队列，然后传入一个根结点，将根结点取出后对结点
     * 进行有无左右子树的判断，若有，则将该左右子树放入队列中，这里我们不需要保存值所以
     * 没有创造第一个键队列的必要，然后继续将左右子树取出来进行判断，这样不断循环往复最
     * 终一定会在队列中取出各位置没有左右子树的结点，我们只要将这些结点添加左右子树就完了
     */
    //通过模拟对折N次纸，产生树
    public static Node<String> createTree(int N){
        //先定义根结点
        Node<String> root = null;
        for (int i = 0; i < N; i++) {
            //1.当前是第一次对折
            if(i==0){//如果是第一次对折就只创造根结点并跳过下面的创造结点的代码
                root = new Node<>("down",null,null);
                continue;
            }
            //2.当前不是第一次对折
            //定义一个结点队列，用于找到叶结点
            Queue<Node> queue = new Queue<>();
            queue.enqueue(root);

            //循环遍历队列
            while (!queue.isEmpty()){//只要队列中还有结点就继续循环
                //从队列中弹出一个结点
                Node<String> tmp = queue.dequeue();
                //如果弹出结点有左子树，则把左子树放入队列中
                if(tmp.left!=null){
                    queue.enqueue(tmp.left);
                }
                //如果弹出结点有左子树，则把左子树放入队列中
                if(tmp.right!=null){
                    queue.enqueue(tmp.right);
                }
                //如果该结点没有左右子树，则证明其为叶结点，则为其添加左右子树
                if(tmp.left==null && tmp.right==null){
                    //每次产生的左节点其元素必为down
                    tmp.left = new Node<String>("down",null,null);
                    //每次产生的右节点其元素必为up
                    tmp.right = new Node<String>("up",null,null);
                }
            }
        }
        //创建完毕之后返回新树的根
        return root;
    }

    /*
     * 这里采用了中序遍历的思想构建的方法，也就是左根右的遍历方式
     * 与我们之前定义的左根右的中序遍历的代码不同的是，这里的中序
     * 遍历的根是直接打印的，而我们之前定义的是将其放入队列，然后
     * 我们在主方法里打印队列的元素就完了，这里的代码是直接调用就
     * 可以一并完成打印的动作了
     */
    //打印树中的每个结点到控制台
    public static void printTree(Node root){
        //使用中序遍历完成,先进行安全性校验
        if (root==null){
            return;
        }

        //打印左子树的每个结点
        if (root.left!=null){
            printTree(root.left);
        }

        //打印当前结点
        System.out.print(root.item+" ");

        //打印右子树的每个结点
        if(root.right!=null){
            printTree(root.right);
        }
    }

    //结点类
    private static class Node<T> {
        public T item;//存储元素
        public Node left;
        public Node right;

        //构造方法
        public Node(T item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}
```

这个代码就可以解决我们的折纸问题了