接下来我们学习用注解来实现多表操作，没错，又又又回来了，就突出一个烦，但是没办法，学吧。

- 一对一环境介绍

我们的一对一的环境准备里有很多是跟之前一样的，有所不同的是我们这里在创建的onetoone包里我们要写入两个接口并写入对应的代码，第一个是CardMapper，其代码是

```
package com.itheima.one_to_one;

import com.itheima.bean.Card;

import java.util.List;

public interface CardMapper {
    //查询全部
    public abstract List<Card> selectAll();
}
```

第二个是PersonMapper

```
package com.itheima.one_to_one;

import com.itheima.bean.Person;
import org.apache.ibatis.annotations.Select;

public interface PersonMapper {
    //根据id查询
    @Select("SELECT * FROM person WHERE id=#{id}")
    public abstract Person selectById(Integer id);
}

```

那我们可以看到PersonMapper里实现了根据id查找，但是在CardMapper里还没做什么，别急，怎么在里面做文章令其实现一对一的多表操作是下一节的事情。

- 一对一的实现

接下来我们正式来实现一对一多表操作的功能，首先我们在CardMapper接口类里写入对应的查询全部card对象的查询语句，当然，是使用注释实现的。那么我们可以写入@Select("SELECT * FROM card")

然后我们就要用到Results注释了，我们首先要输入一个Results注释，然后加入小括号，小括号内部加大括号，然后回车在大括号内继续写代码

我们在大括号内使用Result注释，注释内有两个属性，分别是column和property，前者表示表中的数据列的名称，后者表示要给我们创建的实体类中赋值的属性名称，我们这里先给我们的Card对象赋值，因此我们我们这里先输入两个Result注释进行赋值。那么通过上面的叙述我们也知道，Reuslt注释的作用之一就是用于封装对象

接着我们我们要解决的一个问题是，我们的card对象里还有p这个引用数据，我们要如何给它赋值呢？我们的一个想法就是我们可以拿第一次查询cid来去查询我们的person表，查询到cid和id相同的数据并封装进去，那么我们要如何实现这个思路呢？我们同样要使用Result注释，写入小括号然后回车，内有property和javaType属性，前者存放被包含对象的变量名，这里就是其引用变量的名字p，后者存档被包含对象的实际数据类型的class文件。然后还有colum属性，该属性可以拿到我们数据列中对应的数据，我们这里输入pid，意为拿到pid的数据，然后我们要继续写入one = @one()，这个格式是一对一表中所使用的固定格式，可以让我们执行指定接口类的查询方法，内有select属性，该属性通过填入查询方法的所在类的对应方法的所在地址来执行这个方法，同时，执行这个查询方法时需要的参数就由我们上面的pid传入。

当然，这个可以执行的前提是，你先创造好了对应的接口类并提供了对应的执行查询方法的注解，要不然都没有这个玩意你怎么查啊是吧。那么我们可以构造代码如下

```
package com.itheima.one_to_one;

import com.itheima.bean.Card;
import com.itheima.bean.Person;
import org.apache.ibatis.annotations.One;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface CardMapper {
    //查询全部
    @Select("SELECT * FROM card")
    @Results({
            @Result(column = "id",property = "id"),
            @Result(column = "number",property = "number"),
            @Result(
                    property = "p",          //被包含对象的变量名
                    javaType = Person.class, //被包含对象的实际数据类型
                    column = "pid",          //根据查询处的card表中的pid字段来查询person表
                    /*
                        one、@One 一对一固定写法
                        select属性：指定调用哪个接口中的哪个方法
                     */
                    one = @One(select = "com.itheima.one_to_one.PersonMapper.selectById")
            )
    })
    public abstract List<Card> selectAll();
}
```

然后我们构造测试类代码如下

```
@Test
public void selectAll() throws Exception {
    //1.加载核心配置文件
    InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");

    //2.获取SqlSession工厂对象
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

    //3.通过工厂对象获取SqlSession对象
    SqlSession sqlSession = sqlSessionFactory.openSession(true);

    //4.获取StudentMapper接口的实现类对象
    CardMapper mapper = sqlSession.getMapper(CardMapper.class);

    //5.调用实现类对象中的方法，接收结果
    List<Card> list = mapper.selectAll();

    //6.处理结果
    for (Card card:list) {
        System.out.println(card);
    }

    //7.释放资源
    sqlSession.close();
    is.close();
}
```

然后我们会发现我们的代码整得没有毛病，可以运行并查出结果，那这样的话就可以了

当然，不要忘了在对应的核心配置文件里写入对应的配置代码

```
<!--配置映射关系-->
<mappers>
    <package name="com.itheima"/>
</mappers>
```

注意到我们的核心配置文件里配置的具有映射关系的是直接写在com.itheima这个大包下的，这样我们的测试代码在寻找对应的注解的时候就会从整个包下寻找，保证能寻找到。换言之，如果我们有多个子包，子包下都有不同接口注释类，那么我们可以将映射关系直接定义在包含子包的大包下

最后我们可以做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE604be88475e040e54a2a03858eec9823.png)

- 一对多的环境介绍

一对多的模型是经典的学生对班级

我们首先要先创造出一对多的对应的环境，我们数据表中的数据就挺好的，能用，而且没啥问题。然后我们要创建对应的实体类，这个也没有问题，因为实体类我们之前就创造过了。最后我们要创建两个接口类并写入对应的代码，首先是StudentMapper，写入代码如下

```
package com.itheima.ome_to_many;

import com.itheima.bean.Student;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface StudentMapper {
    //根据cid查询student表
    @Select("SELECT * FROM student WHERE cid=#{cid}")
    public abstract List<Student> selectByCid(Integer cid);
}

```

然后是ClassesMapper，写入代码如下

```
package com.itheima.ome_to_many;

import com.itheima.bean.Classes;

import java.util.List;

public interface ClassesMapper {
    //查询全部
    public abstract List<Classes> selectAll();
}

```

其实为什么有StudentMapper这个其实大家懂得都懂了，这肯定是因为后面我们要用cid来查找哪个对应的学生，由于一个班级里能有多个学生，所以返回的是一个学生集合

- 一对多的实现

我们一对多的代码实现其实还是跟以前得差不多，不同的是我们的one变成了many而已，具体请看代码

```
package com.itheima.ome_to_many;

import com.itheima.bean.Classes;
import org.apache.ibatis.annotations.Many;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface ClassesMapper {
    //查询全部
    @Select("SELECT * FROM classes")
    @Results({
            @Result(column = "id",property = "id"),
            @Result(column = "name",property = "name"),
            @Result(
                    property = "students",        //被包含对象的变量名
                    javaType = List.class,        //被包含对象的实际数据类型的class文件
                    column = "id",                //根据查询处的classes表的id字段来查询student表
                    /*
                        many、@Many 一对多查询的固定写法
                        select属性：指定调用哪个接口中的哪个查询方法
                     */
                    many = @Many(select = "com.itheima.ome_to_many.StudentMapper.selectByCid")
            )
    })
    public abstract List<Classes> selectAll();
}

```

然后我们写入测试类如下

```
package com.itheima.ome_to_many;

import com.itheima.bean.Card;
import com.itheima.bean.Classes;
import com.itheima.bean.Student;
import com.itheima.one_to_one.CardMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.InputStream;
import java.util.List;

public class Test01 {
    @Test
    public void selectAll() throws Exception {
        //1.加载核心配置文件
        InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");

        //2.获取SqlSession工厂对象
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

        //3.通过工厂对象获取SqlSession对象
        SqlSession sqlSession = sqlSessionFactory.openSession(true);

        //4.获取StudentMapper接口的实现类对象
        ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);

        //5.调用实现类对象中的方法，接收结果
        List<Classes> list = mapper.selectAll();

        //6.处理结果
        for (Classes cls:list) {
            System.out.println(cls.getId()+","+cls.getName());
            List<Student> students = cls.getStudents();
            for (Student student:students) {
                System.out.println("\t"+student);
            }
        }

        //7.释放资源
        sqlSession.close();
        is.close();
    }
}

```

那么我们的一对多就算是实现完毕了

最后我们可以做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe36836808cba8a7ba542e4ab890bd6ce.png)

- 多对多的环境介绍

经典学生对课程，没啥好说的

同样写入两个接口的代码

```
package com.itheima.many_to_many;

import com.itheima.bean.Course;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface CourseMapper {
    //根据学生id查询所选课程
    @Select("SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}")
    public abstract List<Course> selectBySid(Integer id);
}

```

我们这里解释下为什么我们这里的查询代码是SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}，这是因为我们最终肯定是要通过学生选择的课程号得到对应的课程的，那么我们查询时就通过学生的课程号查询到中间表中对应的号码，也就是sid，然后我们要通过sid查询到对应的含有相同id的课程，然后将其打印，所以我们将查询语句写成这样。说白了其实就是多对多里我们要通过中间表定位到我们所需要的数据，所以我们要构建较为复杂的sql代码

```
package com.itheima.many_to_many;

import com.itheima.bean.Student;

import java.util.List;

public interface StudentMapper {
    //查询全部
    public abstract List<Student> selectAll();
}

```

- 多对多的实现

为什么我们可以Results下写多个Result注解呢，这是因为该注解类下有一个Result注解类数组........

```
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Results {
    String id() default "";

    Result[] value() default {};
}
```

言归正传，我们最终可以构造代码如下

```
package com.itheima.many_to_many;

import com.itheima.bean.Student;
import org.apache.ibatis.annotations.Many;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface StudentMapper {
    //查询全部
    //@Select("SELECT * FROM student")
    @Select("SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id")
    @Results({
            @Result(column = "id",property = "id"),
            @Result(column = "name",property = "name"),
            @Result(column = "age",property = "age"),
            @Result(
                    property = "courses",  // 被包含对象的变量名
                    javaType = List.class, // 被包含对象的实际数据类型
                    column = "id",         // 根据查询处student表的id来作为关联条件，去查询中间表和课程表
                    /*
                        many、@Many 一对多查询的固定写法
                        select属性：指定调用哪个接口中的哪个查询方法
                     */
                    many = @Many(select = "com.itheima.many_to_many.CourseMapper.selectBySid")
            )
    })
    public abstract List<Student> selectAll();
}

```

这里如果我们采用第一个查询语句，也就是13行的代码，那么会将剩下两个没有选择课程的学生也查出来，而我们所希望查出来的内容是选择了课程的学生，因此我们这里的查询语句是查询所有和中间表有相同标识id的学生，同时加入DISTINCT关键字用于去重，由于无法对*去重，因此这里指定了展示的内容

其他的和我们之前的大差不差了，这里就不再赘述了。最后我们来看看本节总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8cf8ae8a5ea74c69c6853e54953824c0.png)

- 注解多表操作的小结

最后我们来看看本章总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE292da629ea4bcc4c21d6fc1fef18a1f7.png)

