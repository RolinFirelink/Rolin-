现在我们来学习中介者模式，先来看看其概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5164ed8cab8e689d542b3fa719083b9b.png)

简单来说就是不要和陌生人讲话的原则，如果不同对象建立直接访问的关系，那么最终得到的对象就会是十分复杂的，因此我们这里提供中介者，让不同对象之间关联中介者，这样可以减低其耦合性

这个很好理解，就好像我们买房子的时候，我们一般不会直接去找卖房子的人，而是寻找对应的房屋中介，通过房屋中介来完成购房，如果我们需要什么，我们也直接去找房屋中介即可，不需要去关心具体的房主

然后我们来看看中介者模式的定义和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8c4c704fb2314d417f4d6e77c5fa2c23.png)

同样的，我们来完成一个案例来加深我们对该模式的理解，先来看看案例需求以及其类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE21a1d17a3eec69636ba72c14219ddd04.png)

首先我们创建抽象中介者类，其可以是一个接口，也可以是抽象类，我们这里设置为抽象类的形式，其下提供一个交流的抽象方法，传入的参数是用于交流的信息和发入交流信息的同事类

```
//抽象中介者类
public abstract class Mediator {
    public abstract void constact(String message,Person person);
}
```

首先我们创建抽象的同事类，其是一个抽象类，具有名字和中介者属性，提供给其对应的构造方法即可

```
//抽象同事类
public abstract class Person {

    protected String name;
    protected Mediator mediator;

    public Person(String name, Mediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }
}

```

接着我们创建具体的同时角色类，在这个案例里代表的其实就是房主，我们令其实现抽象同事类，首先实现其构造方法，然后我们提供两个方法，第一个方法是和中介沟通的方法，直接传入信息和当前类的对象到中介者类中的沟通方法即可，然后还有一个获取信息的方法，打印房主名字和信息即可

```
//具体的同事角色类
public class HouseOwner extends Person{
    public HouseOwner(String name, Mediator mediator) {
        super(name, mediator);
    }

    //和中介联系（沟通）
    public void constact(String message){
        mediator.constact(message,this);
    }

    //获取信息
    public void getMessage(String message) {
        System.out.println("房主"+name+"获取到的信息是"+message);
    }
}
```

然后我们还要创建一个买房对象的具体同事角色类，同样提供对应的两个方法，无非做一些调试而已

```
//具体的同事角色类
public class Tenant extends Person{
    public Tenant(String name, Mediator mediator) {
        super(name, mediator);
    }

    //和中介联系（沟通）
    public void constact(String message){
        mediator.constact(message,this);
    }

    //获取信息
    public void getMessage(String message) {
        System.out.println("租房者"+name+"获取到的信息是"+message);
    }
}
```

最后我们创建具体中介者角色，其下聚合了房主和租房者对象，提供对应的getandset方法然后重写父类的constact方法，我们这里对传入的对象进行判断，若其是卖房者，则调用买房者的获得买房者信息的方法，反之则调用卖房者的获得对应信息的方法

```
//具体的中介者角色类
public class MediatorStructure extends Mediator{

    //聚合房主和租房者对象
    private HouseOwner houseOwner;
    private Tenant tenant;

    public HouseOwner getHouseOwner() {
        return houseOwner;
    }

    public void setHouseOwner(HouseOwner houseOwner) {
        this.houseOwner = houseOwner;
    }

    public Tenant getTenant() {
        return tenant;
    }

    public void setTenant(Tenant tenant) {
        this.tenant = tenant;
    }

    @Override
    public void constact(String message, Person person) {
        if(person==houseOwner){
            tenant.getMessage(message);
        }else {
            houseOwner.getMessage(message);
        }
    }
}

```

最后我们可以在测试类中写入代码如下，我们首先创建中介者、租房者、房主对象，然后将对应的房主和租房者聚合到中介者对象中，然后我们调用租房者的沟通方法，其就会调用中介者的沟通方法，中介者判断到其是租房者后，其就会将对应的信息传达给房主，这样就完成了一个信息的转调，对于房主调用对应的沟通方法而言，其过程也是一样的

```
public class Client {
    public static void main(String[] args) {
        //创建中介者对象
        MediatorStructure mediator = new MediatorStructure();

        //创建租房者对象
        Tenant tenant = new Tenant("李四",mediator);

        //创建房主对象
        HouseOwner houseOwner = new HouseOwner("张三",mediator);

        //中介者要知道具体的房主和租房者
        mediator.setTenant(tenant);
        mediator.setHouseOwner(houseOwner);

        tenant.constact("我要租三室房");
        houseOwner.constact("我这里有三室的房子");
    }
}
```

最后我们来看看中介者模式的优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbad4416c311448db26890e733cbc5375.png)

