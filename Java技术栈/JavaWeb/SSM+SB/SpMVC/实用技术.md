那么到这里，我们的SpringMVC也快学习完了，我们最后的内容则没有怎么多的理论上的东西了，都是偏实用的。

- 文件上传

首先我们来讲讲我们的上传文件过程，首先，我们平时的上传首先是创建一个表单项，然后用户选择上传图片时，是将该部分的内容转换为流数据传给Tomcat，然后tomcat内部对这些数据进行对应的处理最后生成一个对应的文件。而SpringMVC则知道你们要干什么了，所以其将这一部分内容整出了一个接口出来用于实现，那么接下来我们就来重点讲解这个MutipartResolver这个接口

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE44552acb71f5b86013769d451c69d241.png)

首先该接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装，其底层的实现类是CommonsMulitipartResovler。值得一提的是，SpringMVC并没有自主实现文件上传下载对应的功能其实调用apache的文件上传下载组件完成的功能的，因此我们在使用这个接口之前要将引入我们对应的apache的组件依赖

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE228e55778541118b8a22341633656f41.png)

那么我们可以写入其引入依赖的代码如下

```
<dependency>
  <groupId>commons-fileupload</groupId>
  <artifactId>commons-fileupload</artifactId>
  <version>1.4</version>
</dependency>
```

接着我们来正式实现其文件的上传下载，首先我们需要来介绍下我们当前的案例环境，我们这里没有使用jQuery的库，其他几乎没有什么特别的变动

然后我们写入我们的表单提交项如下，我们这里给我们的上传的LOGO的名字设置为file，同时我们点击上传，就回去寻找fileupload的方法并执行

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<form action="/fileupload" method="post" enctype="multipart/form-data">
    上传LOGO:<input type="file" name="file"/><br/>
    上传照片:<input type="file"/><br/>
    上传任意文件:<input type="file"/><br/>
    <input type="submit" value="上传"/>
</form>

```

然后我们来配置对应的上传类，我们这里采用配置bean的方式来实现，指定的实现类是CommonsMultipartResolver，其下有许多设置方法，比如最经典的一个设置上传文件的大小的方法，我们有需要就自己设置就可以了。同时由于这里是不支持设置运算符的，因此到底要多大还得自己计算一个合适的值然后设置进去，单位是kb

最后我们要记住的是，为了让我们的springMVC能够知道这个类是用于控制上传的类，因此其id只能为multipartResolver，写其他的都会令其失效

```
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="maxUploadSize" value="1024000000"/>
</bean>
```

最后我们写入我们的控制层的代码如下

```
package com.itheima.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;

@Controller
public class FileUploadController {

    @RequestMapping(value = "/fileupload")
    public String fileupload(MultipartFile file) throws IOException {
        System.out.println("file upload is running ..."+file);
        file.transferTo(new File("abc.png"));
        return "page.jsp";
    }
}
```

我们这里将我们的映射路径设置为对应的fileupload，令其能寻找到该方法，然后我们往其中加入了MultipartFile作为形参，并命名为file，这个file文件里就保存这我们上传的文件信息，我们可以通过调用该对象的对应的方法来令其保存到对应的路径或者是利用这些信息来创建一个指定的文件。

注意，这里我们页面表单设置的名字和我们的形参设置的名字一定要保持一致，否则将无法正确获取到上传的信息

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE44fd2fa0fb3b5bba68d088eb5f6f2d2d.png)

经过上面的步骤，我们就实现了在SprnigMVC中利用其提供的接口来实现上传了，这可比之前我们学习的方法方便多了

- 文件上传注意事项

接着我们来学习文件上传时的注意事项，文件上传时，最常出现的问题有文件名命名问题、保存路径问题等。而这些问题在我们的MultipartFile对象里都有对应的方法提供给我们使用，我们可以利用这些方法来解决这些问题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc57e16e7f46f7474cf7730e3f20cd24b.png)

那么为了解决对应的问题，我们可以写入我们的代码如下

```
package com.itheima.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;

@Controller
public class FileUploadController {

    @RequestMapping(value = "/fileupload")
    //参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，要求表单名称与参数名相同
    public String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException {
        System.out.println("file upload is running ..."+file);
//        MultipartFile参数中封装了上传的文件的相关信息
//        System.out.println(file.getSize());
//        System.out.println(file.getBytes().length);
//        System.out.println(file.getContentType());
//        System.out.println(file.getName());
//        System.out.println(file.getOriginalFilename());
//        System.out.println(file.isEmpty());
        //首先判断是否是空文件，也就是存储空间占用为0的文件
        if(!file.isEmpty()){
            //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）
            //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用
            String fileName = file.getOriginalFilename();
            //设置保存的路径
            String realPath = request.getServletContext().getRealPath("/images");
            //保存文件的方法，指定保存的位置和文件名即可，通常文件名使用随机生成策略产生，避免文件名冲突问题
            file.transferTo(new File(realPath,file.getOriginalFilename()));
        }
        //测试一次性上传多个文件
        if(!file1.isEmpty()){
            String fileName = file1.getOriginalFilename();
            //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可
            String realPath = request.getServletContext().getRealPath("/images");
            file1.transferTo(new File(realPath,file1.getOriginalFilename()));
        }
        if(!file2.isEmpty()){
            String fileName = file2.getOriginalFilename();
            String realPath = request.getServletContext().getRealPath("/images");
            file2.transferTo(new File(realPath,file2.getOriginalFilename()));
        }
        return "page.jsp";
    }
}

```

我们上面的代码就完成了第文件的处理，将上传的文件存放在我们指定的位置，并且获得其最开始的后缀来赋予其后缀，同时获得其初始的名字赋予其原来的名字

同时注意这里我们可以设置新的路径的前提是我们确实创建了这么一个路径，否则是没法用的

最后我们来提一下同名问题的解决，实际上，我们可以用数据库来保存文件的名字，而实际传送过来的文件的名字则用我们自己生成的规则字符串来代替，这样就能避免重名问题，同样也能不失去文件的原来的名字，获取名字的简单方法是使用UUID，这个我们用到了的时候再具体讲吧

- Restful

本节我们来学习Restful，其实一种网络资源的访问风格，注意是风格而不是规范，这是一个伏笔。我们传统风格访问我们的资源时，我们总是要加上地址和不能够写入我们的具体的传入的数据，非常麻烦，而且会被别人看到，不安全。此时我们的Rest风格访问路径就出现了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0b9d1d89fdcf938477441f4bd8112af1.png)

Rest风格的访问路径是直接在对应的页面后面加上我们要传入的数据，只有数据，所以即使看到了也整不明白这是干啥的，而Restful则是按照这个风格来访问网络资源的方式的统称

Rest行为的约定方式有四种，分别是负责查询的GET方式、负责保存的POST方式、负责更新的PUT方式以及负责删除的DELETE方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5500af38006e21d7e3d240e23e7064d3.png)

值得一提的是，上述的行为都是约定方式，也就是说，如果你非要利用GET做保存，也是可以的，只是我们不推荐。

那么我们现在就来正式在SpringMVC中来开发我们的Restful

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2c4ed49ae8147a73caaf2c84d8177725.png)

我们的项目环境本身没什么变化，所以这里就不再介绍一遍了，然后我们创建对应的控制类并写入代码如下

```
//rest风格访问路径完整书写方式
@RequestMapping("/user/{id}")
//使用@PathVariable注解获取路径上配置的具名变量，该配置可以使用多次
public String restLocation(@PathVariable Integer id){
    System.out.println("restful is running ....");
    return "success.jsp";
}
```

我们这里采用的就是rest风格的路径的完整书写方式，直接写我们要访问的路径并写入通过/分割，然后最后用大括号写入我们要传入的数据的变量名，在方法中则是以相同类型的参数名获得这个数据，注意这里形参名和映射中的名字一定要相同，否则会无法获得。同时我们这里要使用PathVariable注解，该注解能够让我们的形参在数据传入时获得对应的值，加了这个注解我们的形参才可以获得正确的值

这里值得一提的是，我们写入的user同时也是我们的路径名称，因此如果我们写入上面的代码，要令其正确跳转到我们的页面，我们就需要在webapp文件夹中创建一个user文件夹然后将success.jsp移动到这里去才可以。

那么我们在地址栏中输入如下地址就可以访问我们的服务器

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdbe57add42f06cc206428d211d26f6a5.png)

同时我们也可以不必每次都指定路径，我们可以将指定路径的动作放到类中，使用RequestMapping注解，在括号内中填入我们想要进入的路径就行了，然后其下的方法就都默认要使用这个路径来进入了，我们后续的方法就只需要直接写对应的数据值就完了

```
//rest风格访问路径简化书写方式，配合类注解@RequestMapping使用
@RequestMapping("{id}")
public String restLocation2(@PathVariable Integer id){
    System.out.println("restful is running ....get:"+id);
    return "success.jsp";
}
```

同时我们有时需要返回自己的字符串创建的页面而非字符串对应的jsp文件，此时我们就需要用到ResponseBody注解，我们一般把他加到方法上，而实际上其还可以用于类中，被修饰的类相当于其下的方法都被这个注解修饰了。而Controller注解又是我们必须要写的，springMVC考虑到了这一点，将这两个注解合并到了一个注解中，这个注解就是RestController。

- Restful风格配置

开始本章之前，我们要先知道，我们配置了一个表单页面用于进行测试

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>
<h1>restful风格请求表单</h1>
<%--切换请求路径为restful风格--%>
<%--GET请求通过地址栏可以发送，也可以通过设置form的请求方式提交--%>
<%--POST请求必须通过form的请求方式提交--%>
<form action="/user/1" method="post">
    <input type="submit"/>
</form>
```

如果我们想要某个方法区只处理某些特定的请求的话，那么我们就要在RequestMapping中，具体配置其method属性，通过后面属性设定其专门处理的请求

```
//接收GET请求配置方式
@RequestMapping(value = "{id}",method = RequestMethod.GET)
//接收GET请求简化配置方式
@GetMapping("{id}")
public String get(@PathVariable Integer id){
    System.out.println("restful is running ....get:"+id);
    return "success.jsp";
}
```

GET请求如此，POST请求也是如此，当然我们的表单项里提交的方法要写成是post

```
//接收POST请求配置方式
@RequestMapping(value = "{id}",method = RequestMethod.POST)
//接收POST请求简化配置方式
@PostMapping("{id}")
public String post(@PathVariable Integer id){
    System.out.println("restful is running ....post:"+id);
    return "success.jsp";
}
```

但是PUT请求就需要更多的改动才能生效，其中之一就是需要对我们的表单页面进行对应的改动，改动如下

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>
<h1>restful风格请求表单</h1>
<%--切换请求路径为restful风格--%>
<%--GET请求通过地址栏可以发送，也可以通过设置form的请求方式提交--%>
<%--POST请求必须通过form的请求方式提交--%>
<form action="/user/1" method="post">
    <%--当添加了name为_method的隐藏域时，可以通过设置该隐藏域的值，修改请求的提交方式，切换为PUT请求或DELETE请求，但是form表单的提交方式method属性必须填写post--%>
    <%--该配置需要配合HiddenHttpMethodFilter过滤器使用，单独使用无效，请注意检查web.xml中是否配置了对应过滤器--%>
    <input type="text" name="_method" value="PUT"/>
    <input type="submit"/>
</form>
```

我们这里给其加上了新的输入框并在value处设置PUT方式，这里的type属性一般是hidden，其代表不会在浏览器中显示，我们实际开发中一般也不会让用户自身去知道有这玩意的存在，但是我们这里为了演示方便，所以我们允许给其设置为text，而且我们的method的方式仍然是post

然后我们在web.xml中配置我们的代码如下

```
<filter>
  <filter-name>HiddenHttpMethodFilter</filter-name>
  <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
</filter>
<filter-mapping>
  <filter-name>HiddenHttpMethodFilter</filter-name>
  <servlet-name>DispatcherServlet</servlet-name>
</filter-mapping>
```

这个代码代表的意思是我们又在我们的容器中加入一个过滤器，这个过滤器类的类名是HiddenHttpMethodFilter类，而我们要过滤的方法是所有要经过DispatcherServlet的请求，简而言之就是要经过springmvc的请求，相当于我们配置了两个过滤器，一个专门过滤springmvc的请求，另一个过滤所有的请求，配置了这个过滤器我们就可以将进入到springmvc中的put方法给拦截下来并令其执行对应的方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd3441e5081c1b7e8ba829bbcbecf10ad.png)

配置完了这个之后，我们的请求就可以正确运行了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6c394ac69bc41e680e98d71835b2efd3.png)

最后我们可以写入我们的分别调用四个方法的代码如下

```
//接收GET请求配置方式
@RequestMapping(value = "{id}",method = RequestMethod.GET)
//接收GET请求简化配置方式
@GetMapping("{id}")
public String get(@PathVariable Integer id){
    System.out.println("restful is running ....get:"+id);
    return "success.jsp";
}

//接收POST请求配置方式
@RequestMapping(value = "{id}",method = RequestMethod.POST)
//接收POST请求简化配置方式
@PostMapping("{id}")
public String post(@PathVariable Integer id){
    System.out.println("restful is running ....post:"+id);
    return "success.jsp";
}

//接收PUT请求简化配置方式
@RequestMapping(value = "{id}",method = RequestMethod.PUT)
//接收PUT请求简化配置方式
@PutMapping("{id}")
public String put(@PathVariable Integer id){
    System.out.println("restful is running ....put:"+id);
    return "success.jsp";
}

//接收DELETE请求简化配置方式
@RequestMapping(value = "{id}",method = RequestMethod.DELETE)
//接收DELETE请求简化配置方式
@DeleteMapping("{id}")
public String delete(@PathVariable Integer id){
    System.out.println("restful is running ....delete:"+id);
    return "success.jsp";
}
```

当然，细心的同学可能会发现，我们这里似乎还多了另外的注解，没错，这种注解就是我们的原来的接受对应请求的简化配置方式，用了这个注解，我们就不用再配置什么特别的属性了，直接用对应的注解然后括号内传入对应的我们想要设置给数据的名字的字符串就行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2d70a2411211c321d81415f93b9d46d9.png)

- postman工具安装与使用

最后我们来介绍一款可以发送Restful风格请求的工具，其可以方便开发调试，这款工具就是postman

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4ad99add225efd23629cd8c45d5fdd76.png)

Restful风格的请求有许多种，但是我们最常用的就是我们最开始介绍的那四种，因此我们这里也只演示这四种

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc8d165a1d2f56222fa25ed02109b45ee.png)

开启服务器之后选择对应的请求然后输入网址发送就完了，要填入更多参数也可以自己设置，更多的内容我们就等到以后我们再说