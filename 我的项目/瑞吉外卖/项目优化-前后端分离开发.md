现在我们的项目还存在什么问题呢？那就是我们的代码是前端和后端都是放在一起开发的，这种开发存在许许多多的问题，具体请看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE65ef5ade19a2a2953f59076587ca304a.png)

那么我们要如何改善呢？这就需要使用到我们的前后端分离开发，前端人员负责前端代码，后端人员负责后端代码，这是目前开发的主流方式

前后端分离开发后，我们的工程结构也会发生变化，不会再混合到一个maven工程中，而是分为前端和后端工程，其中后端工程我们会打包部署到Tomcat中，而前端工程则是部署到Nginx中

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE29c47fee47cd00872f46bfa613103743.png)





那么接着我们面临的问题就是，我们前后端分离之后要怎么协调统一开发呢？这里我们可以使用如下的流程来进行，首先我们要定制接口，注意，这里的接口指的是一个http的请求地址，其下定义了请求路径、方式、参数等内容，具体可以看下图

接口的定制是最重要的，因为其定义了前后端开发的规则，如果接口定义不好，那么后面就全完了。前后端开发都有自测的数据和方法，自测没问题后就进行联调，看看前后端是否能正常工作，都没问题之后就进入到最后的提测步骤，也就是自动化测试，这一步骤都过了那就全没事了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe04810394888d20aad055359efc27ff1.png)

最后我们来了解前端开发所需要的技术栈，看看就行了，毕竟我们后端开发不太用得上前端代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE58a8963c0ff1467a47629e0c4545c3a7.png)

- YApi

我们此前讲过定义接口是最为重要的，那么我们现在就来学习定义接口的工具，YApi，请看介绍

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe49720358fb962addb589ac4a76df326.png)

关于YApi的知识，我们这里就不深入了解了，反正大伙们只要知道其可以定义接口并且给前后端定义一个规范就可以了，其部署需要前端的环境，而且最重要的是，这些接口的定义一般也是产品经理的事，我们只管写后端代码就完了的，所以我们不用管这个太多

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE084c3a0256087c3457e55199541bcd27.png)

- Swagger

虽然说这一节的内容是Swagger，但其实我们不用Swagger，而是使用Knife4j，其实javaMVC框架继承Swagger生成的Api文档的增强解决方案，本质上使用的还是Swagger，但是外部上我们用的是knife4j，功能更加强大

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfab373cf6552e9546fb31ea92364111e.png)

我们来看看我们的执行步骤，首先我们要做的当然是导入对应的坐标

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE689eaac4f0197c05ca61b6bbb29806f9.png)

然后我们需要导入相关的配置，这里需要加入两个注解，并且还需要额外在对应的配置类里添加两个方法

```
@Bean
public Docket createRestApi() {
    // 文档类型
    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.itheima.reggie.controller"))
            .paths(PathSelectors.any())
            .build();
}

private ApiInfo apiInfo() {
    return new ApiInfoBuilder()
            .title("瑞吉外卖")
            .version("1.0")
            .description("瑞吉外卖接口文档")
            .build();
}
```

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE099bf404fb1b389f754c60359f657a2f.png)

然后我们要操作对应的静态资源映射，否则我们是无法访问其对应的生成页面的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8a90b644c475e6145003b98e1520107b.png)

具体代码如下

```
registry.addResourceHandler("doc.html").addResourceLocations("classpath:/META-INF/resources/");
registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
```

最后我们需要在过滤器中设置不需要处理的请求路径，其实不设置也可以，但是这样的话我们每次访问对应的文档页面就要先登录一次，我反正是嫌弃麻烦，所以我们这里还是要设置下不需要处理的请求路径

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb20cbb1a9c44a7ae896498c1a03d896f.png)

最后这一切都搞定之后我们只需要直接访问这个路径就可以看到我们的接口描述文档了，http://localhost:8080/doc.html#/home

然后我们访问到了常用文档之后会发现这些文档虽然比较齐全，但是其说明很少，前端人员或者是其他同行看了可能会一下子不理解这是个什么几把玩意，因此我们需要使用Swagger提供给我们的注解，加到对应的我们的代码的地方，然后在我们的接口文档中就会对应生成这些说明

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8ef427ba4e2ead4ce4a24d7ec1d1f672.png)

首先我们来看看请求在类上的注解

```
@Api(tags = "套餐相关接口")
public class SetmealController {
```

然后是在实体类上的注解

```
@ApiModel("套餐")
public class Setmeal implements Serializable {
```

属性上的注解

```
@ApiModelProperty("主键")
private Long id;
```

请求方法上的注解及其传入的参数的说明的注解

```
@GetMapping("/page")
@ApiOperation(value = "套餐分页查询接口")
@ApiImplicitParams({
        @ApiImplicitParam(name = "page",value = "页码",required = true),
        @ApiImplicitParam(name = "pageSize",value = "每页记录数",required = true),
        @ApiImplicitParam(name = "name",value = "套餐名称",required = false),
})
public R<Page> page(int page,int pageSize,String name) {
```

