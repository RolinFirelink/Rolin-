现在这一节我们来学习事务，事务是在了解内容里比较重要的一节，我们就当他是正常要学习的内容来学习就可以了

- 事务的介绍

所谓事务就是由一条或多条SQL语句组成的一个执行单元，其特点是这个单元的内容要么同时成功，要么同时失败。其执行时一旦有一条语句执行失败，那么整个单元就会撤回到事务最初的状态，如果所有的语句都执行成功了，事务才会顺利执行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE52faabcc739a2027d0f4724eba8d790f.png)

在我们正式学习之前，我们还要做一些基本的数据准备，其代码如下

```
-- 创建db8数据库
        CREATE DATABASE db8;

        -- 使用db8数据库
        USE db8;

        -- 创建账户表
        CREATE TABLE account(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id
        NAME VARCHAR(20),        -- 账户名称
        money DOUBLE            -- 账户余额
        );
        -- 添加数据
        INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',1000);
```

- 事务的基本使用

事务的基本操作分三种，一种是开启事务，其关键字是START TRANSACTION，另一种是回滚事务，也就是当我们的事务执行中出现问题时我们需要执行的回滚操作，关键字是ROLLBACK，最后是提交事务，也就是当我们的事务成功执行之后，我们让我们的数据变成执行之后的状态，其关键字时COMMIT

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9c0b67d7d327744b0559206521097e8a.png)

我们可以写入示例代码如下

```
-- 张三给李四转账500元

        -- 开启事务
        START TRANSACTION;

        -- 1.张三账户-500
        UPDATE account SET money=money-500 WHERE NAME='张三';

        出错了...

        -- 2.李四账户+500
        UPDATE account SET money=money+500 WHERE NAME='李四';

        -- 回滚事务
        ROLLBACK;

        -- 提交事务
        COMMIT;
```

我们要使用事务，我们就要先开启事务（第4行），然后我们执行相应的语句，如果中间出错了，我们可以执行第15行的回滚事务，让我们的数据回滚到最初我们执行开始事务时的状态，如果我们确定我们的语句执行成功了，那么我们最后执行提交事务，也就是第18行，执行完毕就可以让我们的数据真正发生改变了

- 事务的提交方式

事务的提交方式有两种，一种是自动提交，一种是手动提交。其中前者是我们的MySQL默认的提交方式。我们可以通过语句SELECT @@AUTOCOMMIT;来查看我们事务的提交方式，这里@@就相当于是在查看全局变量。查看到的结果会是数字，1代表自动提交，0代表手动提交。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd7b3f4f1c2e3ce5e1f9ef7291687059a.png)

我们同样可以修改我们事务的提交方式，如果我们将事务的提交方式修改为手动提交，那么我们对任何数据的改动都会变成临时的，如果想要令其持久化到我们的数据中，要调用COMMIT;命令才可以实现。我们来看看其示例代码

```
/*
   查询事务提交方式：SELECT @@AUTOCOMMIT;  -- 1代表自动提交    0代表手动提交
   修改事务提交方式：SET @@AUTOCOMMIT=数字;
*/
-- 查询事务的提交方式
        SELECT @@autocommit;

UPDATE account SET money=2000 WHERE id=1;

        COMMIT;


        -- 修改事务的提交方式
        SET @@autocommit = 1;

```

- 事务的四大特征

这是面试中的经典问题，就是事务有什么特征，我们要知道，事务有四大特征。分别是原子性、一致性、隔离性、持久性。这四个性质可以简称为ACID，其中隔离性最为难，其中还可以设置不同的隔离级别，每个不同的隔离级别可能又会引发不同的问题，反正就特别麻烦。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3adae5e16872d3fbdd068bfba1a3ff57.png)

原子性（Atomicity）指的是事务包含的操作要么全部成功，要么就全部失败，回滚到执行事务之前的状态。其所带来的的结果是，事务的操作如果成功就必须完全应用到数据库，如果失败则不能对数据库本身产生任何影响。

一致性指的是事务必须使数据库从一个一致性状态变换到另外地一个一致性状态，简而言之就是事务执行之前和之后我们的数据库都必须处于一致性状态。那什么是一致性状态呢，其实我也不是很整得明白，反正先记住吧

隔离性指的是当多个用户并发访问数据表，比如说操作同一张表的时候，数据库为每一个用户开启的事务，不能被其他事务的操作干扰，多个并发事务要互相隔离，有点像线程安全的意思

持久性指的是一个事务一旦被提交，那么其对数据库中的数据改变是永久性的，即使数据库遇到了故障，也不会停止或者是丢失提交事务的操作。

- 事务的隔离级别

我们上一节说过，当多个客户端操作时，各个客户端的事务应该是隔离的，相互独立的，不受影响的。而如果多个事务操作同一批数据，就会产生各种不同的问题，我们需要设置不同的隔离级别来解决这些问题。隔离级别一共有四类，分别是read uncommitted（读未提交）、read committed（读已提交）、repeatable read（可重复读）、serializable（串行化）。具体的对应内容都写到下图中了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb0ee5c4ab4e537015399a90047eca79d.png)

我们接着来了解下不同隔离级别引发的不同问题的内容，所谓脏读指的是在一个事务处理时读到了另一个未提交事务中的数据。而不可重复读指的是一个事务处理过程中读到了另一个事物中修改并以提交的数据。而幻读分为两种，一种是指查询某数据不存在，而执行插入时却发现该记录已经存在，无法插入。另一种是查询数据时不存在，然后执行删除操作，却出现了删除成功的结果。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0a651f743e20e72aa496cb62c764d9c2.png)

接着我们来学习如何修改事务的隔离级别，这里要注意的一点是，一旦我们修改事务的隔离级别，我们要重启我们的SQLyog之后才会生效

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbdfc5af363899ef9bd6cb7807d9ab3ca.png)

示例代码如下：

```
/*
   查询隔离级别：SELECT @@TX_ISOLATION;
   修改隔离级别：SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;
*/
-- 查询事务隔离级别
        SELECT @@tx_isolation;

-- 修改事务隔离级别(修改后需要重新连接)
        SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

- 脏读问题的演示和解决

接下来我们来演示下脏读的问题，我们先来回顾下脏读的定义，脏读指的是一个事务中读取到了其他事务未提交的数据

这里为了模拟两个客户端的操作，我们需要打开两个SQLyog窗口，并分别写入代码。

第一个窗口的代码如下

```
/*
   脏读的问题演示和解决
   脏读：一个事务中读取到了其他事务未提交的数据
*/
-- 设置事务隔离级别为read uncommitted
        SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
        SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

        -- 开启事务
        START TRANSACTION;

        -- 转账
        UPDATE account SET money = money-500 WHERE NAME='张三';
        UPDATE account SET money = money+500 WHERE NAME='李四';

        -- 查询account表
        SELECT * FROM account;

        -- 回滚
        ROLLBACK;

        -- 提交事务
        COMMIT;
```

第二个窗口的代码如下

```
-- 查询事务隔离级别
        SELECT @@tx_isolation;

-- 开启事务
        START TRANSACTION;

        -- 查询account表
        SELECT * FROM account;

        -- 提交事务
        COMMIT;
```

这里我们就来说下脏读的问题，比方说，我们窗口一里创建了事务并执行了转账操作，但是我们的数据还没有提交，此时第二个窗口同样查询表，会发现我们的数据就是修改之后的数据，此时就发生了脏读现象。因为虽然得到的结果是一致的，但是因为窗口1还没有提交，如果窗口一因为各种情况发生了回滚，那么此时窗口2就会获得最初的数据，此时会脏读现象会提供给用户错误的信息。

解决脏读的方法也很简单，我们只要将我们的隔离方式下降一级就完了，此时只要窗口一的事务没有提交，窗口二查询的内容就还是没提交前的内容。

- 不可重复读的问题的演示和解决

我们同样需要两个窗口来演示我们的不可重复读的问题，我们同样来复习下不可重复读的定义，不可重复读指一个事务中读取到了其他事务已提交的数据

第一个窗口的代码如下

```
/*
   不可重复读的问题演示和解决
   不可重复读：一个事务中读取到了其他事务已提交的数据
*/
-- 设置事务隔离级别为read committed
        SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
        SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

        -- 开启事务
        START TRANSACTION;

        -- 转账
        UPDATE account SET money = money-500 WHERE NAME='张三';
        UPDATE account SET money = money+500 WHERE NAME='李四';

        -- 查询account表
        SELECT * FROM account;

        -- 提交事务
        COMMIT;
```

第二个窗口的代码如下

```
-- 查询隔离级别
        SELECT @@tx_isolation;

-- 开启事务
        START TRANSACTION;

        -- 查询account表
        SELECT * FROM account;

        -- 提交事务
        COMMIT;
```

其实，像我们上面，第一个窗口发生了转账并提交结束了事务之后，再第二个窗口里查询到的第一个窗口里已经修改的数据的时候，这时我们的不可重复读的问题就已经发生了。虽然说这个情况似乎是十分合乎逻辑的，但实际情况里其是有问题的。可能会出现上午A查询和下午B查询的结果不同的情况发生（因为上午和下午发生了数据的修改），这种情况有时候是不为我们所允许的。因此此时我们要解决这问题，解决这个问题的方式也很简单，就是将其隔离级别再下放一级。下放一级之后，我们即使在另一个事务提交之后，我们也查询不到修改之后的数据（但是查询动作可以执行），只有当两个事务都结束之后，我们才能够查询到对应的数据。

- 幻读问题的演示和解决

我们照例先来复习一下幻读的定义，幻读存在两种情况，如下所示

   查询某记录是否存在，不存在

   准备插入此记录，但执行插入时发现此记录已存在，无法插入

   或某记录不存在执行删除，却发现删除成功

同样我们这里需要两个窗口，先来看看窗口1的代码

```
/*
   幻读的问题演示和解决
   查询某记录是否存在，不存在
   准备插入此记录，但执行插入时发现此记录已存在，无法插入
   或某记录不存在执行删除，却发现删除成功
*/
-- 设置隔离级别为repeatable read
        SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
        SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;

        -- 开启事务
        START TRANSACTION;

        -- 添加记录
        INSERT INTO account VALUES (3,'王五',2000);
        INSERT INTO account VALUES (4,'赵六',3000);

        -- 查询account表
        SELECT * FROM account;

        -- 提交事务
        COMMIT;
```

接着来看看窗口2的代码

```
-- 查询隔离级别
        SELECT @@tx_isolation;

-- 开启事务
        START TRANSACTION;

        -- 查询account表
        SELECT * FROM account;

        -- 添加
        INSERT INTO account VALUES (3,'王五',2000);

        -- 提交事务
        COMMIT;
```

假设我们在窗口一中尝试插入一个新用户，但是我们不提交，然后我们在窗口2中查询，会查询到我们插入之前的数据情况，然后我们在窗口2中也执行插入，此时窗口2会一直卡顿，因为窗口1没提交，窗口2是无法执行的，然后窗口1提交，此时数据中就突然有了第三个数据了，此时窗口2会显示插入失败。这里发生的问题就是幻读，窗口2查询到的结果是没有该用户，插入应该是成功的，但实际上却是失败的。而对于另一个情况，我们也能很简单的猜测到，窗口2中执行删除，自然会一直等待，然后窗口1中提交，数据中就有了相应的数据，此时插入成功。

解决的方式同样是将隔离下放一级，当然，我们这里说的下放一级其实指的是图片上的往下看的意思，其实，最下面的那个权限是最高的，所以它发生的问题也最少，这个对前面的相同说法也是适用的。当我们将隔离权限提升至最高时，此时当窗口1没有提交时，窗口2执行查询都会直接卡住，除非窗口1提交事务完毕，否则就一直卡，这就相当于是直接把整个事务给锁住了，没有执行完就不许其他事务执行任何动作。

其安全性最高，同时效率也最差。

- 事务隔离级别的小结

最后我们的MySQL数据库里的默认隔离级别是repeatable read，不同的数据库或许有不同的隔离默认隔离级别

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3338f4238ecc18849f1fe70253482265.png)

注意，隔离级别从小到大安全性越来越高，效率越来越低，我们是不建议修改数据库默认的隔离级别的。至于脏读幻读和不可重复读的问题，我们后面会学习其他解决的方法，不要以为解决这些问题就只是嗯换隔离级别