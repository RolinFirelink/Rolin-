# 模板方法模式

到这里我们就开始学习行为型模式了，先来看看行为型模式的介绍吧

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE64c2d082a7e51918d61b818ed8b16d1a.png)

行为型模式分为类行为模式和对象行为模式，前者采用继承机制，后者采用组合或者聚合方式，后者的灵活性比前者高

## 模板方法模式介绍

我们先来学习模板方法模式，先来看看其定义和结构

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE1bf8d07b8b9bb308810335c54725a6ac.png)

照样是通过一个例子来加深我们的理解，先来看看例子的需求和类图

## 案例实现

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE29cb25d1160169c0bd78a3405566bea7.png)

首先我们创建抽象类，抽象类中应该要有固定的模板方法，这个方法对于每一个人来说都是一样的，不允许子类修改该方法，我们可以给其加入final关键字，所以我们的cookProcess方法才会这样构造

然后我们定义每一个具体要执行的方法，一样的方法我们直接写好，不一样的方法要有子类进行具体实现，我们就定义为抽象方法即可

```
public abstract class AbstractClass {

    //模板方法定义
    public final void cookProcess() {
        pourOil();
        heatOil();
        pourVegetable();
        pourSauce();
        fry();
    }

    public void pourOil() {
        System.out.println("倒油");
    }

    //第二步：热油是一样的，所以直接实现
    public void heatOil() {
        System.out.println("热油");
    }

    //第三步：倒蔬菜是不一样的
    public abstract void pourVegetable();

    //第四步：倒调味料是不一样
    public abstract void pourSauce();

    //第五步：翻炒是一样的，所以直接实现
    public void fry() {
        System.out.println("炒菜ing...");
    }
}

```

然后我们需要定义具体的子类，该子类当然需要实现其抽象方法，我们这里定义了两个子类，代码都大差不差，所以我们只展示其中一个

```
public class ConcreteClass_BaoCai extends AbstractClass{

    @Override
    public void pourVegetable() {
        System.out.println("蔬菜是包菜，下锅");
    }

    @Override
    public void pourSauce() {
        System.out.println("酱料是辣椒，下锅");
    }
}
```

然后我们在测试中写入代码如下，我们这里创建具体的子类，然后直接调用其对应的方法即可

```
public class Client {
    public static void main(String[] args) {
        //炒包菜
        //创建对象
        ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai();
        //调用炒菜的功能
        baoCai.cookProcess();
    }
}
```

然后我们来看看其优缺点和适用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE43f4a44a7e9c75ddf12965088bdf680b.png)

## JDK源码解析

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE0b4e4c01f0da85490710e31a95f6ec94.png)

# 策略模式

现在我们来学习策略模式，先来看看策略模式的概述

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEb14151aaae814aef92d93062016575f8.png)

简而言之是，我们可以选择的策略可以有很多，但是我们最终的目的总是一样的

## 策略模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE59490fb62a730f8ac8b467faccfdf1d6.png)

同样我们是用一个案例来加深我们的理解，来看看案例需求和类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE35073406983b61ac99aa8952a50d672f.png)

## 案例实现

首先我们创建抽象策略内，内部存放对应的抽象策略方法

```
public interface Strategy {
    void show();
}
```

然后创建具体的策略类，当然要实现我们的具体策略

```
public class StrategyA implements Strategy{

    @Override
    public void show() {
        System.out.println("买一送一");
    }
}
```

然后是我们的环境对象，其内部应该聚合策略类对象

```
public class SalesMan {

    //聚合策略类对象
    private Strategy strategy;

    public SalesMan(Strategy strategy) {
        this.strategy = strategy;
    }

    //由促销员展示促销活动给用户
    public void salesManShow() {
        strategy.show();
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
}
```

接着我们在对应的测试类中写入代码如下，可以得到我们想要的结果，能够正确调用不同的策略

```
public class Client {
    public static void main(String[] args) {
        //春节来了，使用策略1
        SalesMan salesMan = new SalesMan(new StrategyA());
        salesMan.salesManShow();

        salesMan.setStrategy(new StrategyB());
        salesMan.salesManShow();

        salesMan.setStrategy(new StrategyC());
        salesMan.salesManShow();
    }
}
```

然后我们来看看策略模式的优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE4ee6596a6dac801540d8b5d872b2cf49.png)

## JDK源码解析

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEd7cffd03626a95e4b5d7728f707b5872.png)

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEeb1d5607d3afcff72922f0115b609671.png)

直接记忆重点，我们的Arrays.sort方法使用了策略模式即可

# 命令模式

现在我们来学习命令模式，先来看看下面的案例

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE7e10ecfb8b8ca08d79627e8aba9e9967.png)

在我们这里有服务员、订单、厨师对象，服务员要将订单提供给厨师，一般我们会让服务员类聚合厨师类，这样服务员就可以往对应的厨师提供订单，但是我们的厨师是有可能会更换的，如果我们更换厨师，就要修改服务员的源代码，不符合开闭原则

## 命令模式介绍

此时我们就可以使用命令模式，将一个请求封装为一个对象，服务员通过该对象来联系厨师，这样就实现了解耦合

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE8c7ac5ce3ee66f334c7673e62f67d827.png)

接着我们来看看命令模式里具有的结构

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9276f575feeeaced0df4cb4e72b9f43d.png)

接着我们将上面的案例用代码实现，在上面的案例中，如果用命令模式实现，那么服务员就是调用者角色、厨师就是接收者角色，而订单则是命令类角色，来看看其类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE119ea492809ff3979db77832ca344660.png)

首先我们创建订单类，要发送请求当然需要一个订单类，我们这里提供餐桌号码的属性，所用户所辖的餐品和份数则使用Map集合来存储，我们最后提供一个设置食物的方法，这个方法就类似于往订单中写入顾客要的数据，要求提供事物名字和数量，然后我们将其设置到Map集合中

## 案例实现

```
public class Order {
    //餐桌号码
    private int diningTable;

    //所下的餐品及份数
    private Map<String,Integer> foodDir = new HashMap<>();

    public int getDiningTable() {
        return diningTable;
    }

    public void setDiningTable(int diningTable) {
        this.diningTable = diningTable;
    }

    public Map<String, Integer> getFoodDir() {
        return foodDir;
    }

    public void setFood(String name,int num) {
        foodDir.put(name,num);
    }
}
```

然后我们当然要创建厨师对象，厨师对象只有一个执行做菜的方法，需要传入对应的名字和份数

```
public class SeniorChef {
    public void makeFood(String name,int num) {
        System.out.println(num + "份" + name);
    }
}
```

接着我们设置抽象命令类，只是一个接口

```
//抽象命令类
public interface Command {
    void execute();
}
```

接着我们写入具体命令类，具体命令类中要实现我们的抽象命令类，然后其下应该要持有接收者对象，也就是厨师对象，以及被接受的对象，也就是订单类，其是请求的根本，提供对有的构造方法，然后重写发送请求的方法

这里我们发送请求的方法就是遍历订单中的Map集合，拿到所有的内容之后调用厨师的做菜方法做菜就完了

```
//具体命令类
public class OrderCommand implements Command{

    //持有接收者对象
    private SeniorChef receiver;
    private Order order;

    public OrderCommand(SeniorChef receiver, Order order) {
        this.receiver = receiver;
        this.order = order;
    }

    @Override
    public void execute() {
        System.out.println(order.getDiningTable()+"桌的订单：");
        Map<String, Integer> foodDir = order.getFoodDir();
        //遍历map集合
        Set<String> set = foodDir.keySet();
        for (String foodName : set) {
            receiver.makeFood(foodName,foodDir.get(foodName));
        }
        System.out.println(order.getDiningTable()+"桌的饭菜准备完毕");
    }
}
```

最后我们要定义请求者对象，也就是服务员，服务员可以拥有多个订单，所以拥有List属性，提供设置新订单的方法，这是当然，服务员当然要可以接受订单，然后提供发起命令的方法，如果命令没有问题，就调用请求对象中的发送请求方法，其会调动厨师的做菜方法来做订单中对应的菜

```
public class Waiter {

    //持有多个命令对象
    private List<Command> commands = new ArrayList<>();

    public void setCommand(Command cmd){
        //将cmd对象存储到list集合中
        commands.add(cmd);
    }

    //发起命令的功能
    public void orderUp() {
        System.out.println("服务员对厨师说订单来了");
        for (Command command : commands) {
            if(command!=null){
                command.execute();
            }
        }
    }
}
```

最后我们在测试类中写入代码如下，我们这里首先设置两个订单对象，然后创建一个厨师对象和两个命令对象，命令对象需要厨师对象和订单对象，我们这里相当于是让两个命令对象将厨师和对应的命令绑定起来，然后将这两个命令对象设置到服务员对象中，接着让服务员发起命令，即可让服务员发起所有的命令请求，令其正确执行

```
public class Client {
    public static void main(String[] args) {
        //创建第一个订单对象
        Order order = new Order();
        order.setDiningTable(1);
        order.setFood("西红柿鸡蛋面",1);
        order.setFood("小杯可乐",2);

        //创建第二个订单对象
        Order order2 = new Order();
        order2.setDiningTable(2);
        order2.setFood("尖椒肉丝盖饭",1);
        order2.setFood("小杯雪碧",2);

        //创建厨师对象
        SeniorChef receiver = new SeniorChef();
        //创建命令对象
        OrderCommand cmd1 = new OrderCommand(receiver,order);
        OrderCommand cmd2 = new OrderCommand(receiver,order2);

        //创建调用者（服务员对象）
        Waiter waiter = new Waiter();
        waiter.setCommand(cmd1);
        waiter.setCommand(cmd2);

        //让服务员发起命令
        waiter.orderUp();
    }
}
```

最后我们来看看命令模式的优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE3939eacc337e307df25c94d18d78164f.png)

## JDK源码解析

JDK中的Runable就是一个典型的命令模式，Thread是调用者，而start则是我们要执行的请求命令，接收者是有我们程序员自己定义的一个全新的类

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEcb2b113b60c8acdf726403ddb2134e46.png)

# 责任链模式

现在我们来学习责任链模式，先来看看我们的现实生活中的情况

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE2d0c130b5ed7e5b47cf87c81b62ff1fe.png)

接着我们来看看定义和结构

## 责任链模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9e70ed58f60ec229452734c1e5d15fdb.png)

我们现在来讲解一个案例来加深我们的理解，先来看看案例需求和类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE8860990eb76056bf55ccc6758a498891.png)

首先我们要创建的当然是请假条类，没有请假条那怎么发送请求？这里进行基本的构造，提供了对应的构造方法和setandget方法

## 案例实现

```
//请假条类
public class LeaveRequest {
    //姓名
    private String name;

    //请假天数
    private int num;

    //请假内容
    private String content;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public LeaveRequest(String name, int num, String content) {
        this.name = name;
        this.num = num;
        this.content = content;
    }
}

```

然后创建抽象处理者类，我们这里提供三个常量用于设置后续不同组员能处理的请假时长，之所以设置常量，是因为后续我们可能会改动他们的权限，此时使用常量我们就可以轻易尽量减少源代码的多次改动

然后我们其中还要聚合另外一个Handler对象，这就意味着我们的一个组长可能有上一级的领导，我们提供对应的构造方法，再提供一个提交请假条的方法，提供请假条的方法先判断当前组长能否成功处理，若能则进行处理，不能则继续提交给上一级

最后还有一个各级领导处理请假条的方法，这个方法由于每个不同级别的领导处理的权限不同，因此设置为抽象方法

```
public abstract class Handler {
    protected final static int NUM_ONE = 1;
    protected final static int NUM_THREE = 3;
    protected final static int NUM_SEVEN = 7;

    //该领导处理的请求天数区间
    private int numStart;
    private int numEnd;

    //声明后继者(声明上级领导)
    private Handler nextHandler;

    public Handler(int numStart) {
        this.numStart = numStart;
    }

    public Handler(int numStart, int numEnd) {
        this.numStart = numStart;
        this.numEnd = numEnd;
    }

    //设置上级领导对象
    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    //各级领导处理请假条的方法
    protected abstract void handleLeave(LeaveRequest leave);

    //提交请假条
    public void submit(LeaveRequest leave) {
        if(this.nextHandler != null && leave.getNum() > this.numEnd){
            //提交给上级领导进行审批
            this.nextHandler.submit(leave);
        }else {
            //该领导进行审批
            this.handleLeave(leave);
            System.out.println("流程结束!");
        }
    }
}
```

然后我们创建具体的处理者类，分别是小组长，主管和总经理类，他们都要实现抽象处理者类，其对应的构造方法则传入我们想要设置的能够处理的请假时长，重写的方法则是固定的处理请假的方法

```
//小组长类，具体的处理者
public class GroupLeader extends Handler{

    public GroupLeader() {
        super(0,Handler.NUM_ONE);
    }

    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println(leave.getName()+"请假"+leave.getNum()+"day,"+leave.getContent()+"。");
        System.out.println("小组长审批通过");
    }
}
```

最后我们在客户端中写入如下代码，我们这里先创建请假对象，然后创建各个领导对象，设置对应的领导间具有的层级关系，最后再先由小组长对象提交请假申请，最后可以得到我们想要的结果

```
public class Client {
    public static void main(String[] args) {
        //创建一个请假条对象
        LeaveRequest leave = new LeaveRequest("小明",1,"身体不适");

        //创建各级领导对象
        GroupLeader groupLeader = new GroupLeader();
        Manager manager = new Manager();
        GeneralManager generalManager = new GeneralManager();

        //设置处理者链
        groupLeader.setNextHandler(manager);
        manager.setNextHandler(generalManager);

        //小明提交请假申请
        groupLeader.submit(leave);
    }
}

```

最后我们来看看其优缺点

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEac23f22dcfd815dfcd909822110db45d.png)

## JDK源码解析

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEdecd1b66f8b0834e06cd43fffed1cab5.png)



![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9444e16139dc36fd75ed614655605038.png)

上面的源码是我们经过处理之后的简单版本的，很好理解我就不多提了，我们记住，FilterChain是职责链（过滤器）模式的典型应用就行了

# 状态模式

现在我们来学习状态模式，这次跟以往有些不一样，我们先来构造一个案例，再来分析下其缺点

先来看看该例子的需求和类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE727fafb35cd5827cb43171498ce72bb8.png)

首先我们定义对应的接口类然后定义对应的电梯状态的常量，我们这里之所以定义一个接口，是为了能够让以后的类都可以被我们赋予这个状态（如果有这个业务需求的话）

```
public interface ILift {
    //定义四个电梯状态的常量
    int OPENING_STATE = 1;
    int CLOSING_STATE = 2;
    int RUNNING_STATE = 3;
    int STOPPING_STATE = 4;

    //设置电梯状态的功能
    void setState(int state);

    //电梯操作功能
    void open();
    void close();
    void run();
    void stop();
}
```

然后我们创建其具体的实现类，其下有对应的属性变量用于记录状态，然后重写了设置状态的方法，接着我们实现其四个功能，每个功能中我们都是用switch方法进行判断，只有其处于对应的状态中我们才执行对应的方法，否则就是直接跳出

```
public class Lift implements ILift{

    //声明一个变量记录当前电梯状态
    private int state;

    @Override
    public void setState(int state) {
        this.state=state;
    }

    //执行开门动作
    @Override
    public void open() {
        switch (this.state) {
            case OPENING_STATE://门已经开了，不能再开门了
                //do nothing
                break;
            case CLOSING_STATE://关门状态，门打开:
                System.out.println("电梯打开了...");
                this.setState(OPENING_STATE);
                break;
            case RUNNING_STATE:
                //do nothing 运行时电梯不能开门
                break;
            case STOPPING_STATE:
                System.out.println("电梯开了...");//电梯停了，可以开门了
                this.setState(OPENING_STATE);
                break;
        }
    }

    @Override
    public void close() {
        switch (this.state) {
            case OPENING_STATE:
                System.out.println("电梯关门了。。。");//只有开门状态可以关闭电梯门，可以对应电梯状态表来看
                this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了
                break;
            case CLOSING_STATE:
                //do nothing //已经是关门状态，不能关门
                break;
            case RUNNING_STATE:
                //do nothing //运行时电梯门是关着的，不能关门
                break;
            case STOPPING_STATE:
                //do nothing //停止时电梯也是关着的，不能关门
                break;
        }
    }

    @Override
    public void run() {
        switch (this.state) {
            case OPENING_STATE://电梯不能开着门就走
                //do nothing
                break;
            case CLOSING_STATE://门关了，可以运行了
                System.out.println("电梯开始运行了。。。");
                this.setState(RUNNING_STATE);//现在是运行状态
                break;
            case RUNNING_STATE:
                //do nothing 已经是运行状态了
                break;
            case STOPPING_STATE:
                System.out.println("电梯开始运行了。。。");
                this.setState(RUNNING_STATE);
                break;
        }
    }

    @Override
    public void stop() {
        switch (this.state) {
            case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下)
                //do nothing
                break;
            case CLOSING_STATE://关门时才可以停止
                System.out.println("电梯停止了。。。");
                this.setState(STOPPING_STATE);
                break;
            case RUNNING_STATE://运行时当然可以停止了
                System.out.println("电梯停止了。。。");
                this.setState(STOPPING_STATE);
                break;
            case STOPPING_STATE:
                //do nothing
                break;
        }
    }
}

```

然后我们在客户端类写入代码如下，能够正确得到我们想要的结果，电梯的对应方法只有在电梯处于对应状态时才可以执行

```
public class Client {
    public static void main(String[] args) {
        //创建电梯对象
        Lift lift = new Lift();

        //设置当前电梯的状态
        lift.setState(ILift.RUNNING_STATE);

        //打开
        lift.open();
        lift.close();
        lift.run();
        lift.stop();
    }
}
```

那么我们上面的程序存在什么问题呢？

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE8560fe771933a88044b3e26c3341d3dd.png)

我们为了解决这个问题，就可以使用状态模式，先来看看状态模式的定义和结构

## 状态模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE7144b3a38707d4db8c5e323ed8c031f5.png)

接着我们就要使用状态模式来改善我们之前的案例，先来看看改进之后的类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE7b969a4a88592b218d627a85fb6aec0a.png)

那么首先我们要创建抽象的接口类，该类封装了我们类中拥有的方法以及我们的环境类，可以看到我们这个抽象类聚合了环境变量的属性，然后我们拥有电梯开启关闭运行停止的四个方法（环境类我们下面会创建）

## 案例改进

```
public abstract class LiftState {

    //声明环境变量类
    protected Context context;

    public void setContext(Context context){
        this.context = context;
    }

    //电梯开启
    public abstract void open();

    //电梯关闭
    public abstract void close();

    //电梯运行
    public abstract void run();

    //电梯停止
    public abstract void stop();
}

```

接着我们来实现我们的环境类，我们的环境类中组合了四个状态类（这四个类后面会实现），都是作为常量存在，同时其自身还聚合了电梯类，其下提供的设置类中不但会聚合当前的电梯类，还会聚合电梯类中的当前类（也就是环境类）

对应的四个方法则是直接调用我们组合的类中的对应方法

```
public class Context {

    //定义对应状态对象的常量
    public final static OpeningState OPENING_STATE = new OpeningState();
    public final static ClosingState CLOSING_STATE = new ClosingState();
    public final static RunningState RUNNING_STATE = new RunningState();
    public final static StoppingState STOPPING_STATE = new StoppingState();

    //定义一个当前电梯状态变量
    private LiftState liftState;

    public LiftState getLiftState() {
        return liftState;
    }

    //设置当前状态对象
    public void setLiftState(LiftState liftState) {
        this.liftState = liftState;
        //设置当前状态对象中的Context对象
        this.liftState.setContext(this);
    }

    public void open() {
        this.liftState.open();
    }

    public void close() {
        this.liftState.close();
    }

    public void run() {
        this.liftState.run();
    }

    public void stop() {
        this.liftState.stop();
    }
}

```

然后我们再来创建对应的四个状态类，其都应继承我们的抽象功能类，首先是开启状态的类

```
public class OpeningState extends LiftState{
    //开启当然可以关闭了，我就想测试一下电梯门开关功能
    @Override
    public void open() {
        System.out.println("电梯门开启...");
    }

    @Override
    public void close() {
        //状态修改
        super.context.setLiftState(Context.CLOSING_STATE);
        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作
        super.context.getLiftState().close();
    }

    //电梯门不能开着就跑，这里什么也不做
    @Override
    public void run() {
        //do nothing
    }

    //开门状态已经是停止的了
    @Override
    public void stop() {
        //do nothing
    }
}
```

然后是关闭状态的类

```
public class ClosingState extends LiftState{
    @Override
    //电梯门关闭，这是关闭状态要实现的动作
    public void close() {
        System.out.println("电梯门关闭...");
    }

    //电梯门关了再打开，逗你玩呢，那这个允许呀
    @Override
    public void open() {
        super.context.setLiftState(Context.OPENING_STATE);
        super.context.open();
    }


    //电梯门关了就跑，这是再正常不过了
    @Override
    public void run() {
        super.context.setLiftState(Context.RUNNING_STATE);
        super.context.run();
    }

    //电梯门关着，我就不按楼层
    @Override
    public void stop() {
        super.context.setLiftState(Context.STOPPING_STATE);
        super.context.stop();
    }
}
```

接着是运行状态的类

```
public class RunningState extends LiftState{
    //运行的时候开电梯门？你疯了！电梯不会给你开的
    @Override
    public void open() {
        //do nothing
    }

    //电梯门关闭？这是肯定了
    @Override
    public void close() {//虽然可以关门，但这个动作不归我执行
        //do nothing
    }

    //这是在运行状态下要实现的方法
    @Override
    public void run() {
        System.out.println("电梯正在运行...");
    }

    //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了
    @Override
    public void stop() {
        super.context.setLiftState(Context.STOPPING_STATE);
        super.context.stop();
    }
}

```

最后是停止状态的类

```
public class StoppingState extends LiftState{
    //停止状态，开门，那是要的！
    @Override
    public void open() {
        //状态修改
        super.context.setLiftState(Context.OPENING_STATE);
        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作
        super.context.getLiftState().open();
    }

    @Override
    public void close() {//虽然可以关门，但这个动作不归我执行
        //状态修改
        super.context.setLiftState(Context.CLOSING_STATE);
        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作
        super.context.getLiftState().close();
    }

    //停止状态再跑起来，正常的很
    @Override
    public void run() {
        //状态修改
        super.context.setLiftState(Context.RUNNING_STATE);
        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作
        super.context.getLiftState().run();
    }

    //停止状态是怎么发生的呢？当然是停止方法执行了
    @Override
    public void stop() {
        System.out.println("电梯停止了...");
    }
}

```

然后我们在测试类中写入代码如下，最后可以发现其会正确执行对应状态下才能执行的方法

```
public class Client {
    public static void main(String[] args) {
        //创建环境角色对象
        Context context = new Context();
        //设置当前电梯状态
        context.setLiftState(new ClosingState());

        context.open();
        context.close();
        context.run();
        context.stop();
    }
}

```

然后我们来看看其优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEf956ba66674597c8d2f53666843ac9fd.png)

其实说实话我觉得搞了这么多这玩意最后的代码样式还不如一开始的呢，起码那个好理解多了

# 观察者模式

现在我们来学习观察者模式，先来看看其定义以及结构

## 观察者模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE777e7f67f2efe7ccb212823233b81f03.png)

我们可以通过观察者模式实现广播的功能或者是监听某个对象的功能，与这种设计模式最相似现实例子就是公众号订阅更新功能，一旦订阅号更新，则会以广播的形式通知其下的所有用户对象更新的新文章，那么接下来我们就要来完成这么一个公众号更新的例子，先来看看其需求和类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEba90e43b0cb4c4e5c79d113cf83c365e.png)

## 案例实现

首先我们创建抽象观察者类，其只定义一个更新接口

```
//抽象观察者类
public interface Observer {
    void update(String message);
}
```

接着我们定义抽象主题角色类，其下含有观察者对象，而且具有添加删除更新的方法，我们可以直接将其理解为是公众号对象，不过我们这里提供的是一个接口

```
//抽象主题角色类
public interface Subject {

    //添加订阅者（添加观察者对象）
    void attach(Observer observer);

    //删除订阅者
    void detach(Observer observer);

    //通知订阅者更新消息
    void notify(String message);
}
```

然后我们定义抽象具体的主题角色类，我们这里定义一个集合来存储多个观察者对象，这是当然的，因为一个公众号可以有多个微信用户，其下对应的增加用户，删除用户和更新的方法，更新使用foreach循环调用方法实现

```
public class SubscriptionSubject implements Subject{

    //定义一个集合，用来存储多个观察者对象
    private List<Observer> weiXinUserList = new ArrayList<>();

    @Override
    public void attach(Observer observer) {
        weiXinUserList.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        weiXinUserList.remove(observer);
    }

    @Override
    public void notify(String message) {
        //遍历集合
        for (Observer observer : weiXinUserList) {
            //调用观察者中的update方法
            observer.update(message);
        }
    }
}

```

最后我们定义具体观察者类，其就是实现一个更新的方法，当然，我们这里的观察者类其实一个微信用户类，因此我们这里提供保存用户名的属性并且提供构造方法

```
public class WeiXinUser implements Observer{

    private String name;

    public WeiXinUser(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name+"---"+message);
    }
}

```

最后我们写入我们的测试类的代码如下，可以得到我们想要的结果，三个用户都调用了更新方法

```
public class Client {
    public static void main(String[] args) {
        //1.创建公众号对象
        SubscriptionSubject subject = new SubscriptionSubject();

        //2.订阅公众号
        subject.attach(new WeiXinUser("孙悟空"));
        subject.attach(new WeiXinUser("猪八戒"));
        subject.attach(new WeiXinUser("沙悟净"));

        //3.公众号更新，发出消息给订阅者(观察者对象)
        subject.notify("黑马更新了");
    }
}
```

然后我们来看看观察者模式的优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE841c97b0ab5e63eb103efb8cfe6647fe.png)

## JDK中提供的实现

在Java中提供了两个接口（分别是抽象目标类和抽象观察者类）用于实现观察者模式，用户只需要实现这两个就可以实现观察者模式，即可以实现监听器或者是广播的效果

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEe00722fb409087fc60760db79b834bc7.png)

首先我们来介绍抽象目标类Observable

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE21c7b30b0753199b1de2892917302e8f.png)

其下有一个Vector的集合成员变量，我们直接把它当List集合对象来看待就行了其实，其第一个添加方法会判断集合中是否存在对应的对象，若存在再添加，具体请看源码

```
public synchronized void addObserver(Observer o) {
    if (o == null)
        throw new NullPointerException();
    if (!obs.contains(o)) {
        obs.addElement(o);
    }
}
```

第二个更新的方法本质还是使用for循环来遍历所有对象并调用其下的更新方法，之所以越晚加入就越快得到通知，是因为遍历时其是从后往前遍历的

```
public void notifyObservers(Object arg) {

    Object[] arrLocal;

    synchronized (this) {
        if (!changed)
            return;
        arrLocal = obs.toArray();
        clearChanged();
    }

    for (int i = arrLocal.length-1; i>=0; i--)
        ((Observer)arrLocal[i]).update(this, arg);
}
```

第三个方法简单来说就是一个布尔类型的变量，该变量的主要作用就是用于判断我们的最初的对象是否进行了更新，若更新则将其赋值为true，然后调用我们的第二个方法，自然会通知，同时通知完之后再调用clearChanged()方法将对应的布尔类型的值设置为false，即是未更新

```
protected synchronized void setChanged() {
    changed = true;
}
```

然后是抽象观察者类的接口，这个没什么值得说的，直接用就行

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE1f78a358f3cdd9743920d15c34b4b889.png)

然后我们可以做一个警察抓小偷的简单例子来加深理解

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE1cc741f423cffb134d67639fbb59e23a.png)

首先我们创建小偷对象，其需要继承Obsevable类，其下我们提供名字属性，一旦偷东西我们就调用其父类的标记更新方法和状态更新方法

```
public class Thief extends Observable {

    private String name;

    public Thief(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void steal() {
        System.out.println("小偷：我偷东西了，有没有人来抓我！！！");
        super.setChanged(); //changed  = true
        super.notifyObservers();
    }
}
```

然后我们创建观察者类，令其实现Observer接口，其下提供警察的名字属性，同时我们重写父类接口的更新方法

```
public class Policemen implements Observer {

    private String name;

    public Policemen(String name) {
        this.name = name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public void update(Observable o, Object arg) {
        System.out.println("警察：" + ((Thief) o).getName() + "，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！");
    }
}
```

最后我们可以写入我们的测试类的代码如下，我们这里第8行的代码相当于是让警察盯住小偷，也相当于是用户订阅了某个公众号（当然，这里小偷是公众号），一旦小偷的状态更新，我们就调用其下的更新方法，让警察抓小偷，这很好理解，就类似于公众号，功能几乎一样的，只不过我们这里提供了一个实现方式而已，我们可以通过这个接口直接实现它

```
public class Client {
    public static void main(String[] args) {
        //创建小偷对象
        Thief t = new Thief("隔壁老王");
        //创建警察对象
        Policemen p = new Policemen("小李");
        //让警察盯着小偷
        t.addObserver(p);
        //小偷偷东西
        t.steal();
    }
}
```

# 中介者模式

现在我们来学习中介者模式，先来看看其概述

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE8c4c704fb2314d417f4d6e77c5fa2c23.png)

简单来说就是不要和陌生人讲话的原则，如果不同对象建立直接访问的关系，那么最终得到的对象就会是十分复杂的，因此我们这里提供中介者，让不同对象之间关联中介者，这样可以减低其耦合性

这个很好理解，就好像我们买房子的时候，我们一般不会直接去找卖房子的人，而是寻找对应的房屋中介，通过房屋中介来完成购房，如果我们需要什么，我们也直接去找房屋中介即可，不需要去关心具体的房主

然后我们来看看中介者模式的定义和结构

## 中介者模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE5164ed8cab8e689d542b3fa719083b9b.png)

同样的，我们来完成一个案例来加深我们对该模式的理解，先来看看案例需求以及其类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE21a1d17a3eec69636ba72c14219ddd04.png)

## 案例实现

首先我们创建抽象中介者类，其可以是一个接口，也可以是抽象类，我们这里设置为抽象类的形式，其下提供一个交流的抽象方法，传入的参数是用于交流的信息和发入交流信息的同事类

```
//抽象中介者类
public abstract class Mediator {
    public abstract void constact(String message,Person person);
}
```

首先我们创建抽象的同事类，其是一个抽象类，具有名字和中介者属性，提供给其对应的构造方法即可

```
//抽象同事类
public abstract class Person {

    protected String name;
    protected Mediator mediator;

    public Person(String name, Mediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }
}

```

接着我们创建具体的同时角色类，在这个案例里代表的其实就是房主，我们令其实现抽象同事类，首先实现其构造方法，然后我们提供两个方法，第一个方法是和中介沟通的方法，直接传入信息和当前类的对象到中介者类中的沟通方法即可，然后还有一个获取信息的方法，打印房主名字和信息即可

```
//具体的同事角色类
public class HouseOwner extends Person{
    public HouseOwner(String name, Mediator mediator) {
        super(name, mediator);
    }

    //和中介联系（沟通）
    public void constact(String message){
        mediator.constact(message,this);
    }

    //获取信息
    public void getMessage(String message) {
        System.out.println("房主"+name+"获取到的信息是"+message);
    }
}
```

然后我们还要创建一个买房对象的具体同事角色类，同样提供对应的两个方法，无非做一些调试而已

```
//具体的同事角色类
public class Tenant extends Person{
    public Tenant(String name, Mediator mediator) {
        super(name, mediator);
    }

    //和中介联系（沟通）
    public void constact(String message){
        mediator.constact(message,this);
    }

    //获取信息
    public void getMessage(String message) {
        System.out.println("租房者"+name+"获取到的信息是"+message);
    }
}
```

最后我们创建具体中介者角色，其下聚合了房主和租房者对象，提供对应的getandset方法然后重写父类的constact方法，我们这里对传入的对象进行判断，若其是卖房者，则调用买房者的获得买房者信息的方法，反之则调用卖房者的获得对应信息的方法

```
//具体的中介者角色类
public class MediatorStructure extends Mediator{

    //聚合房主和租房者对象
    private HouseOwner houseOwner;
    private Tenant tenant;

    public HouseOwner getHouseOwner() {
        return houseOwner;
    }

    public void setHouseOwner(HouseOwner houseOwner) {
        this.houseOwner = houseOwner;
    }

    public Tenant getTenant() {
        return tenant;
    }

    public void setTenant(Tenant tenant) {
        this.tenant = tenant;
    }

    @Override
    public void constact(String message, Person person) {
        if(person==houseOwner){
            tenant.getMessage(message);
        }else {
            houseOwner.getMessage(message);
        }
    }
}

```

最后我们可以在测试类中写入代码如下，我们首先创建中介者、租房者、房主对象，然后将对应的房主和租房者聚合到中介者对象中，然后我们调用租房者的沟通方法，其就会调用中介者的沟通方法，中介者判断到其是租房者后，其就会将对应的信息传达给房主，这样就完成了一个信息的转调，对于房主调用对应的沟通方法而言，其过程也是一样的

```
public class Client {
    public static void main(String[] args) {
        //创建中介者对象
        MediatorStructure mediator = new MediatorStructure();

        //创建租房者对象
        Tenant tenant = new Tenant("李四",mediator);

        //创建房主对象
        HouseOwner houseOwner = new HouseOwner("张三",mediator);

        //中介者要知道具体的房主和租房者
        mediator.setTenant(tenant);
        mediator.setHouseOwner(houseOwner);

        tenant.constact("我要租三室房");
        houseOwner.constact("我这里有三室的房子");
    }
}
```

最后我们来看看中介者模式的优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEbad4416c311448db26890e733cbc5375.png)

# 迭代器模式

现在我们来学习迭代器模式，这个模式就要提及我们远古时候的记忆了，以前学习过的东西给我们埋伏笔了属于是

首先我们先来看看其概述以及结构

## 迭代器模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE2994bc7a37dc914b01ff1f85a7df7f89.png)

看着就感觉非常的相似，非常的有感觉啊，好像我们之前学习集合的时候就学过这玩意啊

我们照样通过一个案例来加深我们对该模式的理解，先看看案例需求以及类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9b6e5b45f0f0386899d5f79cc246ada0.png)

## 案例实现

首先我们需要创建对应的学生类，然后提供对应的方法

```
package com.login;

public class Student {
    private String name;
    private String number;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", number='" + number + '\'' +
                '}';
    }

    public Student() {
    }

    public Student(String name, String number) {
        this.name = name;
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }
}
```

然后我们创建抽象迭代器接口，其下定义两个方法，判断是否还有元素以及获取下一个元素

```
//抽象迭代器角色接口
public interface StudentIterator {

    //判断是否还有元素
    boolean hasNext();

    //获取下一个元素
    Student next();
}

```

接着我们创建具体的得带器角色类，其下提供两个属性，第一个是集合对象，第二个是一个坐标，用于记录遍历时的位置，其下要实现接口中的两个方法，第一个方法是判断还有没有下一个元素，我们直接判断当前位置是否到达集合最大位置即可，第二个方法是获得集合中指定位置的元素，直接获得对应坐标的元素再令下标+1即可

```
//具体迭代器角色类
public class StudentIteratorImpl implements StudentIterator{

    private List<Student> list;
    private int position = 0;//用于记录遍历时的位置

    public StudentIteratorImpl(List<Student> list) {
        this.list = list;
    }

    @Override
    public boolean hasNext() {
        return position<list.size();
    }

    @Override
    public Student next() {
        //从集合中获取指定位置的元素
        return list.get(position++);
    }
}

```

然后我们再创建一个抽象聚合接口，其下有添加、删除学生功能，而最重要的是获取迭代器对象的功能

```
//抽象聚合接口
public interface StudentAggregate {

    //添加学生功能
    void addStudent(Student stu);

    //删除学生功能
    void removeStudent(Student stu);

    //获取迭代器对象功能
    StudentIterator getStudentIterator();
}
```

接着我们创建抽象聚合的即可的实现类，可以看到我们这里实现这三个方法，而获取迭代器对象的方法就是直接返回一个迭代器对象即可

```
public class StudentAggregateImpl implements StudentAggregate{

    private List<Student> list = new ArrayList<>();

    @Override
    public void addStudent(Student stu) {
        list.add(stu);
    }

    @Override
    public void removeStudent(Student stu) {
        list.remove(stu);
    }

    @Override
    public StudentIterator getStudentIterator() {
        return new StudentIteratorImpl(list);
    }
}

```

最后我们可以在测试类中写入我们的代码如下，首先我们创建聚合对象，接着往其下添加四个学生对象，然后获取迭代器对象再通过while循环遍历即可

```
public class Client {
    public static void main(String[] args) {
        //创建聚合对象
        StudentAggregateImpl aggregate = new StudentAggregateImpl();
        //添加元素
        aggregate.addStudent(new Student("张三","001"));
        aggregate.addStudent(new Student("李四","002"));
        aggregate.addStudent(new Student("王五","003"));
        aggregate.addStudent(new Student("赵六","004"));

        //遍历聚合对象

        //1.获取迭代器对象
        StudentIterator iterator = aggregate.getStudentIterator();

        //2.遍历
        while (iterator.hasNext()){
            //3.获取元素
            Student next = iterator.next();
            System.out.println(next.toString());
        }
    }
}
```

最后我们来看看其优缺点是使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEdb41370cd39084a0adc5a949eb2649b9.png)

## JDK源码解析

这个没啥值得说的，以前都学过了都，直接看图吧

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEa5f309114e444268dbf869d6c04ef918.png)

# 访问者模式

现在我们来学习下访问者模式，首先我们来看看其定义和结构

## 访问者模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE114b42b5f5c47cc0b83ad2be02ecb8f0.png)

当然，只看上面的说明肯定是空洞的，我们同样通过一个例子来加深理解，先来看看其需求和类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE690bb1a25cca8888cbf589017c11928c.png)

## 案例实现

那么首先我们创建抽象访问者角色，其下提供两个喂食方法，分别喂食我们的猫和狗，为什么不统一用Animal接口来表示？因为如果使用统一的接口表示，后续我们喂食的时候将无法具体对应喂食到某个宠物，只能喂食整个宠物一个大的类别

```
//抽象访问者角色
public interface Person {

    void feed(Cat cat);

    void feed(Dog dog);

}

```

然后我们定义主人类和路人类，其都实现Person类并重写其下的方法（只展示一个）

```
public class Owner implements Person{

    @Override
    public void feed(Cat cat) {
        System.out.println("主人喂食猫");
    }

    @Override
    public void feed(Dog dog) {
        System.out.println("主人喂食狗");
    }
}
```

接着我们定义抽象动物类，其实抽象元素角色，其下我们定义一个可以接受人访问的方法

```
public interface Animal {

    //接受访问者访问的功能
    void accept(Person person);
}

```

然后定义具体的宠物类实现动物类，重写其方法，直接调用人的喂食方法，将当前的宠物对象传入即可

```
public class Dog implements Animal{

    @Override
    public void accept(Person person) {
        person.feed(this);//访问者给宠物猫喂食
        System.out.println("好吃汪...");
    }
}
```

最后我们要创建结构对象角色，这里代表的主人家类，其下组合了一个宠物对象的集合，具有添加宠物和遍历宠物的功能，遍历宠物就直接调用宠物里的接受访问的方法即可，即是可以让外人或者是主人直接访问所有的宠物

```
//对象结构类
public class Home {

    //声明一个集合对象，用来存储元素对象
    private List<Animal> animals = new ArrayList<>();

    //添加元素功能
    public void add(Animal animal){
        animals.add(animal);
    }

    public void action(Person person){
        //遍历集合，获取每一个元素，让访问者访问每一个元素
        for (Animal animal : animals) {
            animal.accept(person);
        }
    }
}
```

然后我们可以写入我们的测试类代码如下，我们这里创建主人类，然后往其中添加宠物，接着分别创建主人对象和路人对象并调用主人家里的统一访问方法，最后可以得到主人和路人都分别给宠物进行了喂食的结果

```
public class Client {
    public static void main(String[] args) {
        //创建Home对象
        Home home = new Home();
        //添加元素到Home对象中
        home.add(new Dog());
        home.add(new Cat());

        //创建主人对象
        Owner owner = new Owner();
        //让主人喂食所有的宠物
        home.action(owner);

        //创建路人对象
        Someone someone = new Someone();
        home.action(someone);
    }
}
```

接着我们来看看其优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEf90f8990fa5269ac8028da7659e8e18a.png)

## 扩展内容-分派

实际上，我们的访问者模式是使用到了一种双分派的技术，我们这里就来扩展一下这个知识点

分派又两种，分别是静态分派和动态分派，我们来看看他们三者的描述

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE65fbc15a1cd0dc6acbcc523d971540b8.png)

静态分派可以简单理解为是方法重载，其是发生在编译时期，而动态分派是发生在运行时期，可以动态置换掉某个方法

我们先来讲讲动态分派的例子，请看下图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE36348a92fbdf15358fd086ea1bcb80f5.png)

所以简单来说，我们可以将都动态分派理解为多态，Java编译器在编译时期会对对象的类型进行判断，此处判断的类型是静态类型，但是对方法的调用是根据对象的真实类型，而不是静态类型，因此我们调用对应的方法时会执行其真实类型里的方法

接着我们再来说说静态分派，方法重载可以简单理解为是静态分派，我们来看看下图中的例子

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEcbaffc2d291872e13565b6385f21dfee.png)

这个结果似乎有些楚人意料，之所以会产生这个结果是因为重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。这样说可能有些云里雾里，简单来说就是只有我们调用对象中的方法的时候其才会调用其真实对象，而如果我们只是给其定义了一个类型然后直接传入给对应类调用方法，那么最终其会认为这三个类都是我们之前指定的类型然后进入到对应的方法中并执行，具体就体现在上面的三个结果都是animal

最后我们来谈谈什么是双分派，简单来说，双分派就是在选择一个方法的时候，不仅仅要根据消息接收者的运行时区别，还要根据参数时的运行区别

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE35571b1758a56f074db6a0c1f6a7ed91.png)

我们这里首先创建动物对象，而其下定义一个Execute对象的方法，该方法会调用Execute对象的excute方法，调用内部的方法需要传入一个具体的动物对象，其会根据对应的动物对象来执行对应的方法。

那么我们在测试类中先创建这个三个方法，然后创建一个Execute对象，接着我们分别调用三个对象的accept方法传入exe对象，此处我们调用子类的真实方法，就完成的动态分派，然后我们在对应的子类的方法中，会将自身对象传入给exe对象中，此处就是实现了静态分派，定义一个对象并传入，而exe类又会根据对应的类执行对应的方法，最终就能够得到我们想要的结果，那么在这个过程中我们就实现了双分派

双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了

简单来说，双分派的作用就是可以实现我们的动态重载，虽然比较麻烦就是

# 备忘录模式

现在我们来学习备忘录模式，先来看看其概述

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEcaf446adc190aea46faba694203646e0.png)

然后我们来看看其定义的结构

## 备忘录模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9ce6db5631d062d8b3caaa8a18e8a8a9.png)

同样的我们通过一个案例来加深理解，来看看案例需求

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEac57c7b14bdaba325800565b2a21849f.png)

实现这种案例有两种方式，分别是白箱和黑箱，我们先来实现白箱方式，所谓白箱方式指的是对备忘录角色的任何一个对象都提供宽接口，备忘录角色内部存储的状态对所有角色公开，来看看类图

## 白箱实现

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE8f48e39f413354e5fd5ffa3fd31e20a4.png)

首先我们创建备忘录角色类，该角色类可以保存我们的状态，我们的角色属性就生命、攻击、防御三种，所以我们这里只往内部设置这三个属性，然后提供对应的方法

```
//备忘录角色类
public class RoleStateMemento {

    private int vit; //生命
    private int atk; //攻击
    private int def; //防御

    public RoleStateMemento(int vit, int atk, int def) {
        this.vit = vit;
        this.atk = atk;
        this.def = def;
    }

    public RoleStateMemento() {
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }
}

```

然后创建发起人角色，其在我们案例中代表的是游戏角色类，我们给予其赋予生命、攻击、防御三个属性，提供对应的构造和setandget方法，然后我们体用初始化内部状态的方法，给对应的属性赋值，接着提供一个保存角色状态功能的方法，返回一个保存角色状态的对象，然后我们再提供一个恢复角色状态的方法，要求提供一个角色状态对象，然后内部会自动获得里面的值并赋予到原来的对象中

```
//游戏角色类（发起人角色）
public class GameRole {

    private int vit; //生命
    private int atk; //攻击
    private int def; //防御

    //初始化内部状态
    public void initState() {
        this.vit=100;
        this.atk=100;
        this.def=100;
    }

    //战斗
    public void fight() {
        this.vit=0;
        this.atk=0;
        this.def=0;
    }

    //保存角色状态功能
    public RoleStateMemento saveState() {
        return new RoleStateMemento(vit,atk,def);
    }

    //恢复角色状态
    public void recoverState(RoleStateMemento roleStateMemento){
        //将备忘录对象中存储的状态赋值给当前对象的成员
        this.vit= roleStateMemento.getVit();
        this.atk= roleStateMemento.getAtk();
        this.def= roleStateMemento.getDef();
    }

    //展示状态功能
    public void stateDisplay() {
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "GameRole{" +
                "vit=" + vit +
                ", atk=" + atk +
                ", def=" + def +
                '}';
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }
}

```

最后我们创建管理者角色，其下聚合了备忘录类，还提供了一些必要的方法

```
public class RoleStateCaretaker {

    //声明RoleStateMemento类型的变量
    private RoleStateMemento roleStateMemento;

    public RoleStateCaretaker(RoleStateMemento roleStateMemento) {
        this.roleStateMemento = roleStateMemento;
    }

    public void setRoleStateMemento(RoleStateMemento roleStateMemento) {
        this.roleStateMemento = roleStateMemento;
    }

    public RoleStateMemento getRoleStateMemento() {
        return roleStateMemento;
    }

    public RoleStateCaretaker() {
    }
}
```

接着我们可以写入我们的测试类代码如下，我们这里先创建游戏对象，然后创建游戏管理者对象，接着我们往管理者对象中设置一个游戏保存的状态对象，直接调用游戏角色内部的方法即可，接着调用游戏角色的恢复方法，传入一个管理者类中保存的游戏状态类即可完成恢复

```
public class Client {
    public static void main(String[] args) {
        System.out.println("h之前");
        //创建游戏角色对象
        GameRole gameRole = new GameRole();
        gameRole.initState();//初始化状态操作
        gameRole.stateDisplay();

        //将该游戏角色内部状态进行备份
        //创建管理者对象
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());

        System.out.println("h之后");
        //损耗严重
        gameRole.fight();
        gameRole.stateDisplay();
        System.out.println("恢复之前的状态");
        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());
        gameRole.stateDisplay();
    }
}
```

-  黑箱备忘录模式

那么接着我们来用黑箱备忘录模式来实现这个案例，其实现的方式就是提供一个备忘录接口，然后将备忘录类设计为发起人类的内部成员类

## 黑箱实现

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE21312edac4a6dafa836e918b13ffecc9.png)

首先我们创建备忘录接口，其用于对外提供窄接口

```
//备忘录接口，对外提供窄接口
public interface Memento {
}
```

然后我们创建管理者类，其拥有我们刚刚定义的接口属性，同时提供对应的getandset方法

```
public class RoleStateCaretaker {

    //声明Memento类型的变量
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```

然后我们定义游戏角色类，内部再定义一个保存状态的类，令其实现我们的接口，然后其下提供对应的方法即可

```
//游戏角色类（发起人角色）
public class GameRole {

    private int vit; //生命
    private int atk; //攻击
    private int def; //防御

    //初始化内部状态
    public void initState() {
        this.vit=100;
        this.atk=100;
        this.def=100;
    }

    //战斗
    public void fight() {
        this.vit=0;
        this.atk=0;
        this.def=0;
    }

    //保存角色状态功能
    public Memento saveState() {
        return new RoleStateMemento(vit,atk,def);
    }

    //恢复角色状态
    public void recoverState(Memento memento){
        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;
        //将备忘录对象中存储的状态赋值给当前对象的成员
        this.vit= roleStateMemento.getVit();
        this.atk= roleStateMemento.getAtk();
        this.def= roleStateMemento.getDef();
    }

    //展示状态功能
    public void stateDisplay() {
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "GameRole{" +
                "vit=" + vit +
                ", atk=" + atk +
                ", def=" + def +
                '}';
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    private class RoleStateMemento implements Memento{
        private int vit; //生命
        private int atk; //攻击
        private int def; //防御

        public RoleStateMemento() {
        }

        public RoleStateMemento(int vit, int atk, int def) {
            this.vit = vit;
            this.atk = atk;
            this.def = def;
        }

        public int getVit() {
            return vit;
        }

        public void setVit(int vit) {
            this.vit = vit;
        }

        public int getAtk() {
            return atk;
        }

        public void setAtk(int atk) {
            this.atk = atk;
        }

        public int getDef() {
            return def;
        }

        public void setDef(int def) {
            this.def = def;
        }
    }
}

```

最后我们写入我们的测试类的代码如下，最终也可以得到同样的效果

```
public class Client {
    public static void main(String[] args) {
        System.out.println("h之前");
        //创建游戏角色对象
        GameRole gameRole = new GameRole();
        gameRole.initState();//初始化状态操作
        gameRole.stateDisplay();

        //将该游戏角色内部状态进行备份
        //创建管理者对象
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setMemento(gameRole.saveState());

        System.out.println("h之后");
        //损耗严重
        gameRole.fight();
        gameRole.stateDisplay();
        System.out.println("恢复之前的状态");
        gameRole.recoverState(roleStateCaretaker.getMemento());
        gameRole.stateDisplay();
    }
}

```

而且我们这样定义，我们的管理者类就无法随意获取到我们的状态类并修改其内容了，如果其采用向下转型的话，那么会报类型转换异常

值得一提的是，我们将该状态类即使放到外面来，不定义成其内部的类，也是可行的，那为什么我们这里就要定义成内部类呢？这个问题值得我们思考

最后我们来看看其优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE65fb85aaa19d9395bcce2fc803764928.png)

# 解释器模式

现在我们来学习行为型模式里的最后一个模式，解释器模式，我们先来看看其概述

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE433b6c4e7c48f252dba1b7b960f6c5ea.png)

也就是说，我们的确可以通过几个简单的方法来实现加减法，但是这样实现的内容不但形式单一，而且不符合要求，那么我们就需要一种可以翻译的机器，可以解析我们传入的运算序列

我们可以将运算符和数字都看做结点，那么我们目标就是希望能够对逐个结点进行读取并解析运算，这就是解释器模式的思维

## 解释器模式介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE591a2b7ecbbff929df736d610fd3ac9a.png)

我们的解释器就是要解析出来的语句的含义，那么剩下的问题就在于我们要如何描述我们的语法规则

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEc5d3155b3f08951b2a476b542be9a7ca.png)

上面的图中，expression表达的是我们的表达式，表达式中的 | 指的是与操作，也就是说，我们的一个表达式可以由value，plus以及minus组成，这三个在下面都有定义

我们的plus操作应该由两个表达式以及一个+号连接组成，minus操作则是有-号连接，而value的值我们这里规定只能为Integer类型的值，上面的内容则定义了我们的语法结构的形式规则，其本身就作为一个文法

在计算机科学中具有抽象语法树结构，简称语法树，我们一般用这种结构来表达符合文法结构规则的句子

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEfd62f77d302606037ab12b899f9ae861.png)

接着我们来通过一个案例来加深我们对解释器模式的理解，首先我们来看看其案例的需求和类图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE284563da9f1abf8a1ced331ca8828af5.png)

## 案例实现

首先我们创建抽象表达式类，其是一个抽象类，定义了一个抽象方法，该方法需要传入一个环境类（当前未创建），然后返回一个int类型的结果

```
//抽象表达式类
public abstract class AbstractExpression {
    public abstract int interpret(Context context);
}
```

然后我们定义我们的环境角色类，其下拥有Map集合类，用来存储变量以及对应的值，我们还提供了添加变量的方法，需要提供保存变量的Variable类以及具体的值（保存变量的类还未定义），还有一个获取对应值的方法

```
//环境角色类
public class Context {

    //定义一个Map集合，用来存储变量及对应的值
    private Map<Variable,Integer> map = new HashMap<>();

    //添加变量的功能
    public void assign(Variable var,Integer value){
        map.put(var,value);
    }

    //根据变量获取对应的值
    public int getValue(Variable var){
        return map.get(var);
    }
}
```

接着我们定义封装变量的类，这里我们往其中定义一个封装变量的类，其当然要继承我们的抽象表达式类，其中提供一个String属性用于保存我们的变量名，重写的方法中我们直接返回变量的值即可，因此我们这里直接调用传入的环境类的getValue方法，传入当前的变量对象，即可从环境类中的map集合中获得我们所需要的值

最后我们还重写了toString方法，重写这个方法是为了让我们后期能够正确打印我们的文法语句

```
//封装变量的类
public class Variable extends AbstractExpression{

    //声明存储变量名的成员变量
    private String name;

    public Variable(String name) {
        this.name = name;
    }

    @Override
    public int interpret(Context context) {
        //直接返回变量的值
        return context.getValue(this);
    }

    @Override
    public String toString() {
        return name;
    }
}
```

接着我们定义我们的加法表达式类，其下应该聚合了两个表达式类的属性，分别保存+号左右两边的内容，我们重写父类的方法，让我们的方法调用我们的属性中的计算结果的方法并将环境对象继续传入，最后我们提供一个toString方法用于打印我们的语法表达式

```
//加法表达式类
public class Plus extends AbstractExpression{

    //+号左边的表达式
    private AbstractExpression left;
    //+号右边的表达式
    private AbstractExpression right;

    public Plus(AbstractExpression left,AbstractExpression right){
        this.left=left;
        this.right=right;
    }

    @Override
    public int interpret(Context context) {
        //将左边表达式的结果和右边表达式的结果进行相加
        return left.interpret(context)+right.interpret(context);
    }

    @Override
    public String toString() {
        return "("+left.toString()+"+"+right.toString()+")";
    }
}

```

同样对于减法表达式类也是一样的

```
//减法表达式类
public class Minus extends AbstractExpression{

    //-号左边的表达式
    private AbstractExpression left;
    //-号右边的表达式
    private AbstractExpression right;

    public Minus(AbstractExpression left, AbstractExpression right){
        this.left=left;
        this.right=right;
    }

    @Override
    public int interpret(Context context) {
        //将左边表达式的结果和右边表达式的结果进行相减
        return left.interpret(context)-right.interpret(context);
    }

    @Override
    public String toString() {
        return "("+left.toString()+"-"+right.toString()+")";
    }
}
```

最后我们再测试类中写入我们的代码如下，这里我们来解释下我们的这份代码的执行过程，因为还是有点复杂的，先解释下好，免得以后看不懂

首先我们创建对应的环境变量，然后我们创建多个变量对象，提供唯一标识，然后我们将对应的变量存储到我们的环境对象中，这里我们还设置了对应的值，分别是1234，接着我们来获取我们的抽象语法树，我们这里通过直接创建对应的类的方式来指定构建我们的语法树，而每个语法树中都应该要设置两个变量对象，每一个new的对象代表的是要两个变量要执行的运算，并且其都会返回一个新的保存变量对象，最终我们构造出了我们的语法树

然后我们调用语法树中的计算方法，我们的语法树最开始的真实对象是Minus对象，首先我们就调用Minus类中的interpret方法，然后我们需要调用两个保存的变量类中的interpret方法获得对应的值用于计算，如果最终我们往内部传入的值并不是一个变量类，而是一个计算类，那么其就会递归调用方法，继续进入到同样的方法中去执行计算过程，而由于我们总是能保证我们任何一个计算类最终总是保存了两个变量类的，因此最终我们虽然调用同样的方法，但是由于类的特殊性，我们总是能够让我们的方法正确停止，这也是为什么我们的保存变量的类也叫做终结符表达式，计算类又被称为非终结符表达式

```
public class Client {
    public static void main(String[] args) {
        //创建环境对象
        Context context = new Context();

        //创建多个变量对象
        Variable a = new Variable("a");
        Variable b = new Variable("b");
        Variable c = new Variable("c");
        Variable d = new Variable("d");

        //将变量存储到环境对象中
        context.assign(a,1);
        context.assign(b,2);
        context.assign(c,3);
        context.assign(d,4);

        //获取抽象语法树 a+b-c+d
        AbstractExpression expression = new Minus(a,new Plus(new Minus(b,c),d));

        //解释（计算）
        int interpret = expression.interpret(context);
        System.out.println(expression+"="+interpret);
    }
}

```

最后我们可以得到这个结果，左边是我们对应的语法树，右边是我们的结果

```
(a-((b-c)+d))=-2
```

最后我们来看看该模式的优缺点和使用场景

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEdbd16d66322d772a76fbd3c29f8ac899.png)

