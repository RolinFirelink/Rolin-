为了这一节，我甚至不得去重新学习JS、jQuery以及AJAX，想当初我是因为觉得他们用不上所以跳过的，现在又给补回来了，只能说欠下的债，总有一天是要还的

然后本章我们来学习SpringMVC的异步调用

- 接收异步请求参数

我们先来介绍下我们的案例环境，我们的springmvc配置文件的代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--扫描加载所有的控制类类-->
    <context:component-scan base-package="com.itheima"/>
    
    <mvc:resources mapping="/js/**" location="/js/"/>

    <mvc:annotation-driven/>
</beans>
```

可以看到我们这里只做了简单的扫包以及开启注解驱动，还有我们放开了js的静态资源，因为我们这里会用上对应的类库，因此我们要对其进行对应的放开，否则都无法调用对应的方法

然后我们创建了一个对应的User的实体类，然后我们在web包下创建一个ajax的jsp文件并写入其代码如下

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>

<a href="javascript:void(0);" id="testAjax">访问springmvc后台controller</a><br/>
<a href="javascript:void(0);" id="testAjaxPojo">访问springmvc后台controller，传递Json格式POJO</a><br/>
<a href="javascript:void(0);" id="testAjaxList">访问springmvc后台controller，传递Json格式List</a><br/>
<a href="javascript:void(0);" id="testAjaxReturnString">访问springmvc后台controller，返回字符串数据</a><br/>
<a href="javascript:void(0);" id="testAjaxReturnJson">访问springmvc后台controller，返回Json数据</a><br/>
<a href="javascript:void(0);" id="testAjaxReturnJsonList">访问springmvc后台controller，返回Json数组数据</a><br/>
<br/>
<a href="javascript:void(0);" id="testCross">跨域访问</a><br/>

<script type="text/javascript" src="${pageContext.request.contextPath}/js/jquery-3.3.1.min.js"></script>

<script type="text/javascript">
    $(function () {
        //为id="testAjax"的组件绑定点击事件
        $("#testAjax").click(function(){
            //发送异步调用
            $.ajax({
                //请求方式：POST请求
                type:"POST",
                //请求的地址
                url:"ajaxController",
                //请求参数（也就是请求内容）
                data:'ajax message',
                //响应正文类型
                dataType:"text",
                //请求正文的MIME类型
                contentType:"application/text",
            });
        });

        //为id="testAjaxPojo"的组件绑定点击事件
        $("#testAjaxPojo").click(function(){
            $.ajax({
                type:"POST",
                url:"ajaxPojoToController",
                data:'{"name":"Jock","age":39}',
                dataType:"text",
                contentType:"application/json",
            });
        });

        //为id="testAjaxList"的组件绑定点击事件
        $("#testAjaxList").click(function(){
            $.ajax({
                type:"POST",
                url:"ajaxListToController",
                data:'[{"name":"Jock","age":39},{"name":"Jockme","age":40}]',
                dataType:"text",
                contentType:"application/json",
            });
        });


        //为id="testAjaxReturnString"的组件绑定点击事件
        $("#testAjaxReturnString").click(function(){
            //发送异步调用
            $.ajax({
                type:"POST",
                url:"ajaxReturnString",
                //回调函数
                success:function(data){
                    //打印返回结果
                    alert(data);
                }
            });
        });

        //为id="testAjaxReturnJson"的组件绑定点击事件
        $("#testAjaxReturnJson").click(function(){
            //发送异步调用
            $.ajax({
                type:"POST",
                url:"ajaxReturnJson",
                //回调函数
                success:function(data){
                    alert(data);
                    alert(data['name']+" ,  "+data['age']);
                }
            });
        });

        //为id="testAjaxReturnJsonList"的组件绑定点击事件
        $("#testAjaxReturnJsonList").click(function(){
            //发送异步调用
            $.ajax({
                type:"POST",
                url:"ajaxReturnJsonList",
                //回调函数
                success:function(data){
                    alert(data);
                    alert(data.length);
                    alert(data[0]["name"]);
                    alert(data[1]["age"]);
                }
            });
        });

        //为id="testCross"的组件绑定点击事件
        $("#testCross").click(function(){
            //发送异步调用
            $.ajax({
                type:"POST",
                url:"http://www.jock.com/cross",
                //回调函数
                success:function(data){
                    alert("跨域调用信息反馈："+data['name']+" ,  "+data['age']);
                }
            });
        });
    });
</script>
```

我们上面的代码里所干的事情就是加了对应的方法，然后向客户端发送了对应的请求，有些还会传入一些参数到客户端上。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbef38d29ea5b4175809c034b431613e7.png)

最后我们创建一个Ajax的实现类来实现我们的异步调用，我们真正要完成的代码也是在这里完成

我们先来看看我们的第一个事件的向服务器请求的内容，可以看到第11行，我们这里使用了一个data来发送了一个字符串参数过去

```
$(function () {
    //为id="testAjax"的组件绑定点击事件
    $("#testAjax").click(function(){
        //发送异步调用
        $.ajax({
            //请求方式：POST请求
            type:"POST",
            //请求的地址
            url:"ajaxController",
            //请求参数（也就是请求内容）
            data:'ajax message',
            //响应正文类型
            dataType:"text",
            //请求正文的MIME类型
            contentType:"application/text",
        });
    });
```

如果这时我们想要在服务器上接受的到这个参数，那我们应该要怎么做呢？我们的一个简单的想法就是直接在我们的响应内容中加入一个形参来接受这个参数，但这样实际上是接受不了的。这是因为我们之前是是通过参数的方法直接发送去的，而我们如果使用AJAX的方式来发送请求，那么这里面一并发送的参数是整个请求正文，直接用形参是接受不了的，此时我们就要使用RequestBody注解，该注解可以将请求正文里的参数自动赋值到我们的形参中

```
@RequestMapping("/ajaxController")
//使用@RequestBody注解，可以将请求体内容封装到指定参数中
public String ajaxController(@RequestBody String message){
    System.out.println("ajax request is running..."+message);
    return "page.jsp";
}
```

后续的内容都是依葫芦画瓢，这里就不多提了

```
@RequestMapping("/ajaxPojoToController")
//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中
//注意：POJO中的属性如果请求数据中没有，属性值为null，POJO中没有的属性如果请求数据中有，不进行映射
public String  ajaxPojoToController(@RequestBody User user){
    System.out.println("controller pojo :"+user);
    return "page.jsp";
}

@RequestMapping("/ajaxListToController")
//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式的对象数组，数据将自动映射到集合参数中
public String  ajaxListToController(@RequestBody List<User> userList){
    System.out.println("controller list :"+userList);
    return "page.jsp";
}
```

值得一提的是，之前我们说过如果我们的集合里放着的是我们的自定义对象，我们是要用另外一个对象来做的，但是这里仍然是只用一个RequestBody注解就完了，属于是非常方便了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE745d9d372a4ee737c07a21df9949691b.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6011d9b7ba6abee22c1a2485d77bc7ce.png)

- 异步请求接受响应数据

接着我们来讲我们异步请求如何接受响应数据，简单来说，我们的页面要如何接收到我们的在服务器端返回的页面对象的数据

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE793d3c4948cb11ce70575193259efbd6.png)

具体我们来看看我们页面里的这十四行的代码，里面获得响应的数据并打印

```
//为id="testAjaxReturnString"的组件绑定点击事件
$("#testAjaxReturnString").click(function(){
    //发送异步调用
    $.ajax({
        type:"POST",
        url:"ajaxReturnString",
        //回调函数
        success:function(data){
            //打印返回结果
            alert(data);
        }
    });
});

```

首先，如果我们的页面完全不做改动，那么最终我们会返回一个page.jsp的代码，其返回这个是没问题的，因为一般我们都是用这个放到页面上，只是这里我们将其传给我们的页面了，因此打印的内容就是里面的编码。但是这并不是我们在这个案例中想要的，我们希望页面得到的不是这一个编码内容，而是这一个字符串，那么此时我们应该要怎么做呢？这时就需要用到ResponseBody注解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEad194411722eee90cea84e37c866a627.png)

在对应方法上用该注解可以告知我们的springMVC，将我们的返回值作为一个响应正文来处理，而不要对其进行相应的视图解析，能够达到我们写入什么就返回什么的效果。那么最后我们可以构造其代码如下

```
    //使用注解@ResponseBody可以将返回的页面不进行解析，直接返回字符串，该注解可以添加到方法上方或返回值前面
    @RequestMapping("/ajaxReturnString")
//    @ResponseBody
    public @ResponseBody String ajaxReturnString(){
        System.out.println("controller return string ...");
        return "page.jsp";
    }
```

最后值得一提的是，我们的该注解不但可以放在我们的方法上，也可以放到我们返回值前面，这就相当于是用该注解修改我们的返回值，令其不会解析。这个很好理解，不过为了防止我们的方法名过长的情况所以我们一般不这样做，还是正常写在方法之上

然后如果我们要返回一个Pojo对象时也是同样的方法，同时如果返回值为Pojo，那么其会自动封装数据成json对象数据

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa8bc9b6e154b3c64e584dea6e2a16e93.png)

那么我们可以写入代码如下

```
@RequestMapping("/ajaxReturnJson")
@ResponseBody
//基于jackon技术，使用@ResponseBody注解可以将返回的POJO对象转成json格式数据
public User ajaxReturnJson(){
    System.out.println("controller return json pojo...");
    User user = new User();
    user.setName("Jockme");
    user.setAge(39);
    return user;
}
```

值得一提的是，json数据回到页面时又会被自动封装成一个对象，所以如果我们想要打印对应的内容的话，应该要在页面的打印代码上做相应的改动，如下所示

```
//为id="testAjaxReturnJson"的组件绑定点击事件
$("#testAjaxReturnJson").click(function(){
    //发送异步调用
    $.ajax({
        type:"POST",
        url:"ajaxReturnJson",
        //回调函数
        success:function(data){
            alert(data);
            alert(data['name']+" ,  "+data['age']);
        }
    });
});
```

返回值为List的情况也是一样的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE54a66796171abb0d5491978af8147bb0.png)

我们可以构造其代码如下

```
@RequestMapping("/ajaxReturnJsonList")
@ResponseBody
//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据
public List ajaxReturnJsonList(){
    System.out.println("controller return json list...");
    User user1 = new User();
    user1.setName("Tom");
    user1.setAge(3);

    User user2 = new User();
    user2.setName("Jerry");
    user2.setAge(5);

    ArrayList al = new ArrayList();
    al.add(user1);
    al.add(user2);

    return al;
}
```

- 跨域访问

接着我们来学习异步调用的最后一个内容，跨域访问，这个知识是作为我们以后学习微服务的一个学习准备。我们先来介绍下什么是跨域访问

我们之前的访问都是一个服务器去访问他自己的东西的，这不涉及跨域访问，但如果我们要一个服务器连接另一个服务器的话，那么就涉及到跨域访问了，我们跨域访问的连接的一个最简单的方式是通过ip地址连接，但是这个方法太low了，我们一般是让我们的不同的服务器申请一个域名，可以通过域名解析到一个ip，然后通过域名来访问的。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfc84ce921ee955e0ce1832dd103a52b1.png)

所谓跨域访问，就是当通过域名A下的操作访问域名B下的资源时，成为跨域访问。那么怎么样才叫两个不同的域呢？这里分别有请求协议不同、ip地址不同、端口号不同，这三个只要有一个不同，那么其就是两个不同的域，最后，还有一点，域名不同也是不同的域，因为其解析之后会得到两个服务器的地址。

按照上面知道的信息，我们可以在我们的本机上打造出两个域来实现跨域访问，只要在我们的本机上搞两个域名不同的应用就行，即使他们的ip地址相同，但是由于其服务器不同，所以其还是跨域访问

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf8e39e8aefb3c2418a7073ef50fadc28.png)

那么接着我们就要来搭建我们的跨域环境，我们要在C盘中找到这么一个文件

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE23f5b6defa0f6de20091ee3a7c0af018.png)

然后我们将其内容修改为

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd20358b1a1c0773040879fb1b57c9f87.png)

然后直接写入其代码如下，其中127.0.0.1代表的是本机的ip地址，任何电脑都是一样的，而后面的域名则是我们自己给本机设置的域名

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb4a027dcd1dd200276fdd54c11fcb8bf.png)

修改这个文件需要管理员权限，这个不要忘了，然后我们修改之后要用cmd命令窗口进行更进一步的设置

首先打开cmd窗口，然后输入命令如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbd298785555361e12f6d0589d8d31b0c.png)

然后输入命令如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE76473bfa83674465432d11cf5a83fcdc.png)

然后我们开启对应的服务器，接着我们打开对应的网页，首先进入对应的页面，然后我们用我们的本机ip的地址也去访问我们的服务器下的内容，输入网址如下http://www.jock.com/ajax.jsp，然后我们进行测试，点击跨域访问会发现两个都可以正确打印我们的内容。一个是我们的jock的域名，一个是我们的localhost的域名

然后我们将我们的页面的代码稍作改动如下

```
$("#testCross").click(function(){
    //发送异步调用
    $.ajax({
        type:"POST",
        url:"http://www.jock.com/cross",
        //回调函数
        success:function(data){
            alert("跨域调用信息反馈："+data['name']+" ,  "+data['age']);
        }
    });
});
```

简单来说，就是将我们的原本的cross改为http://www.jock.com/cross，相当于是从直接访问cross变为要去访问另一个域名上的cross，此时我们再次开启我们服务器，我们会发现jock域名可以正常工作，但是localhost不行，我们能够在下方看到其对应的提示说不支持跨域访问，因为我们没有开启，此时我们要开启跨域访问就需要用到CrossOrigin注解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa17c1bd938984e7ae18fc067d9900fc0.png)

那么我们可以将我们的代码修改如下

```
@RequestMapping("/cross")
@ResponseBody
//使用@CrossOrigin开启跨域访问
//标注在处理器方法上方表示该方法支持跨域访问
//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问
@CrossOrigin
public User cross(HttpServletRequest request){
    System.out.println("controller cross..."+request.getRequestURL());
    User user = new User();
    user.setName("Jockme");
    user.setAge(39);
    return user;
}

```

我们只要加入该注解，我们就会发现其就支持跨域访问了。