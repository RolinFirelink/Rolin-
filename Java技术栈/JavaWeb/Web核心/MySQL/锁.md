本章节我们来学习锁的内容，关于这一章节的内容，我们可以结合我们以前在JAVASE里学习过的多线程同步的知识来学习。首先我们来进行锁的介绍

- 锁的介绍

首先我们要知道什么锁，锁是数据库为了保证数据的一致性而设计的一种规则，其类似于多线程的中的线程同步，可以保证数据的一致性和安全性。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE67628e94b52ef17bd26e714110b5db31.png)

锁按操作分类可以分类共享锁和排他锁，共享锁也叫读锁，而排他锁也叫写锁，前者可以多个锁共存和多个线程查询数据但不可修改数据，后者不可共存且只允许当前线程查询和修改数据。

按力度分类可以分为表级锁和行级锁，前者会锁定整个表，具有加锁快，开销小，力度大的特点，但是其容易发生锁冲突，而且并发度底，不过其不会出现死锁情况。而后者会锁定当前行，其具有开销大，加锁慢，力度小的缺点，但是其发生锁冲突的概率低，并发度还高，不过其最大的问题是会出现死锁的情况

我们还可以按使用方式进行分类，将锁分为悲观锁和乐观锁，前者是认定每次查询数据时都认为别人会修改，所以每次查询都会加锁，后者是认为每次查询时别人都不会修改，只会在更新时判断此期间别有没有去更新该数据

不同引擎所支持的锁也是不同的，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe09b71b01a65cfae990aadf81de95192.png)

- InnoDB共享锁

那么我们先来介绍共享锁，先来看看共享锁的语法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE36b8f3f9073687b782438e98c0fe9176.png)

在学习内容之前，我们要先做一些对应的数据准备，其代码如下

```
-- 创建db10数据库
        CREATE DATABASE db10;

        -- 使用db10数据库
        USE db10;

        -- 创建student表
        CREATE TABLE student(
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(10),
        age INT,
        score INT
        );

        -- 添加数据
        INSERT INTO student VALUES (NULL,'张三',23,99),(NULL,'李四',24,95),
        (NULL,'王五',25,98),(NULL,'赵六',26,97);
```

我们准备的数据是一个db10的数据库，并在其下创建了一个student表，其中id是主键列，其他属性则没有添加任何约束，然后我们添加了对应的数据。接着我们就可以来正式开始学习了，我们要创建两个窗口并写入其对应的代码，窗口1的代码如下

```
/*
   共享锁：数据可以被多个事务查询，但是不能修改
   创建锁的格式
      SELECT语句 LOCK IN SHARE MODE;
*/
-- 开启事务
        START TRANSACTION;

        -- 查询id为1数据，并加入共享锁
        SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;

        -- 查询分数为99的数据，并加入共享锁
        SELECT * FROM student WHERE score=99 LOCK IN SHARE MODE;

        -- 提交事务
        COMMIT;
```

窗口2的代码如下

```
-- 开启事务
        START TRANSACTION;

        -- 查询id为1数据,(普通查询没问题)
        SELECT * FROM student WHERE id=1;

        -- 查询id为1数据,也加入共享锁(共享锁和共享锁是兼容)
        SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;

        -- 修改id为1数据，姓名改成张三三(修改失败。会出现锁的情况。只有窗口1提交事务后才能修改成功)
        UPDATE student SET NAME='张三三' WHERE id=1;

        -- 修改id为2数据，姓名改成李四四(修改成功，InnoDB引擎默认加的是行锁)
        UPDATE student SET NAME='李四四' WHERE id=2;

        -- 修改id为3数据，姓名改成王五五(修改失败，InnoDB引擎如果不采用带索引的列加锁，加的就是表锁)
        UPDATE student SET NAME='王五五' WHERE id=3;


        -- 提交事务
        COMMIT;
```

我们先在第一个表里开启事务，然后我们查询id为1的数据并且加入共享锁，此时我们在窗口而中也可以查询id为1的数据，同时也可以将其加入共享锁，这是没有问题的，因为共享锁之间可以共存，但是如果我们要在窗口2中修改id为1的数据，那就不行了，一定要等到窗口1提交结束之后才可以，然后我们窗口2中修改之后再次点击提交就可以完成对数据的真正修改了

但如果我们是将id为1的数据加入到共享锁中，然后修改id为2的数据，此时却是可以的，这是因为在InnoDB引擎中，如果采用带索引的列加锁，那么默认加的是表所，id是主键列，其下有主键索引。如果我们是查询分数为99的数据并加入到共享锁的话，此时默认加的就是表锁了，因为在InnoDB引擎中，如果不采用带索引的列加锁，那么加的就是表锁

- InnoDB排他锁

同样的我们需要两个窗口，先来看看窗口1的代码

```
/*
   排他锁：加锁的数据，不能被其他事务加锁查询或修改
   排他锁创建格式
      SELECT语句 FOR UPDATE;
*/
-- 开启事务
        START TRANSACTION;

        -- 查询id为1数据，并加入排他锁
        SELECT * FROM student WHERE id=1 FOR UPDATE;

        -- 提交事务
        COMMIT;
```

再来看看窗口2的代码

```
-- 开启事务
        START TRANSACTION;

        -- 查询id为1数据(普通查询没问题)
        SELECT * FROM student WHERE id=1;

        -- 查询id为1数据,并加入共享锁(排他锁和共享锁是不兼容的)
        SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;

        -- 查询id为1数据，并加入排他锁(排他锁和排他锁是不兼容的)
        SELECT * FROM student WHERE id=1 FOR UPDATE;

        -- 修改id为1数据，将姓名改成张三(修改失败，会出现锁的情况。只有窗口1提交事务后才能修改成功)
        UPDATE student SET NAME='张三' WHERE id=1;

        -- 提交事务
        COMMIT;
```

将对应的数据加入到排他锁时，是无法将其加入到其他锁的，同时也不能修改数据，但是可以读

- MyISAM锁

接着我们来学习MyISAM引擎的读锁，先来看看语法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3fd78c1a9c85166e2fd69c0383f71916.png)

然后我们要做相应的数据准备，其代码如下

```
-- 创建product表
        CREATE TABLE product(
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(20),
        price INT
        )ENGINE = MYISAM;  -- 指定存储引擎为MyISAM

        -- 添加数据
        INSERT INTO product VALUES (NULL,'华为手机',4999),(NULL,'小米手机',2999),
        (NULL,'苹果',8999),(NULL,'中兴',1999);
```

注意，MyISAM引擎不能加行锁，只能加表锁。同样我们需要两个窗口，窗口1的代码

```
/*
   读锁：所有连接只能读取数据，不能修改
   加锁
      LOCK TABLE 表名 READ;

   解锁
      UNLOCK TABLES;
*/
-- 为product表添加读锁
        LOCK TABLE product READ;

        -- 查询id为1数据
        SELECT * FROM product WHERE id=1;

        -- 修改id为1数据，将金额修改4999
        UPDATE product SET price = 4999 WHERE id=1;

        -- 解锁
        UNLOCK TABLES;
```

窗口2的代码

```
-- 查询id为1数据
        SELECT * FROM product WHERE id=1;

        -- 修改id为1数据，将金额改成5999(修改失败，只有窗口1解锁后才能修改成功)
        UPDATE product SET price=5999 WHERE id=1;
```

读锁非常简单，对一个表加入读锁就完了，加入读锁之后，其他窗口和本窗口都只能做读取操作，不能坐任何的修改，其他窗口修改数据会进入无限等待，直到解锁

- MyISAM写锁

接着我们来学习写锁，同样我们先来学习写锁的语法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcc5fc9c6d019bf5f1537168a8279cbc8.png)

我们同样也需要两个窗口并写入对应的代码，窗口1的代码如下

```
/*
   写锁：其他连接不能查询和修改数据
   加锁
      LOCK TABLE 表名 WRITE;

   解锁
      UNLOCK TABLES;
*/
-- 为product表添加写锁
        LOCK TABLE product WRITE;

        -- 查询
        SELECT * FROM product;

        -- 修改
        UPDATE product SET price=1999 WHERE id=2;

        -- 解锁
        UNLOCK TABLES;
```

窗口而的代码如下

```
-- 查询(查询失败，只有窗口1解锁后才能查询成功)
        SELECT * FROM product;

        -- 修改(修改失败，只有窗口1解锁后才能修改成功)
        UPDATE product SET price=2999 WHERE id=2;
```

窗口1中添加写锁之后只有窗口1可以做到修改数据和查询数据，窗口2一旦这样做就要一直等待窗口1的解锁。最后我们这里指的修改数据并不是说单纯的修改数据，增删改都是修改数据，不是说只有改属于修改数据，只是我们这里方便因此这么说而已

- 悲观锁和乐观锁

接着我们来学习最后一个内容，悲观锁和乐观锁，先来看看乐观锁和悲观锁的介绍

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9b6dc82e2e8761c963eba0cc0034a98d.png)

我们之前学习的锁就是悲观锁，至于乐观锁则需要用户去手动实现，那么我们要如何实现乐观锁呢？大体有以下两种方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2d8cb925745afd200e3faa7c6238ebc3.png)

这两种方法的本质都是加标记的思想，其实这有点类似于我们JAVASE里学习的序列版本号其实，我们来演示下方式一创建乐观锁，请看代码

```
-- 创建city表
        CREATE TABLE city(
        id INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id
        NAME VARCHAR(20),                   -- 城市名称
        VERSION INT                         -- 版本号
        );

        -- 添加数据
        INSERT INTO city VALUES (NULL,'北京',1),(NULL,'上海',1),(NULL,'广州',1),(NULL,'深圳',1);


        -- 将北京修改为北京市
        -- 1.将北京的版本号读取出来
        SELECT VERSION FROM city WHERE NAME='北京';   -- 1
        -- 2.修改北京为北京市，版本号+1.并对比版本号是否相同
        UPDATE city SET NAME='北京市',VERSION=VERSION+1 WHERE NAME='北京' AND VERSION=1;
```

这里我们创建了一个city表，然后添加了对应的数据，我们先读出其版本号，然后将该版本号进行对比，我们这里最后一行对比是手动获得了一，如果希望是动态的，那么可以将1置换为14行的代码。乐观锁的实现方式有许多种，但是大体都是加标记的思想

最后值得一提的是，乐观锁比较少用，我们只做了解就可以了，这是因为现实生活里本来乐观锁的应用就少，而且乐观锁的实现也更加繁琐，因此我们只做一些简单的了解就可以了