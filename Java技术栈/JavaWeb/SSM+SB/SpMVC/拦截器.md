那么接着我们来学习SpringMVC中的拦截器，这里我们要注意的是，我们的拦截器这一章，是非常重要的，所以我们要认真学，务必要学会搞懂。

- 拦截器简介

来解析下我们的处理过程，我们的客户端浏览器向服务器发送请求，该请求首先被tomcat获取到并进行处理，其中所有的静态资源tomcat都会获得并帮我们处理好。然后是动态资源，这些动态资源要经过一层层的过滤器，最终到达spring中，然后进入spring中的springmvc里进行处理，当然其处理是经过Handler对象进行处理的，此时出现的一个问题就在于，使用Handler对象进行处理，可能会需要相应的权限，如果我们在每一个Handler对象里都做赋予权限这种事情，这未免效率就有些太低了，于是我们就在其进入该对象之前，设定了一个拦截器，该拦截器可以赋予一些内容对应的权限，也可以将一些不具有权限的内容或者方法拦截下来，最后当其处理完之后，有些权限是一次性的，用过了就要归还，此时就需要用到后面的第二个拦截器，用于归还对应的权限

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1084b32c94c11ad7fd45cb8543aa9d8e.png)

其实这个过程简单来说就好像去过安保上班，进三道门过对应的验证来传对应的衣服，出去的时候又将对应的衣服归还，大概是这个流程。

我们要知道，拦截器是一种动态拦截方法调用的机制，其核心原理是AOP思想，不过其与AOP不同，就是其更加专一，AOP几乎无所不包，而拦截器是负责一部分功能，就是专门做请求和响应的功能。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8605af1ace883bf1b4750306b5c91c73.png)

拦截器链指的则是多个拦截器按照一定的顺序，对原始被调用功能进行增强的功能。同时我们现在这样听来，似乎拦截器的作用和过滤器相差无几，那么它们两者之间又有什么区别呢？

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa459665ebb6af83ab823730ec2183b72.png)

其具体区别在于两点，分别是归属不同以及拦截内容不同，过滤器属于Servlet技术，而拦截器则属于SpringMVC技术，同时过滤器可以对所有访问进行增强，而拦截器只能只针对所有对SpringMVC的访问进行增强

最后我们要提一点是，拦截器的最大作用，就是对对应的对SpringMVC的访问进行增强。

- 自定义拦截器开发过程

然后我们来自定义我们的拦截器开发，其实这个过程跟我们的之前的开发我们的AOP的时候差不多，不过也是有所不同的，所以我们这里再演示一遍

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE48be3e4e5a3da14ba90396642c5ecc4a.png)

这里我们值得一提的是，我们的springMVC中是有预先配置好的拦截器的，我们可以直接使用，我们自定义的时候是意味着其原来的拦截器功能已经不适用于我们的项目的时候，我们要做的事

我们先来介绍我们的案例环境吧，首先我们的pom文件还是跟以前一样，然后我们的xml文件就做了扫描控制类和加载注解驱动，然后我们在控制类里写入了如下的代码

```
@Controller
public class InterceptorController {
    @RequestMapping("handlerRun")
    public String handlerRun() {
        System.out.println("业务处理器运行-------------main");
        return "page.jsp";
    }
}

```

接着我们要自定义拦截器类，那我们就需要实现我们的HandlerInterceptor接口

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE47af4da8981704b2fde7b36e5736edaa.png)

该接口的三个抽象方法是有其默认实现的，该方法也是拦截器的核心方法，那么我们可以重写这三个并写入其代码如下

```
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("前置运行----a1");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("后置运行----b1");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("成功运行----c1");
    }
}

```

这里我们可以看到我们实现的方法有三个，分别是preHandle、postHandler、afterCompletion，其中第一个方法是用于拦截对应的方法的，如果我们返回的是false，则后两个方法不会执行，反之则会。第二个方法是在我们的功能执行完毕之后才允许的拦截方法，而最后一个方法是只要我们的类方法执行就一定会在最后执行的一个方法

我们写好了对应的方法之后，还要给拦截器加入对应的配置，否则拦截器就不会工作

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE81cf6f3b15dbd56dce5b773e8885859b.png)

我们这里写入的path是我们要拦截的具体方法，然后往其中加入一个bean的class类，该类是我们自定义的拦截器类。当然实际我们也可以另外创建一个bean，然后在此处引入对应的bean的id，我们这里贪方便就直接创建了

```
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/handlerRun"/>
        <bean class="com.itheima.interceptor.MyInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```

我们开启我们的服务器，然后刷新对应的页面就相当于是请求了服务器，此时就会在控制台上正确打印我们写在拦截器上的语句以及我们的方法本身的语句，此时就说明我们的案例已经成功了

最后我们来看看有拦截器和无拦截器时我们的方法的执行流程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE464b5b20266d8432831f273b5f9377ce.png)

- 拦截器配置与方法参数

接着我们来讲下我们的拦截器的具体配置和里面的形参，首先是我们的前置处理方法preHandle。里面有最基本的请求和响应对象，有了这两个对象我们就可以再原始方法运行之前进行一些对请求和响应对象的增强，而后面的handler对象则是一个封装了原始的方法的对象，被封装的方法是Method对象，我们可以直接把它当做Method对象来使，都差不多好用，该对象可以用于对方法本身做一些增强

而返回的值是true还是false则是决定了后面的方法要不要执行，同时也决定了原始方法要不要执行。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc86e337230c7c04661ee6e4ca904c737.png)

然后我们来讲讲我们的后置处理方法postHandler，该方法执行的前提是原始方法没有被拦截，其下还多了一个ModelAndView对象，这个是视图对象，这个视图对象内部就是封装了我们的服务器响应给我们的视图。即使服务器给我们的响应的是一个字符串，其仍然会被封装为一个视图对象并发送到客户端，只不过就是字符串封装的数据中，然后视图本身就是空的，因为服务器没给一个具体响应页面过来，所以为空。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE92362aafb760f20dbe8c2c42ea54fb99.png)

最后我们来看看我们的完成处理方法，该方法是拦截器最后执行的方法，这个方法存在的意义就是如果处理器执行过程中出现异常对象，那么我们就可以针对异常请看进行单独处理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa332483887ea49a239a14e6d9941edc2.png)

然后我来看看我们的拦截器的配置项

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE51ddb25c6397647ee81d8b5935a32885.png)

这里我们要记住的是，我们的path标签可以设置多个，同时其下还有多种设置格式可以用于设置我们要拦截的内容，最常用的是/*表示拦截所有，而/get*则表示拦截所有以get开头的方法，其他格式的当然还有，但是我们一般只使用这两个

同时其下还有一个exclude和include的属性，该属性其实也很简单，就是用于排除某些方法或者是包括某些方法的设置

那么最后我们可以构造其代码如下

```
<!--开启拦截器使用-->
<mvc:interceptors>
    <!--开启具体的拦截器的使用，可以配置多个-->
    <mvc:interceptor>
        <!--设置拦截器的拦截路径，支持*通配-->
        <!--/**         表示拦截所有映射-->
        <!--/*          表示拦截所有/开头的映射-->
        <!--/user/*     表示拦截所有/user/开头的映射-->
        <!--/user/add*  表示拦截所有/user/开头，且具体映射名称以add开头的映射-->
        <!--/user/*All  表示拦截所有/user/开头，且具体映射名称以All结尾的映射-->
        <mvc:mapping path="/*"/>
        <mvc:mapping path="/**"/>
        <mvc:mapping path="/handleRun*"/>
        <!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的-->
        <mvc:exclude-mapping path="/b*"/>
        <!--指定具体的拦截器类-->
        <bean class="MyInterceptor"/>
    </mvc:interceptor>
    <!--配置多个拦截器，配置顺序即为最终运行顺序-->
    <mvc:interceptor>
        <mvc:mapping path="/*"/>
        <bean class="MyInterceptor2"/>
    </mvc:interceptor>
    <mvc:interceptor>
        <mvc:mapping path="/*"/>
        <bean class="MyInterceptor3"/>
    </mvc:interceptor>
</mvc:interceptors>
```

- 多拦截器配置

接着我们来学习本章的最后一个内容，也就是多拦截器的配置。对于这一节，我们最好就想象我们进工厂过检查，每过一道增加一道防护的过程，这样易于我们对本章内容的理解。

首先，我们的拦截器链的运行顺序是参照配置的先后顺序，谁先配置谁先运行，同时后面的方法则是谁后运行谁就先执行对应的方法，这就相当于我们的最后过一道检查传防护眼镜，最后我们出去也是先返还防护眼镜的过程一样

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2eb1fda2b70d6c27a19537504e5722b3.png)

最后值得一提的是，我们的拦截器链里，一旦有任何一个进行了拦截，那么原始方法都不会执行，同时如果我们的拦截器链中中间的拦截链拦截了，那么其后的拦截链（包括他自己）不会执行，而前面的拦截工序里最后的执行完成的方法仍然会执行，这也跟过检查门一样，他都不要你穿衣服了，你也不用还，后面的装备没拿到，所以你也没必要还，准确来说都进不去，出去的时候就要返回鞋子给第一个检查门，非常好理解

最后我们这样的行为模式其实是一种责任链模式，其是一种行为模式，对于这种行为模式的具体介绍请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd14dcd45968994430caad175e06ac69c.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2229314e686400d745fbcf9be8e3512f.png)

