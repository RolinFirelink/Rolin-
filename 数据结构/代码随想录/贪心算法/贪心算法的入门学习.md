现在我们来学习贪心算法了，我们离结束只剩下两章了，加油加油，冲冲冲

- 贪心算法的理论基础

首先我们要知道贪心的本质是选择每一阶段的局部最优，从而达到全局最优。这里要注意的是，贪心算法本质上是一个推测的算法，他不能百分百保证正确性，但是对于很多题目来说，我们通过局部最优的形式是可以推导出我们想要的全局最优的结果的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4299a2b19eca82654bfc13de63ddf140.png)

贪心算法并没有固定的套路、策略或者方法。那么我们什么时候使用贪心算法好呢？答案是，靠感觉。当自己没什么思路的时候，可以尝试尝试贪心算法

然后我们来看看贪心算法的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe42043b502d741159b520aa4345dbafd.png)

最后提一下贪心没有套路，说白了就是常识性推导加上举反例。

我们解题的一般目标就是找到我们的局部最优，然后从局部最优出发，构建从局部最优推导出全局最优的逻辑代码。

- 分发饼干

我们先来做一题小试牛刀，来看看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6742fb045a7d534b7ea38e195e7ecbcb.png)

本题可以使用暴力解法，但是暴力法不是我们所追求的，我们必须要使用贪心算法，我们容易想到的局部最优是，让每个孩子都尽可能地吃到和他的胃口最接近的饼干，那么根据这个思路，我们可以写入我们的代码如下

```
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int ans = 0,index = 0;
        for (int i = 0; i < g.length; i++) {
            while (index<s.length && s[index]<g[i]){
                index++;
            }
            if(ans==s.length){
                break;
            }
            if(index<s.length){
                ans++;
            }
            if(index==s.length){
                break;
            }
            index++;
        }
        return ans;
    }
}
```

我们这个代码的思路是，我们的i指针指向孩子，index指针指向饼干，当我们的饼干小于孩子的胃口时，我们就让饼干指针往前进，直到满足，满足我们就让指针和饼干都前进一位，如果我们的饼干指针或者是孩子指针有任何一个到达了数组终止位置，此时我们都可以结束遍历，直接返回结果，因为此时我们的继续遍历也不会对结果有任何改变

我们上面的代码运行起来是没有问题的，但是这个代码写的太丑了，实际上，我们可以将我们的代码改造如下

```
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int ans = 0;
        for (int i = 0,index = 0; i < g.length && index < s.length;index++) {
            if(g[i]<=s[index]){
                ans++;
                i++;
            }
        }
        return ans;
    }
}
```

我们这里固定递增的指针指向饼干，而特定情况递增的指针则指向孩子，只有当我们的孩子胃口正好小于等于饼干时，我们就让两个指针前进，如果大于，我们则让饼干不断指针前进，寻找更大的饼干，同时，这两个指针无论哪一个到达了尽头都直接结束循环返回答案

- 摆动序列

接着我们来做一道难一点的题目，要不然大伙们都会觉得贪心这玩意随便做了都

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9217f7b83b867d423db0fc68c4ac55d1.png)

本题我们要利用贪心，问题就在于，我们这里要怎么贪？这一下子似乎没什么思路，其实我们可以将这个数组化作一个函数图像来看待，这样我们要就的摆动序列其实就可以理解为是一个上下不断波动的图像，那么我们要做的事就是去掉中间的点，这样让我们最终形成的函数图像总是一个波动形的，而且由于我们这里只是返回数量即可，所以我们甚至连去掉这个动作都不用做，直接统计对应的点即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE926520dd90e465092509de9c6c42d083.png)

所以本题的局部最优和整体最优分别如下

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。

整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。

那么我们的整体逻辑是让峰值尽可能的保持峰值，然后删除单一坡度上的节点

那么根据我们上面所说的逻辑，我们容易构造出我们的代码如下

```
class Solution {
    public int wiggleMaxLength(int[] nums) {
        boolean test = true;
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i]!=nums[i+1]){
                test=false;
                break;
            }
        }
        if(test){
            return 1;
        }
        int ans = 0,val = 0;
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i+1]==nums[i]){
                if(i==0){
                    ans++;
                }
                continue;
            }
            int num = nums[i+1]-nums[i];
            if(i==0){
                val = num;
                ans++;
                continue;
            }
            if(num>0 && val<0 || num<0 && val>0){
                ans++;
            }
            val = num;
        }
        return ans+1;
    }
}
```

我们这个代码的基本逻辑是首先判断我们的代码是不是完全一样的，如果是，我们就返回1，确定不是完全一样的之后，我们就进入我们的整体判断，我们这里首先判断当前的数和下一个数是否相等，如果相等我们则跳过，同时由于我们的第一个数也是计入坡度的，因此我们判断当前跳过的数是否是第一个数，如果是，那么我们最后计数时就要加上这个数量，同时由于我们的最后一个数也是要计入数量的，因此我们返回结果时需要将结果+1，代表我们还返回了最后那一位

这里值得一提的是我们会发现我们这里对第一个数要不要增加的判断里还限定的i==0，这是因为只有我们的第一个数是一样的时候，后面的第一位的代码统计代码将无法被调用，此时我们需要手动加上，但是如果其不是第一位的数，那么第一位的数量是被统计上的，此时我们就不需要额外加上该数，因此我们这里进行了一个i==0的特殊判断

然后我们定义两个数，一个数量保存当前数量的差，这个可以理解为我们的函数的坡度，另外一个变量则保存上一位坡度，然后我们每次判断坡度是否是相反的，是的话我们就让结果数量+1

上面的逻辑是没有问题的，但是问题在于，实际上上面的代码实际也是可行的，效率也还不错。但是上面的代码的问题在于太几把麻烦了，我们需要简化这份代码，那么我们应该怎么做呢？我们注意到，我们上面的代码麻烦的地方主要在于我们要处理重复的数字以及开头和结尾的数字的特殊处理，但实际上，我们可以这么做

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa3983a7d6e75750c5cfc733a201fd468.png)

我们假设出两个坡度，一个坡度记录当前和下一个坡度，另外一个记录上一个坡度，初始时上一个坡度为的值为0，此时代表第一个值有上一个值，而且其上一个值与当前值完全一样，此时我们仍然令其通过我们的判断，令结果+1，通过这种方法，我们相当于是构造了一个值出来，这样我们就便于统计我们的坡度，相当于是将特殊的情况通过构造一个新的条件来令其普通化

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE29e6575b1c28d098da40a0ecc1a72e6a.png)

那么我们可以构造我们的代码如下

```
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int prev = 0,ans = 1;
        for (int i = 0; i < nums.length-1; i++) {
            int now = nums[i]-nums[i+1];
            if(now>0 && prev<=0 || now<0 && prev>=0){
                ans++;
                prev=now;
            }
        }
        return ans;
    }
}
```

我们这里的逻辑是每次我们的统计当前的坡度，和上一个坡度进行比较，由于第一位的上一个坡度总是为0，因此第一位总是能进去到我们的判断条件中，这就相当于是加上了我们第一位的数的数量，同时由于我们的统计的坡度中结果中，如果当前坡度结果为0必然进不去，因此我们这上一位的坡度在第一位的记录之后必然不为0，因此我们当我们遇上两个相等的数时，其必然进不去，因此我们可以跳过相同的数。同时，即使第一个相同后面的不相同也没关系，因为后面只要相同就无法进入判断，因此不会产生重复计数的问题，自然也不需要多加一个判断

这份代码说是非常棒了，最后值得一提的是，这个题目还可以用动态规划的算法来做，但是我们目前还没有学习动态规划，所以就先放着吧，等以后学到了我们再来用动态规划做这一道题

- 最大子数组和

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE96a55b16d8e9636506b10e173b014724.png)

本题的暴力解法非常简单，但是会超时，直接寄，我们当然要使用贪心算法来做，但问题在于，这一题我们要怎么贪呢？我们容易观察到上面的例子，当-2和1在一起，我们要计算起点的时候，我们肯定是从1开始计算的，因为负数只会拉低我们的总和，因此我们会忽略-2，而这就是本题贪心所贪的地方，我们每次不断累加都将前面的数的和当做一个整体，当这个整体小于0时，我们就立即放弃该整体，从下一个位置为起点继续计算

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd07a86ea3c361107978506a192a34ba1.png)

这种逻辑的具体运算流程可以看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbe9c37d9ee190e59fad00a283af08944.gif)

那么最终我们容易写出我们的代码如下，注意这里我们的初始答案是最低的值，因为我们的数组是必然有值的，不为空的，而其下的子序列的和是可能为负数的，如果我们将其值定为0的话，那么对于全部数为负数的数组而言，其最终会得到一个0的结果，这肯定是不合理的，所以我们这里需要将我们最初的数量设置为int的最小值，这样就可以保证其总是可以得到数组内子序列的值

```
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = Integer.MIN_VALUE,now = 0;
        for (int i = 0; i < nums.length; i++) {
            now+=nums[i];
            ans = Math.max(ans,now);
            if(now<0){
                now = 0;
            }
        }
        return ans;
    }
}
```

最后我们提一下这题的贪心本质，其本质在于不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数

最后提一嘴，这题还能用动态规划和分治法来做，但是我都不会，咱们以后学到那个程度再来用别的方法做这题吧