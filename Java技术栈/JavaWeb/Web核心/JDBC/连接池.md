之前我们学习的都是JDBC的基础内容，而到了这一章节，我们来正式学习JDBC的高级内容，本章节我们来学习，连接池

- 数据库连接池的概念

首先我们来介绍下什么是数据库连接池，为什么又这个概念。首先数据库连接池简单来说就相当于是线程池，用户向数据库访问时需要从池中获取钥匙，然后访问数据库，访问完毕之后重新将钥匙放回池中。如果没有数据库连接池这个概念，那么用户每次向数据库的访问，java程序都需要新开辟一个空间用于访问，然后再释放这个空间，这样效率太慢了，对数据库的链接的管理是能显著影响到整个应用程序的性能指标的，因此我们提出了数据库连接池的概念，用于提高我们的效率。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE66394384f05fa165f26fb5bc2ab9ea3e.png)

数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接而不是重建建立一个，这样能明显提高数据库操作的性能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE77a7cbd7da4df0ba210f1134e6a20f83.png)

比方说，我们在一开始就往连接池中创建六个钥匙，用户需要访问时就从池中取出一个钥匙出来用于访问，有更多的用户访问就继续取，取完了还要就让他等，等到别人放回去为止或者直接抛出异常，这样能有效提高我们的效率

- 自定义数据库连接池

那么学习了数据库连接池之后，我们接着就来学习如何自定义一个数据库连接池，在学习这个内容之前，我们要先来学习DataSource接口

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0e62c6bf11198121e53c85b906aa8b17.png)

DataSource接口是java官方提供的数据库连接池规范，简单来说就是如果我们要自定义一个数据库连接池，那么我们就必须要令其实现DataSource接口，而这个接口的核心功能是getConnection()，该方法可以返回一个Connection对象。而我们连接池中自然要有保存连接的容器，这个容器我们可以用一个集合来保存。那么我们来看看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE69e48707c4e3fea17a8276692ed70b1c.png)

- 自定义数据库连接池

接着我们就来自定义我们的数据库连接池，我们这里先创建一个模块来定义进行我们本章的学习，所以不要忘了要将之前写好的工具类还有配置文件和相关的jar包先导入进来。然后我们自己创建一个类，令其实现DataSource接口，虽然其下的方法很多，但是我们只需要重写Connection方法就可以了，请看代码

```
/*
    自定义数据库连接池
 */
public class MyDataSource implements DataSource {
    //1.准备容器,用于保存多个连接对象,由于需要线程安全的集合对象，因此采用Collections的内置方法获取所需的集合对象
    private static List<Connection> pool = Collections.synchronizedList(new ArrayList<>());

    //2.定义静态代码块,通过工具类获取10个连接对象并放置于实现构造的集合容器中
    static {
        for (int i = 1; i <= 10; i++) {
            Connection con = JDBCUtils.getConnection();
            pool.add(con);
        }
    }

    //3.重写getConnection(),用于获取一个连接对象,每次我们都获取第一个对象
    @Override
    public Connection getConnection() throws SQLException {
        if(pool.size()>0){
            Connection con = pool.remove(0);
            return con;
        }else {
            throw new RuntimeException("连接数量已用尽");
        }
    }

    //4.定义getSize(),获取连接池容器的大小
    public int getSize() {
        return pool.size();
    }
```

下面还有很多的代码，都是重写的方法，这里我们为了版面就不放出来了。我们这里定义了我们的容器，然后我们提供了静态代码块，代码块内会令我们定义的容器获得十个连接对象，然后重写了getConnection方法，该方法可以用于获取连接对象，最后是获得连接池还有几个连接的方法

- 自定义数据库连接池的测试

那么为了测试我们自定义的数据库连接池是真的有用，我们可以创建一个类并写入其测试代码入如下

```
package com.itheima01;

import com.itheima.utils.JDBCUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class MyDataSourceTest {
    public static void main(String[] args) throws Exception{
        //1.创建连接池对象
        MyDataSource dataSource = new MyDataSource();
        //先打印使用之前的连接池的连接数量
        System.out.println("使用之前的数量：" + dataSource.getSize());

        //2.通过连接池对象获取连接对象，并打印该连接对象的字节码文件
        Connection con = dataSource.getConnection();
        System.out.println(con.getClass());

        //3.查询学生表的全部信息，使用预编译执行对象
        String sql = "SELECT * FROM student";
        PreparedStatement pst = con.prepareStatement(sql);

        //4.执行sql语句，接收结果集
        ResultSet rs = pst.executeQuery();

        //5.处理结果集
        while (rs.next()){
            System.out.println(rs.getInt("sid") + "\t" + rs.getString("name") + "\t" + rs.getInt("age") + "\t" + rs.getDate("birthday"));
        }

        //6.释放资源
        rs.close();
        pst.close();
        con.close();

        System.out.println("使用之后的数量：" + dataSource.getSize());
    }
}
```

解释都已经写在里面了，这里就不多赘述了，实际上我们能够轻易知道我们这份代码所构造的连接池是切实可行的，真实有效的。

- 归还连接之继承方式

但是我们上面的代码有一个问题我们没有解决，就是我们的上面实现的连接池并没有实现归还连接的功能，我们在测试代码里可以看到我们的连接就是用一份少一份的，而且最后也是直接关闭的，因此接下来我们要实现归还连接的功能、

归还连接有四种方式，分别是继承方式、装饰设计模式、适配器设计模式以及动态代理方式。我们这里先来学习继承方式归还数据库连接

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEde9a24e57a2c7a939bdac3dba5b52448.png)

继承方式归还数据库的原理很简单，我们打印连接对象，会发现这个连接实现类是JDBC4Connection，那么我们就可以自定义一个类，令其继承上面的类，然后重写其close()方法实现连接对象的归还，而其他方法不做改动

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE96acdf53ca51f1584d32f59435499f4a.png)

那么我们可以创建这么一个类并写入代码如下

```
package com.itheima02;

import com.mysql.jdbc.JDBC4Connection;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;

/*
    自定义的连接对象
    1.定义一个类，继承JDBC4Connection
    2.定义Connection连接对象和容器对象的成员变量
    3.通过有参构造方法为成员变量赋值
    4.重写close方法，完成归还连接
 */
//1.定义一个类，继承JDBC4Connection
public class MyConnection extends JDBC4Connection {
    //2.定义Connection连接对象和容器对象的成员变量
    private Connection con;
    private List<Connection> pool;

    //3.通过有参构造方法为成员变量赋值
    public MyConnection(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List<Connection> pool) throws SQLException {
        super(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);
        this.con = con;
        this.pool = pool;
    }

    //4.重写close方法，完成归还连接
    @Override
    public void close() throws SQLException{
        pool.add(con);
    }
}
```

对于这其中的MyConnection的构造方法，我们加入了con和pool两个对象进去，这个方法的原理我个人的理解是外面的构造方法我们可以随便定义，然而内部的super构造方法是用于构造父类的代码，而父类的构造方法需要传入对应的四个对象，这四个对象是必不可少的，而我们自己定义的对象则可以由我们自己决定赋予给谁或者是不赋予给谁，我们继承的时候其要求我们去实现这个方法，那么在JDBC4Connection中必然是有这个抽象方法的，这就导致我们的继承的时候一定要去实现这个方法

然后我们在下面重写我们的close方法，完成归还连接，这样我们的继承类就实现完毕了。但是虽然说这个代码实现完毕了，但是这份代码是无法使用的。这是为什么呢？这是因为我们获取的connection连接对象是通过工具类获得的，其内部代码是

```
//4.提供获取数据库连接方法
public static Connection getConnection(){
    try {
        con = DriverManager.getConnection(url,username,password);
    } catch (SQLException throwables) {
        throwables.printStackTrace();
    }
    return con;
}
```

而这里获得的连接对象实际上还是我们的JDBC4Connection连接对象，并不是我们自己定义的类，而我们也无法进行强转，因为在java中只有父类引用指向子类对象，没有子类引用指向父类对象的，所以我们的这份代码只能够用来图一乐

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa743c63ef9fb8fbe295d7179b5ecb928.png)

- 归还连接-装饰设计模式

归还连接的设计模式的思路是我们自定义一个类，令其实现Connection接口，这样其就具备了和JDBC4Connection相同的功能，然后我们重写其close方法，完成连接的归还，其他的方法就原封不动地调用JDBC4Connection内的方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3394cb4332c68df9695f9b360f90a7ef.png)

那么我们新创建一个Connection2类令其实现对应的接口并写入其代码如下

```
package com.itheima02;

import java.sql.*;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

/*
    1.定义一个类，实现Connection接口
    2.定义连接对象和连接池容器对象的成员变量
    3.通过有参构造方法为成员变量赋值
    4.重写close方法，完成连接的归还
    5.剩余方法还是调用原有的连接对象中的功能即可
 */
//1.定义一个类，实现Connection接口
public class MyConnection2 implements Connection {

    //2.定义连接对象和连接池容器对象的成员变量
    private Connection con;
    private List<Connection> pool;

    //3.通过有参构造方法为成员变量赋值
    public MyConnection2(Connection con,List<Connection> pool) {
        this.con=con;
        this.pool=pool;
    }

    //4.重写close方法，完成归还连接
    @Override
    public void close() throws SQLException {
        pool.add(con);
    }

    //5.剩余方法还是调用原有的连接对象中的功能即可
    @Override
    public Statement createStatement() throws SQLException {
        return con.createStatement();
    }
```

后面还有很多重写的方法，都是直接调用原来的方法就可以了，这里为了版面就不放上来了。然后我们将我们的从连接池中获取连接的代码修改如下

```
//3.重写getConnection(),用于获取一个连接对象,每次我们都获取第一个对象
@Override
public Connection getConnection() throws SQLException {
    if(pool.size()>0){
        Connection con = pool.remove(0);
        //通过自定义的连接对象 对原有的连接对象进行包装
        MyConnection2 myCon = new MyConnection2(con,pool);
        return myCon;
    }else {
        throw new RuntimeException("连接数量已用尽");
    }
}
```

可以看到我们这里其实返回的是一个Connection的子类连接，该子类连接内含有连接池和连接，如果执行close就会将连接放回连接池中，执行其他方法就直接执行connection的方法。这个方法是可行的，其本质是利用了多态达成的。而我们第一个继承的方式之所以不可以，是因为继承的方式直接改变的是我们的Connection的对象，如果我们要使用的话，那么我们一开始获得的Connection对象就必须是我们所创造的对象，而我们无法获得这个对象，因此我们采用这种有些迂回的方式，虽然绕，但是能用。

但这种方式也不是没有缺点的，那就是这种方式要写入的代码实在是太多了，需要重写很多的父类方法，非常难看，因此我们要对这个代码进行改造

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE95c998ba115451971d9124d844923992.png)

- 归还连接之适配器设计模式

适配器设计模式的思想是提供一个适配器类充当中间类，该中间类要实现Connection接口，然后将除了close方法外的所有方法都进行实现，接着我们的自定义的连接类只需要继承这个适配器类，再重写close方法就可以了，当然，这个中间的close()类应该要是抽象类而非接口类，因为在抽象类中才可以同时存在抽象方法和方法，并且可以被继承

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE78f588f6f227696c2134cd3a11fd7c04.png)

那么我们可以创建一个中间适配器类并写入代码如下

```
package com.itheima02;

import java.sql.*;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

/*
    1.定义一个适配器类，实现Connection接口
    2.定义连接对象的成员变量
    3.通过有参构造为变量赋值
    4.重写所有的抽象方法(除了close)
 */
public abstract class MyAdapter implements Connection {

    //2.定义连接对象的成员变量
    private Connection con;

    //3.通过有参构造为变量赋值
    public MyAdapter(Connection con){
        this.con=con;
    }

    //4.重写所有的抽象方法(除了close)
    @Override
    public Statement createStatement() throws SQLException {
        return con.createStatement();
    }
```

后面还有很多重写的抽象方法，这里为了版面就不放上来了。

然后我们再定义一个类令其连接中间类，写入代码如下

```
package com.itheima02;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/*
    1.定义一个类，继承适配器类
    2.定义连接对象和连接池容器对象的成员变量
    3.通过有参构造为变量赋值
    4.重写close方法，完成归还连接
 */
//1.定义一个类，继承适配器类
public class MyConnection3 extends MyAdapter{

    //2.定义连接对象和连接池容器对象的成员变量
    private Connection con;
    private List<Connection> pool;

    //3.通过有参构造为变量赋值
    public MyConnection3(Connection con,List<Connection> pool){
        super(con);
        this.con=con;
        this.pool=pool;
    }

    //重写close方法，完成归还连接
    @Override
    public void close() throws SQLException {
        pool.add(con);
    }
}
```

最后我们在连接池类里令其返回MyConnection3就可以了，其实这个本质和我们的第二个方法是差不多的，无非就是多了个中间适配器类让我们的代码一开始点击进去看起来更加舒服些罢了。该有的缺点还是有的，因此还是需要改进

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE20f42a0ace53caf9107ecb6c16c892a1.png)

- 动态代理

那么接着我们就来学习我们的最红一种归还连接池的方式，这种方式就非常得好，能够让我们不用写这么多重复的代码而又能实现我们所需要的功能，这个方法就是动态代理！再学习之前，我们要先了解下什么是动态代理，我们先来看看它的作用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc4e83a70c925c48e0b236e592936a3b9.png)

那么我们要怎么理解这个动态代理呢？我们通过一个案例来理解，首先我们创建一个学生类，并写入代码如下

```
package com.proxy;

public class Student {
    public void eat(String name) {
        System.out.println("学生吃"+name);
    }

    public void study() {
        System.out.println("在家自学");
    }
}
```

接着我们要实现的需求就是在不改动Student类中任何的代码的前提下，通过study方法输出一句话：来黑马学习，那么我们要如何去实现这个需求呢？这时候就需要用到我们的动态代理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE83afc084d9ed36b7f6baebfa8f181856.png)

动态代理有两个组成，一个是被代理对象，一个是代理对象，其中前者是真实的对象，而后者是内存中的一个对象。动态代理实现的前提是代理对象和被代理对象都实现相同的接口。而动态代理的使用则依赖于Proxy.newProxyInstance()方法

那么我们首先创造一个接口，内部写上student类的所有方法

```
package com.proxy;

public interface StudentInterface {
    void eat(String name);
    void study();
}
```

接着令Student类继承这个接口，然后我们在我们的测试类里写入如下代码

```
package com.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Test {
    public static void main(String[] args) {
        Student stu = new Student();
        /*stu.eat("米饭");
        stu.study();*/

        /*
            要求：在不改动Student类中任何的代码的前提下，通过study方法输出一句话：来黑马学习
            类加载器：和被代理对象使用相同的类加载器
            接口类型Class数组：和被代理对象使用相同接口
            代理规则：完成代理增强的功能
         */
          StudentInterface proxyStu = (StudentInterface) Proxy.newProxyInstance(stu.getClass().getClassLoader(), new Class[]{StudentInterface.class}, new InvocationHandler() {
            /*
                执行Student类中所有的方法都会经过invoke方法
                对method方法进行判断
                    如果是study，则对其增强
                    如果不是，还调用学生对象原有的功能即可
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                if(method.getName().equals("study")){
                    System.out.println("来黑马学习");
                    return null;
                }else {
                    return method.invoke(stu,args);
                }
            }
        });

          proxyStu.eat("米饭");
          proxyStu.study();
    }
}
```

这里我们先嗲用Proxy.newProxyInstance方法，该方法需要传入三个参数，这三个参数分别要实现代理的对象的类加载器，以及和被代理对象使用相同接口的接口的Class数组，最后要传入我们的代理规则，我们这里的代理规则采用匿名内部类的方式来实现，可以看到我们这里重写了invoke方法，我们只需要记住一件事情，那就是任何被我们代理的方法一旦执行，都要经过我们的invoke方法，因此我们在invoke方法里进行方法的判断，方法本身被封装到method对象里，我们通过方法名来判断其方法是否是我们要增强的方法，若是就对其进行增强，若不是就调用method的invoke方法并传入其对象和数据，这样就会令该方法按照原本的的方式执行。

最后我们通过我们创建的对象调用方法，就可以得到我们所需要的结果了。

- 归还连接之动态代理方式

那么接下来我们来正式学习动态代理方式来归还数据库，我们首先通过Proxy完成对Connect实现类对象的代理，然后我们在这个过程中判断是否是close方法，是的话就将其归还到池中，不是就照常执行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa902e3c4ee0a5b4405428ed620064330.png)

那么我们可以将我们的连接池的代码改造如下

```
/*
    自定义数据库连接池
 */
public class MyDataSource implements DataSource {
    //1.准备容器,用于保存多个连接对象,由于需要线程安全的集合对象，因此采用Collections的内置方法获取所需的集合对象
    private static List<Connection> pool = Collections.synchronizedList(new ArrayList<>());

    //2.定义静态代码块,通过工具类获取10个连接对象并放置于实现构造的集合容器中
    static {
        for (int i = 1; i <= 10; i++) {
            Connection con = JDBCUtils.getConnection();
            pool.add(con);
        }
    }

    @Override
    public Connection getConnection() throws SQLException {
        if(pool.size()>0){
            Connection con = pool.remove(0);

            Connection proxyCon = (Connection) Proxy.newProxyInstance(con.getClass().getClassLoader(), new Class[]{Connection.class}, new InvocationHandler() {
                /*
                    执行Connection实现类连接对象所有的方法都会经过invoke
                    如果是close，归还连接
                    反之则直接执行连接对象原有的功能即可
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    if(method.getName().equals("close")){
                        //归还连接
                        pool.add(con);
                        return null;
                    }else {
                        return method.invoke(con,args);
                    }
                }
            });
            return proxyCon;
        }else {
            throw new RuntimeException("连接数量已用尽");
        }
    }
    
    //4.定义getSize(),获取连接池容器的大小
    public int getSize() {
        return pool.size();
    }

```

可以看到我们这里主要进行的改造就是在连接池内部的改造，这里使用的动态代理的方式，我们传入了连接对象的类加载器，然后传入了对应的接口的Class文件，然后添加了增强规则，规则里我们就进行方法的判断，这个大家都懂了。然后这份代码同时也省略了后面许多的重写的方法

这份代码的唯一缺点就是由于这是我们自己编写的，所以其判断方式过于简单，存在缺陷

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6cb182d09964a256367642eb06151360.png)

- C3P0连接池的使用

由于我们自己的连接池做的太辣鸡了，所以我们这里要学习使用别人的连接池，也就是开源数据库连接池，这里我们先来学习C3P0连接池，请看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE71c901b6b3a7effd3478b146058ffcb0.png)

那么我们首先导入对应的jar包，然后我们将对应的配置文件复制进去，接着我们来看看配置文件的内容

```
<c3p0-config>
  <!-- 使用默认的配置读取连接池对象 -->
  <default-config>
   <!--  连接参数 -->
    <property name="driverClass">com.mysql.jdbc.Driver</property>
    <property name="jdbcUrl">jdbc:mysql://175.178.114.158:3306/db14</property>
    <property name="user">root</property>
    <property name="password">itheima</property>
    
    <!-- 连接池参数 -->
    <!--初始化的链接数量-->
    <property name="initialPoolSize">5</property>
    <!--最大连接数量-->
    <property name="maxPoolSize">10</property>
    <!--超时时间-->
    <property name="checkoutTimeout">3000</property>
  </default-config>

  <named-config name="otherc3p0"> 
    <!--  连接参数 -->
    <property name="driverClass">com.mysql.jdbc.Driver</property>
    <property name="jdbcUrl">jdbc:mysql://localhost:3306/db15</property>
    <property name="user">root</property>
    <property name="password">itheima</property>
    
    <!-- 连接池参数 -->
    <property name="initialPoolSize">5</property>
    <property name="maxPoolSize">8</property>
    <property name="checkoutTimeout">1000</property>
  </named-config>
</c3p0-config>
```

配置文件里首先有的是名字的指定，也就是说，我们可以通过指定特殊的名字来决定让我们的那些配置代码执行，比如说我们这里19行到后面是另外一份，而前面到19行又是一份，我们连接池参数里有初始的连接储量，还有最大的连接数量，当池中没有连接而又需要时，会创建新的连接，如果连接的数目过多就不创建了，此时指定一个等待时间，这里设置为3s，如果等待时间内还没有获得连接，那么就会抛出异常

那么接着我们创建一个测试代码，并写入代码如下

```
package com.itheima03;

import com.mchange.v2.c3p0.ComboPooledDataSource;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class C3P0Test1 {
    public static void main(String[] args) throws Exception{
        //1.创建c3p0的数据库连接池对象
        DataSource dataSource = new ComboPooledDataSource();

        //2.通过连接池对象获取数据库连接
        Connection con = dataSource.getConnection();

        //3.执行操作
        String sql = "SELECT * FROM student";
        PreparedStatement pst = con.prepareStatement(sql);

        //4.执行sql语句，接收结果集
        ResultSet rs = pst.executeQuery();

        //5.处理结果集
        while (rs.next()){
            System.out.println(rs.getInt("sid") + "\t" + rs.getString("name") + "\t" + rs.getInt("age") + "\t" + rs.getDate("birthday"));
        }

        //6.释放资源
        rs.close();
        pst.close();
        con.close();
    }
}
```

这里我们先创建c3p0的数据库连接池，然后获得连接池的内的链接，然后执行查询操作，最后的测试结果也没有问题

- C3P0连接池的配置

那么接着我们再来创建一个类来测试下我们的连接池里的连接的close方法到底是直接关闭了我们的连接还是把连接放回到了连接池中，我们创建一个类并写入代码如下

```
package com.itheima03;

import com.mchange.v2.c3p0.ComboPooledDataSource;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class C3P0Test2 {
    public static void main(String[] args) throws SQLException {
        //1.创建c3p0的数据库连接池对象
        DataSource dataSource = new ComboPooledDataSource();

        //2.测试
        for (int i = 1; i <= 11; i++) {
            Connection con = dataSource.getConnection();
            System.out.println(i+" : "+con);
            if(i==5){
                con.close();
            }
        }
    }
}
```

我们在第五次执行时调用了一次close方法，我们期待能够获得11个连接池对象并打印，且第五个和第六个是一样的连接对象，因为这个连接对象放进去又拿出来，所以是同一个连接对象，实际测试也的确是这样的，这就说明我们的close方法的确把连接放到了连接池中了

接着我们看我们的配置文件，可以通过指定不同的名字来指定执行不同的配置代码，我们这里采用的无参构造，没有任何指定，因此执行默认的代码，如果我们往里面指定了实际存在的字符串且在配置文件中真实存在，那么就会执行对应的配置，同样的，我们在配置文件里按照这个格式可以自己去指定各种不同的配置代码并用于执行

- Druid连接池的使用

那么学习完了C3P0连接池的使用之后，接着我们来学习Druid连接池的使用，这是阿里巴巴搞得连接池，也是国内目前最好用的连接池技术之一。先来看看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE513528a1084841251972beb360e644e5.png)

同样我们要导入jar包和配置文件，然后我们来看看配置文件里的内容

```
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://175.178.114.158:3306/db14
username=root
password=itheima
# 初始化连接数量
initialSize=5
# 最大连接数量
maxActive=10
# 超时时间
maxWait=3000
```

可以看到我们这个配置文件的内容还就那个跟上一个差不多，不过简洁了不少，这里就不再赘述了

然后我们就创建对应的测试类并写入代码如下

```
package com.itheima04;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Properties;

/*
    1.通过Properties集合，加载配置文件
    2.通过Druid连接池工程类获取数据库连接池对象
    3.通过连接池对象获取数据库连接进行使用
 */
public class DruidTest1 {
    public static void main(String[] args) throws Exception {
        //获取配置文件的流对象
        InputStream is = DruidTest1.class.getClassLoader().getResourceAsStream("druid.properties");

        //1.通过Properties集合，加载配置文件
        Properties prop = new Properties();
        prop.load(is);

        //2.通过Druid连接池工厂类获取数据库连接池对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);

        //3.通过连接池对象获取数据库连接进行使用
        Connection con = dataSource.getConnection();

        String sql = "SELECT * FROM student";
        PreparedStatement pst = con.prepareStatement(sql);

        //4.执行sql语句，接收结果集
        ResultSet rs = pst.executeQuery();

        //5.处理结果集
        while (rs.next()){
            System.out.println(rs.getInt("sid") + "\t" + rs.getString("name") + "\t" + rs.getInt("age") + "\t" + rs.getDate("birthday"));
        }

        //6.释放资源
        rs.close();
        pst.close();
        con.close();
    }
}
```

我们这里先获取我们配置文件的流对象，然后我们通过Properties集合加载我们的配置文件，这里具体的操作就是将流对象传入到我们的prop对象中，这里面什么原理说实话也不知道，也不用知道。接下来我们通过Druid连接池的工程类，传入该prop对象获得连接池对象，然后通过连接池对象获得连接，接着执行查询所有的语句，实际上，也的确可以查询，此时就说明我们的连接池是的确可以使用的

- 连接池的工具类

我们通过观察容易知道，其实我们的很多代码都是重复的，可以对其进行改进，比如说，我们的关闭方法，还有我们的创建连接池的代码，这些都是可以集合到一个工具类中的，所以本章我们就来集合这些代码到一个工具类中

那么我们可以创建一个工具类并写入如下代码

```
package com.itheima.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/*
    数据库连接池的工具类
 */
public class DataSourceUtils {
    //1.私有构造方法
    private DataSourceUtils(){};

    //2.声明数据源变量
    private static DataSource dataSource;

    //3.提供静态代码块，完成配置文件的加载和获取数据库连接池对象
    static {
        try {
            //完成配置文件的加载
            InputStream is = DataSourceUtils.class.getClassLoader().getResourceAsStream("druid.properties");

            Properties prop = new Properties();
            prop.load(is);

            //获取数据库连接池对象并赋给dataSource
            dataSource = DruidDataSourceFactory.createDataSource(prop);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    //4.提供一个获取数据库连接的方法
    public static Connection getConnection(){
        Connection con = null;
        try {
            con = dataSource.getConnection();
        }catch (Exception e){
            e.printStackTrace();
        }
        return con;
    }

    //5.提供一个获取数据库连接池对象的方法(学习框架时会用到)
    public static DataSource getDataSource() {
        return dataSource;
    }

    //6.释放资源
    public static void close(Connection con, Statement stat, ResultSet rs){
        if(con!=null){
            try {
                con.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

        if(stat!=null){
            try {
                stat.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

        if(rs!=null){
            try {
                rs.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}

```

在这个代码里，我们将我们的方法都声明为静态方法，然后我们里面集合了各种我们用得到的方法，那么接着我们就可以用这份工具类来改造我们之前的代码

```
package com.itheima04;

import com.itheima.utils.DataSourceUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class DruidTest2 {
    public static void main(String[] args) throws SQLException {
        //1.通过连接池工具类获取一个数据库连接
        Connection con = DataSourceUtils.getConnection();

        String sql = "SELECT * FROM student";
        PreparedStatement pst = con.prepareStatement(sql);

        //2.执行sql语句，接收结果集
        ResultSet rs = pst.executeQuery();

        //3.处理结果集
        while (rs.next()){
            System.out.println(rs.getInt("sid") + "\t" + rs.getString("name") + "\t" + rs.getInt("age") + "\t" + rs.getDate("birthday"));
        }

        //4.释放资源
        DataSourceUtils.close(con,pst,rs);
    }
}

```

可以看到上面的这份代码就要比我们之前的代码简洁太多了，这个就很棒！