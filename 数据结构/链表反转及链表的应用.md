链表反转

单链表的反转是面试中考试的一种高频题目，因此我们要学习单链表的反转

先来看看我们的需求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE31741e96b4ab30a9fa36e01b081287f6.png)

当然，理论上如果我们只是想输入这么一个数据的话只要倒序遍历链表就可以达成我们的目的了，但是我们这里的目的是将链表的指向全部逆转过来，然后顺序遍历之后获得反转之后的结果

那我们应该如何去实现呢？先来看看其反转的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7aee06db830d1676a7dff962c765034a.png)

我们再来看看其图示原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfb6ee0cccf0591c947921f3313d23ecc.png)

我们先来搞明白这个方法的原理，这个方法本身是利用递归方法实现的，首先我们定义个reverse方法用于反转单向链表，该方法会先通过递归的方式优先进入到最后一个结点中，一旦我们到了最后一个结点，那么我们就要令head结点的尾指针域指向这个最后的结点，然后通过递归的反转不断地将每一个结点指向上一个结点，同时要消除原先上一个结点指向下一个结点的指针，最终完成反转

接下来我们可以实现其代码如下

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class LinkList<T> implements Iterable<T>{
    //记录头结点
    private Node head;
    //记录链表的长度
    private int N;

    //结点类
    private class Node {
        //存储元素
        T item;
        //指向下一个结点
        Node next;

        public Node(T item, Node next){
            this.item=item;
            this.next=next;
        }
    }

    //单向链表的构造方法
    public LinkList() {
        //初始化头结点,头结点不存储数据，因此item是null，头结点刚初始化也不指向谁，因此next也是null
        this.head=new Node(null,null);
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear() {
        head.next=null;
        this.N=0;
        //清空链表，直接让头结点不指向下一个结点，这样结点由于没有指向，会被垃圾回收器回收，达到清空链表的目的
    }

    //获取链表的长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //获取指定位置i处的元素
    public T get(int i) {

        //通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = head.next;//先创造一个结点n并赋予其头结点的引用
        for (int index = 0; index < i; index++) {
            n=n.next;//每次循环令n变为其结点的引用，循环i次就正好到自己想要到的结点的位置
        }

        return n.item;
    }

    //向链表中添加元素t
    public void insert(T t) {
        //先找到当前最后一个结点

        Node n = head;//先定义一个结点n令其等于头结点
        while (n.next!=null){
            n=n.next;
            //利用while循环来将n的next循环到指向结尾位置
        }

        //创建新结点，保存元素t
        Node newNode = new Node(t,null);
        //让当前最后一个结点指向新结点
        n.next=newNode;
        //元素的个数+1
        N++;
    }

    //向指定位置i处，添加元素t
    //要想添加元素就要找到想添加元素的位置的前/后各一个结点
    public void insert(int i,T t) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
            //循环i-1次，正好到i位置的前一个结点
        }

        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点要指向原来i位置的结点
        Node newNode = new Node(t,curr);
        //原来i位置的前一个结点指向新结点
        pre.next=newNode;
        //元素的个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回被删除的元素
    //要删除指定位置的i处的元素，同样要先找到该元素的一个前后元素
    public T remove(int i) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
        }
        //要找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //前一个结点指向下一个结点
        pre.next = nextNode;
        //元素个数-1
        N--;
        return curr.item;
    }

    //查找元素t在链表中第一次出现的位置
    public int indexof(T t){
        //从头结点开始，依次找到每一个结点，取出item和t比较，相同则返回下标
        Node n = head;
        for (int i = 0;n.next!=null; i++) {
            //循环继续条件为n.next!=null，这样就可以达到遍历到底的效果
            n=n.next;
            if(n.item.equals(t)){
                return i;
            }
        }
        return -1;//代码执行到此说明链表里没有目标元素，因此返回-1
    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
        //该方法的重写要求返回一个iterator对象
        //但是iterator是接口，无法直接创造对象
        //因此创建一个内部类来实现iterator接口
        //通过创建该内部类的方式来返回有相同作用的对象
    }

    //实现iterator接口需要重写hasNext和Next方法
    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
            //该方法用于判断当前指针指向还有没有下一个元素
            //用n.next!=null的判断代码可以通过判断其指针域是否为空来进行判断
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
            //先让指针指向下一个结点，接着返回该结点的数据内容
        }
    }

    //用于反转整个单向链表的方法
    public void reverse(){
        //先判断当前链表是否为空，若为空则结束运行
        if(isEmpty()){
            return;
        }
        //程序运行到此说明不为空，执行用于反转链表的重载reverse方法
        reverse(head.next);
    }

    //反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr) {
        //若结点为最后一个结点，即该结点不再指向下一个结点
        if(curr.next==null){
            //则让首结点指向该结点，该结点是原先的尾结点
            head.next=curr;
            //返回该尾结点
            return curr;
        }
        //递归返回的当前结点用定义好的pre结点对象来进行保存
        Node pre = reverse(curr.next);
        //让返回的结点的尾指针域指向原先的上一个结点
        //相当于是加上了后面对前面的指针
        pre.next=curr;
        //把当前结点的尾指针域赋值为null
        //相当于是把原先指向下一个结点的指针给清除
        curr.next=null;
        //最后按照需求返回当前的结点，这个返回只是为了不报错而设计的
        //设计在程序里这个返回值用户可以选择接收也可以选择不接收
        return curr;
    }
}
```

174-193行的代码就是我们添加的用于反转的代码，里面已经有了不少用于解释的注释了，这里不多提



快慢指针

接着我们来学习快慢指针，快慢指针可以解决链表的三个问题，分别是中间值问题、单向链表是否有环问题和有环链表入口问题。

我们通过自己定义两个快慢指针，以此来制造出自己想要的差值，这个差值可以找到我们链表上对应的结点，一般来说，快指针的移动步长为慢指针的两倍

我们先来解决中间值问题，假设我们现在有一个单向链表，我们的需求是我们传入链表的首结点，我们就能够找到其中间值，那么我们应该怎么利用快慢指针来实现需求呢？请看代码

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        Node<String> first = new Node<>("aa",null);
        Node<String> second = new Node<>("bb",null);
        Node<String> third = new Node<>("cc",null);
        Node<String> fourth = new Node<>("dd",null);
        Node<String> fifth = new Node<>("ee",null);
        Node<String> six = new Node<>("ff",null);
        Node<String> seven = new Node<>("gg",null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;

        //查找中间值
        String mid = getMid(first);
        System.out.println("中间值为："+mid);
        //中间值为：dd
    }

    /**
     *
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
    public static String getMid(Node<String> first) {
        //先定义两个指针，两指针的起始位置都是first
        Node<String> fast = first;
        Node<String> slow = first;
        //使用两指针遍历链表，快指针到最后一个结点时返回慢指针指向的结点
        while (fast!=null&&fast.next!=null) {
            //防止出现空指针异常所以在循环里多加了一个fast不为空的判断
            //接着定义快慢指针，快指针走两步慢指针走一步
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow.item;
    }

    //结点类
    private static class Node<T> {
        //储存数据
        T item;
        //下一个结点
        Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }
}


```

接下来我们来解决单向链表中是否有环的问题，我们先来看看有环与无环的单向链表

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeecf6271d4695b7a2d66a34f3e39bf3a.png)

我们只要定义两个快慢指针令其遍历数组，并在遍历过程中不断判断两指针是否相等就可以确定是否有环，因为如果是无环单向链表，则快指针永远都不可能和慢指针重合，但如果是有环单向链表，那么随着循环的不断进行，快指针必然会与慢指针重合，通过这种方法来判断其是否有关，

同样的，我们这里也是要求我们只要传入首结点，就能够找出链表是否有环，我们可以构造代码如下

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        Node<String> first = new Node<>("aa",null);
        Node<String> second = new Node<>("bb",null);
        Node<String> third = new Node<>("cc",null);
        Node<String> fourth = new Node<>("dd",null);
        Node<String> fifth = new Node<>("ee",null);
        Node<String> six = new Node<>("ff",null);
        Node<String> seven = new Node<>("gg",null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //产生环
        seven.next = third;

        //调用判断链表是否有环的方法
        boolean circle = isCircle(first);
        System.out.println("first链表中是否有环？"+circle);
        //true
    }

    public static boolean isCircle(Node<String> first) {
        //定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;

        //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
        while (fast!=null&&fast.next!=null){
            //防止空指针异常而特别设置的循环条件
            fast = fast.next.next;
            slow = slow.next;

            if(fast.equals(slow)){
                return true;
            }
        }

        return false;
    }

    //结点类
    private static class Node<T> {
        //储存数据
        T item;
        //下一个结点
        Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }
}


```

有环链表的入口问题

如果我们已经确定了一个链表有环，那么我们应该如何确定这个链表的环的入口呢？我们只要在快慢指针第一次相遇的时候定义一次新的慢指针，当这个慢指针和原来的慢指针相遇时所指的结点就是链表的环的入口了。这里的原理涉及到了数论的知识，我们不多做提及，反正这么做就对了的

那么我们可以实现其代码如下

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        Node<String> first = new Node<>("aa",null);
        Node<String> second = new Node<>("bb",null);
        Node<String> third = new Node<>("cc",null);
        Node<String> fourth = new Node<>("dd",null);
        Node<String> fifth = new Node<>("ee",null);
        Node<String> six = new Node<>("ff",null);
        Node<String> seven = new Node<>("gg",null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //产生环
        seven.next = third;

        //调用判断链表是否有环的方法
        Node<String> entrance = getEntrance(first);
        System.out.println("first链表中环的入口的结点元素为"+entrance.item);
        //cc
    }

    public static Node getEntrance(Node<String> first) {
        //定义快慢指针
        Node<String> fast = first;
        Node<String> slow = first;
        Node<String> temp = null;
        //先将慢指针定义为null，存在但还不赋值

        //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
        while (fast!=null&&fast.next!=null){
            //防止空指针异常而特别设置的循环条件
            fast = fast.next.next;
            slow = slow.next;

            //判断快慢指针是否相遇
            if(fast.equals(slow)){
                //一旦相遇就定义新的慢指针
                temp = first;
                continue;
                //跳过下面的内容执行
                //让temp指针在这一轮只定义不行动
            }

            //设置循环条件，让慢指针进行移位动作
            if(temp!=null){
                temp = temp.next;
                //每次移位判断两慢指针是否相等
                //若相等则结束循环
                if(temp.equals(slow)){
                    break;
                }
            }
        }
        return temp;
    }

    //结点类
    private static class Node<T> {
        //储存数据
        T item;
        //下一个结点
        Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }
}
```



循环链表问题

那么到此为止我们就已经学习完了快慢指针了，接着我们来学习下链表里的循环链表的问题，先来看看循环链表的演示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE05ea6044892fe43ef890c8540dcad94b.png)

简而言之就是将最后一个结点的尾指针域指向头结点，将头结点的引用赋给最后一个结点的尾指针域就完了，因为太简单所以代码都省略了



约瑟夫问题

接着我们来学习解决链表的一个经典的约瑟夫问题，我们先来看看什么是约瑟夫问题吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE72efa64e05c3dee38e4e13fc6f05c3b3.png)

接着我们可以把这个问题转换成链表的形式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0c9defc090f97d3176cda3c9697a5f51.png)

我们再来看看其图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0520d7412253bbb2b3b67db817c2841a.png)

接着我们来详细讲讲其具体的实现原理，首先我们需要构建这样一个循环链表，这个循环链表有41个结点，尾结点指向头结点。接着我们应该要模拟报数，每次报到3就将报数为3的位置的结点删除，然后其下一个结点要继续从1开始报数这样不断轮回，直到只剩下最后一个人

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8588f01e716924958d4fe9c4cf79a8e0.png)

那么现在我们来看看我们的代码实现

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        //解决约瑟夫问题

        //1.构建包含41个结点的循环链表，分别储存1~41之间的值，储存的值可以视为每个人的编号
        //用于记录首结点的结点，先赋值为null，因为我们还没有创建任何结点
        Node<Integer> first = null;
        //用于记录前一个结点，同样赋值为null，因为我们的首结点也没有前一个结点
        Node<Integer> pre = null;

        //用for循环来创建41个结点
        for (int i = 1; i <= 41; i++) {
            //之所以采用i=1的形式来创建，是因为我们的编号要求是从1开始的
            //如果是第一个结点的情况
            if(i==1){
                //是第一个节点我们就直接创建新结点并将该结点赋予first，此时first成为了首结点
                first = new Node<>(i,null);
                //让pre记录first结点，便于下面的新结点的创建
                pre = first;
                continue;
            }

            //如果不是第一个结点的情况
            //先创建一个新结点
            Node<Integer> newNode = new Node<>(i,null);
            //将上一个结点的尾指针域指向新结点
            pre.next = newNode;
            //让新创建的结点的引用赋给pre，让我们可以调用pre来代表这个节点
            pre = newNode;
            /*这里我们事先定义的pre结点变量的作用就显现出来了，正是因为我们定义了这个
            * pre变量，因此在非第一个结点的创建的中，我们可以通过重复调用pre的方式
            * 来达到让上一个结点的尾指针域指向新结点的目的，如果我们不定义pre变量
            * 的话，那么我们就无法做到这个动作，定义一个变量来记录上一个变量，以此来
            * 实现让上一个变量的指向下一个对象的指向动作，这个思想值得我们学习
            * 那我们应该什么时候就需要自己去定义一个变量来储存前一个对象呢？我觉得
            * 我们可以暂时简单理解为如果我们需要重复进行指向动作的话，那么我们就应该
            * 创建一个变量来保存上一个结点，便于我们后续的重复指向*/

            //如果是最后一个结点，那么我需要令其尾指针域指向头指针
            if(i==41) {
                pre.next=first;
            }
        }

        //2.定义count计数器用于模拟报数
        int count = 0;
        //3.不断遍历循环链表，进行游戏
        //记录每次遍历过程中拿到的结点，默认从首结点开始，这是自然，因为我们的游戏就是从编号1的人开始报数的
        //可以简单理解为指向报数的人的指针
        Node<Integer> n = first;
        //记录当前结点的上一个结点，其主要作用就是为了完成链表内结点的指向，没有遍历前先赋值为null
        Node<Integer> before = null;
        /*构建while循环用于遍历，之所以我们的结束条件写为while是因为当我们的代码到最后一个
        结点时，我们的代码会令最后一个结点指向自身，当指向自身时，就说明了此时只剩下约瑟夫了
        。这时就是已经符合我们要求了的，所以我们的程序执行到此就可以结束了，因此我们的循环
        结束条件是n!=n.next;即只要n不是指向自身，我们就继续进行遍历
         */
        while (n!=n.next){
            //模拟报数
            count++;
            //判断当前报数是否为3
            if(count==3){
                //若为3，
                // 则删除当前结点并打印被删除结点，重置count并且让当前结点n后移一位
                before.next = n.next;//删除当前结点
                System.out.print(n.item+",");//打印被删除结点
                count=0;//重置count
                n=n.next;//让当前结点n后移
            }else {//若不为3，让before变为当前结点，同时让当前结点后移一位
                before=n;
                n=n.next;
            }
        }

        //打印最后一个元素
        System.out.println(n.item);
    }
    //结点类
    private static class Node<T> {
        //储存数据
        T item;
        //下一个结点
        Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }
}
```

