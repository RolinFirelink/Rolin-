- 新增分类

这个也是要经典进行一个实体类的提供，然后利用MP提供给我们的功能来创建对应的三层调用关系，这里就不贴上代码了，直接看步骤吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb80812ee9ed9e3cd6cc0f8890071a9e8.png)

然后我们来分析下前端往服务器上发送的请求，来确定我们的映射地址

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbbf2c545474d5a33e583154688a53e07.png)

最终我们可以写入我们的代码如下，没什么特别值得说的，自己看吧

```
/**
 * 分类管理
 */
@RestController
@RequestMapping("/category")
@Slf4j
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    @PostMapping
    public R<String> save(@RequestBody Category category){
        log.info("category:{}",category);
        categoryService.save(category);
        return R.success("新增分类成功");
    }
}

```

最后我们值得一提的是，我们这里的添加功能，实际上我们可以添加两种菜品和套餐，但是他们都共用一个添加方法，我们在后端中通过一个数字类型的变量来确定他们分别表示的是菜品还是套餐

- 分类信息分页查询

分类信息的分页查询的过程的步骤和我们员工管理的分页查询差不多，我们这里就迅速讲完了，先来看看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE41bbf26e779f42cf7cf7916a6e356d14.png)

那么我们可以写入我们的执行分页查询的代码如下，我们这里还要构造条件构造器，让我们的数据按照其优先级进行降序的排序，显示在我们的客户端上

```
/**
 * 分页查询
 * @param page
 * @param pageSize
 * @return
 */
@GetMapping("/page")
public R<Page> page(int page,int pageSize) {
    //分页构造器
    Page<Category> pageInfo = new Page<>(page,pageSize);
    //条件构造器
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
    //添加排序条件，根据sort进行排序
    queryWrapper.orderByAsc(Category::getSort);

    //分页查询
    categoryService.page(pageInfo,queryWrapper);
    return R.success(pageInfo);
}
```

- 删除分类

先来看看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdbc4d673915ec27d5795af9db9a6fa94.png)

我们执行删除操作的时候，应该是要判断我们的分类是否关联了某一个菜品或者套餐的，如果真的关联了，那么我们就不能删除，否则我们就可以删除，我们这里先实现一个简单粗暴的删除功能的后端代码，那么我们可以写入代码如下

```
/**
 * 根据id删除分类
 * @param id
 * @return
 */
@DeleteMapping
public R<String> delete(Long id) {
    log.info("删除分类，id为: {}",id);

    categoryService.removeById(id);

    return R.success("分类信息删除成功");
}
```

当然我们这个逻辑属实是太简单粗暴了，接着我们要对这个逻辑进行改进。我们的想法是让删除方法执行之前先在数据库里查询有没有对应的菜品或者套餐，若有，则抛出业务异常，反之则正常进行删除。这里有的同学可能会问了，我们不是说要尽量减少业务上对数据库的交互吗？这里我们可以用主键关联来实现这个功能吧？为什么不用？这是因为比起去数据库再次查找数据所造成的负担，主键的负担显然更加重，也更加占用资源，所以我们不使用主键，我们使用再次往数据库中查找的方法。

这里值得一提的是，我们抛出的异常应该要是我们自定义的异常，因此我们要自定义一个异常类并对其进行处理，我们上抛时也抛出我们自己的异常，所以我们可以写入我们的异常类如下

```
/**
 * 自定义业务异常
 */
public class CustomException extends RuntimeException{

    public CustomException(String message){
        super(message);
    }

}
```

然后我们在全局异常的处理类里定义一个处理该异常的方法，这样我们的全局异常处理类就可以自动处理该类的异常了

```
/**
 * 异常处理方法
 * @param ex
 * @return
 */
@ExceptionHandler(CustomException.class)
public R<String> exceptionHandler(CustomException ex){
    log.error(ex.getMessage());
    return R.error(ex.getMessage());
}
```

然后我就可以正式来写我们的自定义的删除方法了，首先我们在对应生成的业务层的接口里先自定义自己的删除方法

```
public interface CategoryService extends IService<Category> {
    public void remove(Long ids);
}
```

然后在实现层里实现这个方法，我们这里执行的查询是查询对应的菜品的数量，如果数量不为零，我们就抛出业务异常，查询时使用的LambdaQueryWrapper类，若全部都可以通过，我们则调用父类的通过id删除的方法

```
@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService{

    @Autowired
    private DishService dishService;

    @Autowired
    private SetmealService setmealService;

    /**
     * 根据id删除分类，删除之前需要进行判断
     * @param ids
     */
    @Override
    public void remove(Long ids) {
        LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();

        //添加查询条件，根据分类id进行查询
        dishLambdaQueryWrapper.eq(Dish::getCategoryId,ids);
        int count = dishService.count(dishLambdaQueryWrapper);

        //查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常
        if(count!=0){
            //已经关联菜品，抛出业务异常
            throw new CustomException("当前分类下关联了菜品，不能删除");
        }

        //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常
        LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();

        //添加查询条件，根据分类id进行查询
        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,ids);
        int count2 = setmealService.count(setmealLambdaQueryWrapper);

        if(count2!=0){
            //已经关联套餐，抛出业务异常
            throw new CustomException("当前分类下关联了套餐，不能删除");
        }

        //正常删除分类
        super.removeById(ids);
    }
}

```

当然，我们这里要注意的是，我们这里查询时，我们使用了菜品和套餐的对象，这些对象我们是事先写好并加入的，同样的，我们也通过MP实现了其三层逻辑，最后由于我们前端传入的是变量名是ids，因此这里我们自定义方法时使用的变量名也要是ids

- 修改分类

首先我们通过分析前端代码，我们可以得到两件事情，第一件事情是数据的回显前端已经帮我们做好了，我们后端人员不需要再费心了。其次是前端发送的请求路径就是一个单纯的category，后面拼接上对应的json格式的菜品修改的数据。

那么根据上面的信息，我们容易写入我们的修改代码ruxi

```
/**
 * 根据id修改分类信息
 * @param category
 * @return
 */
@PutMapping
public R<String> update(@RequestBody Category category) {
    log.info("修改分类信息:{}",category);

    categoryService.updateById(category);

    return R.success("修改分类信息成功");
}
```

