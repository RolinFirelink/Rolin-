接着我们来学习我们的工厂模式，我们先来看一个点咖啡的案例。

我们有一个咖啡店类，其下有一个返回咖啡对象的方法，咖啡对象内容有三个方法，分别是加奶、加糖和获得名字，其下有两个子类，分别是美式咖啡和拿铁咖啡，两个子类都重写了获得名字的方法，用于判断其是美式咖啡还是拿铁咖啡

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6e9bfc5d19f41fa9c039aae5f7287480.png)

但是我们现在这个案例是有问题的，其最大的问题是，我们的这些咖啡的子类镀锡都是需要的手动new出来的，这样一旦我们需要新增一个咖啡对象，那么所有和new对象有关的地方就要修改一遍，这显然违背了开闭原则，因此我们需要令其解耦，此时我们需要使用到工厂模式来完成这个目的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE62f8b4eee697e5d86c8f70bedfb0f3ab.png)

我们首先来学习简单工厂模式，其不属于GOF的23种经典设计模式，其实他与其说是一种设计模式，不如说是一种编程习惯，首先我们简单工厂包含如下角色：

- 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。

- 具体产品 ：实现或者继承抽象产品的子类

- 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。

那么我们可以使用简单工厂对上面的案例进行改进，我们首先创建一个简单工厂对象，然后其下可以生成对应的咖啡对象

```
public class SimpleCoffeeFactory {

    public Coffee createCoffee(String type){
        //声明Coffee类型的变量，根据不同类型的创建不同的coffee子类对象
        Coffee coffee = null;
        if("american".equals(type)){
            coffee = new AmericanCoffee();
        }else if("latte".equals(type)){
            coffee = new LatteCoffee();
        }else {
            throw new RuntimeException("对不起，没这种咖啡");
        }

        return coffee;
    }
}
```

然后我们的咖啡店对象内部就直接创建该工厂对象，调用该工厂对象的创建咖啡的方法即可获得我们所需要的咖啡，对得到的咖啡进行对应的处理再返回即可

```
public class CoffeeStore {

    public Coffee orderCoffee(String type) {

        SimpleCoffeeFactory factory = new SimpleCoffeeFactory();
        //调用生成咖啡的方法
        Coffee coffee = factory.createCoffee(type);

        //加配料
        coffee.addSugar();
        coffee.addMilk();

        return coffee;
    }
}

```

那么上面的关系用图示则是如下所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE005e2dde6abb8588dc0f19aa6c6c355e.png)

当然，有的同学可能会说，我们即使改造成这样，那不还是违反开闭原则吗？我们添加新的咖啡对象时，仍然要修改工厂类的代码，那我们这搞得这工厂对象有啥用呢？其实，我们搞这个工厂类，就相当于是解除了咖啡店和具体咖啡类的耦合，但是又产生了两个新的耦合，分别是咖啡店和咖啡工厂的耦合以及工厂对象和商品对象的耦合。那么这样有什么用呢？其最大的作用就是我们让具体的咖啡店只与咖啡工厂耦合，而不是和具体的咖啡对象耦合，因为往往我们的生产咖啡的工厂对象只有一个，但是我们的咖啡店是可能有非常多的，我们这样做，这样我们在实际的生产环境中，如果我们想要更换咖啡店对象，就不必做非常麻烦的许多对代码上的修改了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE670ae3c0c8b89e11c4cfbc241fdb3689.png)

最后我们来看看其优缺点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE65fd06fe463b6e66ad7c11e708074c86.png)

最后我们值得一提的是，实际开发时，也是有一部分人讲工程类中创建对象的功能定义为静态的，这就是静态工程模式，它也不是23种设计模式中的，对应到我们具体的代码上就是在我们工厂类中创建具体对象的方法上加个static关键词

- 工厂方法模式

上面的简单工程模式仍然没有解决其喂饭开闭原则的问题，如果我们要解决开闭原则的问题，那么我们就要使用工厂方法模式，我们先来看看其概念和具体的结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa47eee5cc743b11ffe2414ef34bf49a9.png)

然后我们来看看其整体的结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2887739fcc58deb4ec10a9a4ed0563b7.png)

接着我们来正式用代码来实现该结构

首先我们要创建对应的工厂接口对象，这里我们只提供最基本的生成咖啡对象的方法

```
public interface CoffeeFactory {
    //创建咖啡对象的方法
    Coffee createCoffee();
}

```

然后创建两个工厂对象，分别是美式工厂和拿铁工厂，其下对应的方法都是生成对应的咖啡对象并返回（这里展示其一），当然他们都应该要实现我们的咖啡工厂接口

```
package com.itheima.reggie.design;

public class AmericanCoffeeFactory implements CoffeeFactory{

    @Override
    public Coffee createCoffee() {
        return new AmericanCoffee();
    }
}
```

我们在对应的咖啡店内注入工厂对象属性，再提供对应的set方法和得到咖啡的方法

然后我们在对应的测试类中创建对应的咖啡店类对象和工厂对象，我们要获得对应的咖啡就直接创建具体的咖啡工程对象并设置到咖啡店对象中即可，最后我们调用咖啡店对应的点咖啡方法即可得到我们对应的咖啡对象

```
public class Client {
    public static void main(String[] args) {
        //创建咖啡店类对象
        CoffeeStore store = new CoffeeStore();
        //创建工厂对象
        //CoffeeFactory factory = new AmericanCoffeeFactory();
        CoffeeFactory factory = new LatteCoffeeFactory();
        store.setFactory(factory);

        //点咖啡
        Coffee coffee = store.orderCoffee("latte");

        System.out.println(coffee.getName());
    }
}

```

上面的工厂对象模式就是严格符合开闭原则的模式，我们要新添加咖啡对象时只需要创建对应的咖啡工厂对象和具体的咖啡对象即可，不需要对原工厂代码做任何的修改

但是其问题也很明显，就是我们每增加一个具体产品需要一并增加一个具体的工程类，这太麻烦了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcab34ebd9a57eebe20887318e185ee0d.png)

- 抽象工厂模式

那么我们要如何解决上面的工厂模式的缺点呢？这时我们就要使用到抽象工厂模式，我们之前介绍的工厂方法模式中只考虑一类产品的生产，而现实中的工厂往往是负责一类产品的生产的，那么我们创建的工厂接口也可以令其能够生产多个级别的产品，我们将同一个公司/风格/流派的产品称为一个产品族，将同一级别的产品称为一个产品等级

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd310bb1f637d57d715e9a48fb06f9f20.png)

接着我们来看看抽象工厂模式的概念和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE272e03ea922a7688ea3d23d83df7d5cc.png)

具体到我们的实际代码中，则是我们要将我们的对应的产品分类，这里我们可以通过产品族分类，我们创建一个工厂接口对象，然后具体实现不同的产品族工厂，不同的产品族工厂都具有生成同一产品族的商品的功能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdda13fc4cd526b8d329620c970c5fa43.png)

那么首先我们创建点心工厂的接口，其下具有生产咖啡功能

```
public interface DessertFactory {

    //生产咖啡的功能
    Coffee createCoffee();

    //生产甜品的功能
    Dessert createDessert();
}
```

然后我们创建具体的工厂对象的实现类，其下要实现生成咖啡和甜品的功能的方法，当然，我们要实现的都是同一产品族的产品，这里我们只展示生产美式风格的产品工厂的代码

```
public class AmericanDessertFactory implements DessertFactory{

    @Override
    public Coffee createCoffee() {
        return new AmericanCoffee();
    }

    @Override
    public Dessert createDessert() {
        return new MatchaMouse();
    }
}
```

然后由于我们这里要生产点心，因此我们这里还要创建点心对象的抽象类以及其具体的实现类（此处省略代码）

最后我们在测试类中直接创建生产对应产品族的工厂对象即可获得我们所需要的产品，如果我们要增加一个产品族的话，那么只需要增加一个对应的工厂类即可，同样符合开闭原则

其优点在于如果我们的产品族中是被设计成多个对象一起工作时，其可以保证客户端只使用同一个产品族的对象，然而其缺点在于如果我们的产品族中要增加一个新的产品时，那么所有的工厂类都需要进行修改，比如说我们的点心类要多加一个汉堡的话，那么其下的所有点心工厂都需要修改其源代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE03d048de03219f9a9051d70e2a233355.png)

正是因为其存在这个缺点，因此这种抽象工厂模式是具有对应的使用场景的，满足以下场景我们就推荐使用抽象工厂模式来进行开发

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0a502e6919ab60f71d7a4924eb6a7fd5.png)

- 模式扩展

其实到现在，我们的工厂模式的全部内容就已经讲完了，但是我们这里还是多讲一个内容，这个内容是讲解我们开发中一般是如何结合配置文件和工厂模式来一起开发我们的工厂模式的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE26ddef9b16bb6eafc995cde49d32ebc5.png)

首先我们需要创建一个对应的配置文件，然后在其下左边写唯一标识的字符串，右边写要创建的实体类的类名

```
american=com.itheima.reggie.design.AmericanCoffee
latte=com.itheima.reggie.design.LatteCoffee
```

然后我们创建对应的咖啡工程对象，在其下加载对应的配置文件，将创建的对象放置于Map集合中，再提供一个根据名字获得指定对象的方法

```
public class CoffeeFactory {

    //加载配置文件，获取配置文件中配置的全类名，并创建该类的对象进行存储
    //1.定义容器对象存储咖啡对象
    private static HashMap<String,Coffee> map = new HashMap<>();

    //2.加载配置文件，只需要加载一次
    static {
        //2.1 创建Properties对象
        Properties p = new Properties();
        //2.2 调用p对象中的load方法键配置文件的加载
        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try {
            p.load(is);
            //从p集合中获取全类名并创建对象
            Set<Object> keys = p.keySet();
            for (Object key:keys) {
                String className = p.getProperty((String) key);
                //通过反射技术创建对象
                Class clazz = Class.forName(className);
                Coffee coffee = (Coffee) clazz.newInstance();
                //将名称和对象存储到容器中
                map.put((String) key,coffee);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    //根据名称获取对象
    public static Coffee createCoffee(String name){
        return map.get(name);
    }
}
```

最后我们的测试方法中只要通过工厂对象的方法传入指定的字符串即可获得我们所需要的对象

```
public class Client {
    public static void main(String[] args) {
        Coffee coffee = CoffeeFactory.createCoffee("american");
        System.out.println(coffee.getName());
        System.out.println("=========================");
        Coffee latte = CoffeeFactory.createCoffee("latte");
        System.out.println(latte.getName());
    }
}
```

这其实就类似于我们的Spring中的对象管理，Map集合就类似于我们的容器，我们可以通过名字自动装配对象，我们这里也是通过名字自动获得我们需要对象

- JDK源码解析

最后我们来看看JDK中的源码，看看其哪些类使用了工厂模式

```
public class Demo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("令狐冲");
        list.add("风清扬");
        list.add("任我行");

        //获取迭代器对象
        Iterator<String> it = list.iterator();
        //使用迭代器遍历
        while(it.hasNext()) {
            String ele = it.next();
            System.out.println(ele);
        }
    }
}
```

获取迭代器对象这个大伙们都做过，这里迭代器对象是接口，那么其返回的是哪个迭代器对象的接口，其又是怎么返回的呢？这就涉及到源码了，我们接下来就来解析源码

先来看看其结构图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9984f85d438b3f9d64a0e4adc0444b6c.png)

Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。

具体的源码我们就不翻了，翻了也是一样的结果，我们这里知道就可以了

最后我们来了解一下其他de

> 1,DateForamt类中的getInstance()方法使用的是工厂模式；

> 2,Calendar类中的getInstance()方法使用的是工厂模式；