现在我们来学习迭代器模式，这个模式就要提及我们远古时候的记忆了，以前学习过的东西给我们埋伏笔了属于是

首先我们先来看看其概述以及结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2994bc7a37dc914b01ff1f85a7df7f89.png)

看着就感觉非常的相似，非常的有感觉啊，好像我们之前学习集合的时候就学过这玩意啊

我们照样通过一个案例来加深我们对该模式的理解，先看看案例需求以及类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdb41370cd39084a0adc5a949eb2649b9.png)

首先我们需要创建对应的学生类，然后提供对应的方法

```
package com.login;

public class Student {
    private String name;
    private String number;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", number='" + number + '\'' +
                '}';
    }

    public Student() {
    }

    public Student(String name, String number) {
        this.name = name;
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }
}
```

然后我们创建抽象迭代器接口，其下定义两个方法，判断是否还有元素以及获取下一个元素

```
//抽象迭代器角色接口
public interface StudentIterator {

    //判断是否还有元素
    boolean hasNext();

    //获取下一个元素
    Student next();
}

```

接着我们创建具体的得带器角色类，其下提供两个属性，第一个是集合对象，第二个是一个坐标，用于记录遍历时的位置，其下要实现接口中的两个方法，第一个方法是判断还有没有下一个元素，我们直接判断当前位置是否到达集合最大位置即可，第二个方法是获得集合中指定位置的元素，直接获得对应坐标的元素再令下标+1即可

```
//具体迭代器角色类
public class StudentIteratorImpl implements StudentIterator{

    private List<Student> list;
    private int position = 0;//用于记录遍历时的位置

    public StudentIteratorImpl(List<Student> list) {
        this.list = list;
    }

    @Override
    public boolean hasNext() {
        return position<list.size();
    }

    @Override
    public Student next() {
        //从集合中获取指定位置的元素
        return list.get(position++);
    }
}

```

然后我们再创建一个抽象聚合接口，其下有添加、删除学生功能，而最重要的是获取迭代器对象的功能

```
//抽象聚合接口
public interface StudentAggregate {

    //添加学生功能
    void addStudent(Student stu);

    //删除学生功能
    void removeStudent(Student stu);

    //获取迭代器对象功能
    StudentIterator getStudentIterator();
}
```

接着我们创建抽象聚合的即可的实现类，可以看到我们这里实现这三个方法，而获取迭代器对象的方法就是直接返回一个迭代器对象即可

```
public class StudentAggregateImpl implements StudentAggregate{

    private List<Student> list = new ArrayList<>();

    @Override
    public void addStudent(Student stu) {
        list.add(stu);
    }

    @Override
    public void removeStudent(Student stu) {
        list.remove(stu);
    }

    @Override
    public StudentIterator getStudentIterator() {
        return new StudentIteratorImpl(list);
    }
}

```

最后我们可以在测试类中写入我们的代码如下，首先我们创建聚合对象，接着往其下添加四个学生对象，然后获取迭代器对象再通过while循环遍历即可

```
public class Client {
    public static void main(String[] args) {
        //创建聚合对象
        StudentAggregateImpl aggregate = new StudentAggregateImpl();
        //添加元素
        aggregate.addStudent(new Student("张三","001"));
        aggregate.addStudent(new Student("李四","002"));
        aggregate.addStudent(new Student("王五","003"));
        aggregate.addStudent(new Student("赵六","004"));

        //遍历聚合对象

        //1.获取迭代器对象
        StudentIterator iterator = aggregate.getStudentIterator();

        //2.遍历
        while (iterator.hasNext()){
            //3.获取元素
            Student next = iterator.next();
            System.out.println(next.toString());
        }
    }
}
```

最后我们来看看其优缺点是使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa5f309114e444268dbf869d6c04ef918.png)

- JDK源码解析

这个没啥值得说的，以前都学过了都，直接看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9b6e5b45f0f0386899d5f79cc246ada0.png)

