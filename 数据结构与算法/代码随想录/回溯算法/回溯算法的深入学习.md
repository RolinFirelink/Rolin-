最后一章就是深入环节了，这一章学完，起码我们的回溯入门是搞定了，以后就不用担心回溯类题目了，起码基本的回溯类题目到时候都会有个思路是吧

- 全排列

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc66d6d2e571574115d4e3aab2fd99c05.png)

对于这一题，我们可以利用一个布尔类型的数组来辅助解题，同样是利用回溯，我们这里是要求求出其全排列，因此我们需要利用数组来帮助判断元素是否已经选取，若已经选取到我们的集合中，那么我们就跳过，若没有则选取，集合到了指定大小就收集并结束递归，这样就可以获得我们所需要的全排列了

注意这里由于我们需要的是全排列，所以我们的for循环总是从0开始的，而不是跟之前一样是传入一个参数并从那个参数为起点开始的，而我们的布尔类型数组就是为了防止重复选取相同元素而整出来的东西

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> list = new ArrayList<>();
        dfs(nums, list,new boolean[nums.length]);
        return this.list;
    }

    private void dfs(int[] nums, List<Integer> list,boolean[] booleans) {
        if(list.size()== nums.length){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(booleans[i]){
                continue;
            }
            list.add(nums[i]);
            booleans[i]=true;
            dfs(nums, list,booleans);
            booleans[i]=false;
            list.remove(list.size()-1);
        }
    }
}
```

该代码执行的过程如下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeed427928510d494a85c5044ae52bd18.png)

- 全排列II

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe1026b9db3e685d894f29d710e1533af.png)

然后我们来学习进阶的题目，本题的数字是可能重复的，然而我们要收集所有不重复的全排列，那么我们要如何进行去重呢？无脑的方法当然是使用Set集合，但这样的话就直接进入人才库回家玩去了，所以我们断然不能使用这种投机取巧的方法。

其实我们这里的去重逻辑就跟之前的一样简单，我们只要避免我们递归例程选取我们已经选取过的值相同的元素就可以了，同时由于我们这里是求其全排列，因此我们还需要布尔类型的数组来帮助我们进行去重，防止我们选择我们之前的路径中已经选择过的元素

其执行过程如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE01875f639021c09c5271bf513934175a.png)

最终我们可以构造代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    boolean[] booleans;
    public List<List<Integer>> permuteUnique(int[] nums) {
        booleans = new boolean[nums.length];
        Arrays.sort(nums);
        dfs(nums,new ArrayList<>());
        return list;
    }

    private void dfs(int[] nums,List<Integer> list) {
        if(list.size()== nums.length){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(i>0 && nums[i]==nums[i-1] && !booleans[i-1]){
                continue;
            }
            if(!booleans[i]){
                booleans[i]=true;
                list.add(nums[i]);
                dfs(nums,list);
                booleans[i]=false;
                list.remove(list.size()-1);
            }
        }
    }
}
```

这里我们有几点要记住，第一点，我们的同层去重法必须要排序之后才能够正确使用。第二点，使用布尔类型数组避免重复选择相同元素必须是一个回溯的过程。第三点，在求全排列的情况下，无法用之前的坐标法来代替布尔类型数组的作用达到去重作用，因为我们这里的坐标总是从0开始的

- 回溯去重问题的另一种写法

接着我们就必须来理一下我们所学习的两个在同一层上进行去重的方法了，我们目前一共学习了两种方法能够帮助我们进行树层上的去重，第一种是通过布尔类型数组，其有第二种局限性的形式，就是利用坐标进行去重。这种形式好用，但是其特点是一定要进行对原数组进行排序，如果原数组是不可以排序的，那么该方法就会直接失效。第二种去重的方法是使用哈希表来帮助我们去重，使用哈希表进行去重，我们需要在每一层上都创建一个哈希表并用于该层的判断，比较浪费内存，效率也不是很高说实话，所以一般来说，我们都是推荐使用前一种方式来进行树层上的去重

一般来说，我们能用第一种方式进行树层去重的题目，我们也可以用第二种方式来达成，但是在不可排序的情况下，是第一种情况所无法复现的，目前后一种去重法的含金量只体现在递增子序列这一题中，其他题目上完全都可以不用。另外如果我们在递归例程中使用了布尔数组，那么一般我们也是偏向使用第一种方式的，因为正好能一起用了是吧

简单来说，能用布尔类型进行树层去重，就不要用哈希表

- 重新安排行程

接着我们来看一道重量级的题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2812b91721317802e004bf04c2a13edc.png)

这位更是重量级，要做这种重量级的题目，我们一定要深刻记住我们之前学习的知识，综合我们的知识来解题，

```
class Solution {
    List<List<String>> list = new ArrayList<>();
    boolean[] booleans;
    public List<String> findItinerary(List<List<String>> tickets) {
        booleans = new boolean[tickets.size()];
        dfs(tickets,"JFK",0,0,new ArrayList<>());
        return findMin(list);
    }

    private void dfs(List<List<String>> tickets,String s,int index,int deep,List<String> list) {
        if(deep==tickets.size()){
            list.add(tickets.get(index).get(1));
            this.list.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return;
        }
        for (int i = 0; i < tickets.size(); i++) {
            if(booleans[i]){
                continue;
            }
            List<String> stringList = tickets.get(i);
            if(stringList.get(0).equals(s)){
                booleans[i]=true;
                list.add(stringList.get(0));
                dfs(tickets,stringList.get(1),i,deep+1,list);
                list.remove(list.size()-1);
                booleans[i]=false;
            }
        }
    }

    public List<String> findMin(List<List<String>> list) {
        int min = 0;
        for (int i = 1; i < list.size(); i++) {
            List<String> stringList1 = list.get(min);
            List<String> stringList2 = list.get(i);

            boolean judge = false;
            for (int j = 0; j < stringList1.size(); j++) {
                String s1 = stringList1.get(j);
                String s2 = stringList2.get(j);
                if(s1.equals(s2)){
                    continue;
                }
                if(s1.compareTo(s2)>0){
                    judge=true;
                }
                break;
            }
            if(judge){
                min=i;
            }
        }
        return list.get(min);
    }
}
```

我们这个逻辑也是很简单，就是直接递归暴力搜索所有可能的结果，然后返回的结果里再进行排序，最后得到的结果就是我们所需要的结果，中间利用布尔类型的数组防止重复搜索，这个想法确实很不错，实际上也的确有用，但是，这题毕竟是个重量级题目，肯定是不可能这么简单的，由于我们的数组的长度能达到惊人的300，因此这题其实用这么低效的搜索方式根本搜索不到，最终会超时，所以这份算法是行不通的，我们必须要更换我们的方法，我们必须要使用效率更高的回溯法，否则这题就无解

我们来逐步解决下这一题的难点，先来看看本题一共有几个难点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE10c9fbc0d23b571986db0892aacba408.png)

首先我们第一个要避免的问题就是死循环的问题，这个很容易理解，我们之前的代码是使用布尔类型的数组来避免我们进入死循环，但是说实话这种方式的效率有点低，实际上，我们大可以使用次数这种特殊的值来防止其继续递归，我们构造一个从某个机场到另一个机场的情况，然后每种情况下我们都构造一个数量值，相同则加，不同则新增可到达的路径，最后只要我们判断该路径的到达次数是否还大于0即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb76ef9fb6cd7d2dec81c55fe2b5857c3.png)

接着我们来解决第二个问题，那就是我们要如何记录我们的映射关系，同时我们能准确返回字母序排在前面的路径，我们之前采用的方式是记录所有的可能路径，然后找到字典序最小的路径并返回，这个操作由于还多了一个排除的过程，因此效率上属实是不尽人意。那么我们要怎么解决这个问题呢？我们可以先将我们的所有情况存在一个集合中，这个集合的路径本身就是有序的，这样我们首先获取到的第一个有效的路径一定是我们题目中所需要的字典序最小的路径。问题在于，我们要选取什么集合好？其实，我们这里可以选取两种集合，第一个中是Map<Stirng,List<String>>和Map<String,Map<String,Integer>>这两种集合，前者的存储格式是Map<出发机场, 到达机场的集合>，后者的存储格式是Map<出发机场, Map<到达机场, 航班次数>>，我们选择后者，因为后者才能存放数字，才有我们的前面说的防止重复选择的应用。也就是说，我们每次进行递归前，都应该先将我们的集合中的内容存放到我们的所构造的新的集合中

那么我们要如何插入我们的集合呢？我们可以对我们的地址集合进行迭代，每次我们判断我们当前的Map结合是否存在这个起始地址，若不存在，我们就创建一个TreeMap的集合，然后往其中存入到达路径和1的次数，反之则取出该集合，然后存入该Map集合的到达路径并用getOrDeafult方法来进行可到达区域的累加，最后我们每次迭代都将Map集合和起始地点存储到我们的总的大的Map集合中，最后我们就可以得到我们所需要的集合对象了

然后是第三个问题，我们的终止条件是什么？这个其实很简单，因为我们已经假定我们的能够搜集到的第一个完整路径就是目标路径了，所以我们的递归结束条件就是我们的路径中的值与我们的最开始传入的数组大小还大于1的时候，其实分析题目也容易知道我们的结果路径中总是有最后一个路径的，这就导致我们的路径大小总是稳定大于我们的数组长度的一位

最后一个问题，我们要如何遍历一个机场对应的所有机场？我们当然是使用for循环了，由于路径中的第一位总是"JFK"，且本题保证有答案，所以我们每次递归的时候可以先取出路径中的最后一位，然后判断Map集合中是否存在该路径，若存在，我们就取出其Map对应的Value值，对其进行递归查找，当然，每次递归时我们都要检查其次数是否大于0，大于0我们才进行递归，否则我们不进行递归，同时递归完毕之后我们需要进行回溯。这里有一点不同的是，由于我们的集合总是拿到了适合路径之后就可以停止了，所以我们每次递归都判断拿到的路径是否达到了长度，若达到则直接返回即可

我们可以来看看其递归的搜索过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE77eeda711a5971ee34bfd849ca11e3ec.png)

最后我们容易构造其代码如下

```
class Solution {
    //存储路径的集合，其存储格式为Map<出发机场, Map<到达机场, 航班次数>>
    Map<String,Map<String,Integer>> map = new HashMap<>();
    //存储路径的集合
    List<String> list = new ArrayList<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        add(tickets);
        //先添加第一位起始路径
        list.add("JFK");
        dfs(tickets);
        return list;
    }

    //递归搜索路径的方法
    private void dfs(List<List<String>> tickets) {
        //如果路径集合的大于数组一位，说明已经收集到合适集合
        if(list.size()==tickets.size()+1){
            return;
        }
        //取出路径中的最后一位的路径
        String s = list.get(list.size()-1);
        //如果大集合中存在该起始路径，我们再进行对应的迭代搜索
        if(map.containsKey(s)){
            //取出大集合中对应的小集合，并进行迭代，entrySet可以理解为每一个小的map组件
            for (Map.Entry<String,Integer> entry:map.get(s).entrySet()) {
                //取出其对应的次数
                int val = entry.getValue();
                //若次数大于0则进行递归
                if(val > 0){
                    //添加路径
                    list.add(entry.getKey());
                    //指定次数-1
                    entry.setValue(val-1);
                    dfs(tickets);
                    //判断是否符合条件，若符合则直接退出递归
                    if(list.size()==tickets.size()+1){
                        return;
                    }
                    //回溯移除路径
                    list.remove(list.size()-1);
                    //回溯重置次数
                    entry.setValue(val);
                }
            }
        }
    }

    //将地址存储到集合中
    private void add(List<List<String>> tickets) {
        //对集合进行遍历
        for (List<String> list:tickets) {
            //先定义小Map集合
            Map<String,Integer> map;
            //判断起始地址是否存在于大Map集合中
            if(this.map.containsKey(list.get(0))){
                //取出大Map集合中的小Map集合
                map = this.map.get(list.get(0));
                //利用getOrDefault方法往小Map集合中实现数字的累加
                map.put(list.get(1), map.getOrDefault(list.get(1),0)+1);
            }else {
                //创建新的Map集合
                map = new TreeMap<>();
                //往Map集合中存入到达位置及能到达的次数，默认为1
                map.put(list.get(1),1);
            }
            //将小集合的情况存储到大集合中
            this.map.put(list.get(0),map);
        }
    }
}
```

但是我们上面的代码我们可以看到，我们似乎是重复进行了两次的判断，这样似乎不太美观，而且显得有些臃肿，我们有办法对我们的代码进行进一步的优化吗？当然可以。我们只要对我们的将我们的返回值改为布尔类型即可，终止条件改为如果路径长度大于集合的一位，那么就返回true，每次递归时判断返回的是否为真，若为真则再次返回真来结束递归，其他情况返回false，通过布尔类型我们可以达到我们所需要的搜索到第一个适合长度路径就立刻返回的效果，我们可以记住这种递归方式，这种递归方式可以让我们总是在收集到第一个适合条件的路径之后就立刻返回，而且代码上也更加美观

```
class Solution {
    //存储路径的集合，其存储格式为Map<出发机场, Map<到达机场, 航班次数>>
    Map<String,Map<String,Integer>> map = new HashMap<>();
    //存储路径的集合
    List<String> list = new ArrayList<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        add(tickets);
        //先添加第一位起始路径
        list.add("JFK");
        dfs(tickets);
        return list;
    }

    //递归搜索路径的方法
    private boolean dfs(List<List<String>> tickets) {
        //如果路径集合的大于数组一位，说明已经收集到合适集合
        if(list.size()==tickets.size()+1){
            return true;
        }
        //取出路径中的最后一位的路径
        String s = list.get(list.size()-1);
        //如果大集合中存在该起始路径，我们再进行对应的迭代搜索
        if(map.containsKey(s)){
            //取出大集合中对应的小集合，并进行迭代，entrySet可以理解为每一个小的map组件
            for (Map.Entry<String,Integer> entry:map.get(s).entrySet()) {
                //取出其对应的次数
                int val = entry.getValue();
                //若次数大于0则进行递归
                if(val > 0){
                    //添加路径
                    list.add(entry.getKey());
                    //指定次数-1
                    entry.setValue(val-1);
                    if(dfs(tickets)){
                        return true;
                    }
                    //回溯移除路径
                    list.remove(list.size()-1);
                    //回溯重置次数
                    entry.setValue(val);
                }
            }
        }
        return false;
    }

    //将地址存储到集合中
    private void add(List<List<String>> tickets) {
        //对集合进行遍历
        for (List<String> list:tickets) {
            //先定义小Map集合
            Map<String,Integer> map;
            //判断起始地址是否存在于大Map集合中
            if(this.map.containsKey(list.get(0))){
                //取出大Map集合中的小Map集合
                map = this.map.get(list.get(0));
                //利用getOrDefault方法往小Map集合中实现数字的累加
                map.put(list.get(1), map.getOrDefault(list.get(1),0)+1);
            }else {
                //创建新的Map集合
                map = new TreeMap<>();
                //往Map集合中存入到达位置及能到达的次数，默认为1
                map.put(list.get(1),1);
            }
            //将小集合的情况存储到大集合中
            this.map.put(list.get(0),map);
        }
    }
}
```

- N皇后

接着我们来学习一些经典的重量级题目，首先是我们早有耳闻的N皇后，这个题目也是老经典了啊

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf236706821dbdb9dd40ed7f7e20e27ee.png)

这一次我们很厉害的，把N皇后的题目一次就给做出来了，没有一次WA，这我是那个自豪啊，这么久的努力总算是没有白费，我们先来看看我们的代码

```
class Solution {
    boolean[] booleans;
    List<List<String>> list = new ArrayList<>();
    List<int[][]> ansList = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        int[][] ans = new int[n][n];
        booleans = new boolean[n];
        dfs(ans,0);
        for (int[][] arr:ansList) {
            List<String> list = new ArrayList<>();
            for (int i = 0; i < arr.length; i++) {
                StringBuffer sb = new StringBuffer();
                for (int j = 0; j < arr[i].length; j++) {
                    if(arr[i][j]==0){
                        sb.append('.');
                    }else {
                        sb.append('Q');
                    }
                }
                list.add(sb.toString());
            }
            this.list.add(list);
        }

        return list;
    }

    private void dfs(int[][] arr,int deep) {
        if(deep==arr.length){
            int[][] ans = new int[arr.length][arr.length];
            for (int i = 0; i < arr.length; i++) {
                System.arraycopy(arr[i], 0, ans[i], 0, arr.length);
            }
            ansList.add(ans);
        }
        for (int i = 0; i < arr.length; i++) {
            if(booleans[i]){
                continue;
            }
            if(judge(arr,deep,i)){
                arr[deep][i]=1;
                booleans[i]=true;
                dfs(arr,deep+1);
                booleans[i]=false;
                arr[deep][i]=0;
            }
        }
    }

    private boolean judge(int[][] arr, int deep, int j) {
        //左上角
        int x = deep,y = j;
        while (x>0 && y>0){
            x--;
            y--;
            if(arr[x][y]==1){
                return false;
            }
        }

        //左下角
        x = deep;y = j;
        while (x<arr.length-1 && y>0){
            x++;
            y--;
            if(arr[x][y]==1){
                return false;
            }
        }

        //右上角
        x = deep;y = j;
        while (x>0 && y<arr.length-1){
            x--;
            y++;
            if(arr[x][y]==1){
                return false;
            }
        }

        //右下角
        x = deep;y = j;
        while (x<arr.length-1 && y<arr.length-1){
            x++;
            y++;
            if(arr[x][y]==1){
                return false;
            }
        }

        return true;
    }
}
```

然后我们来讲解下我们的代码逻辑，首先我们的基本想法是，每次递归我们就确定一个位置放皇后，每次放置时我们必须进行皇后是否可以放置于该位置的正确性判断，若可以则放然后进入下一层的递归，若不行我们就跳出该选择下一个位置来放置皇后。

我们递归的结束条件是当我们的深度到达我们的矩阵底部的时候，到达则说明我们已经成功选取到了符合条件的皇后组合，此时我们就将符合条件的组合收集起来，递归结束之后我们将对应的集合一个个取出改造成题目要求的形式并返回即可

同时我们这里使用布尔类型的数组来辅助我们递归，放置我们选择同一列的位置放置皇后

然后来具体看一下我们的递归的执行过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaba8fee81252349ffa433504233919fe.png)

官方的解题思路和我们几乎是如出一辙，不同的是官方的解题将判断对角线的情况仅分为两种情况进行判断，而且其是每次到达符合条件的结束位置就收集该路径到目标集合中，这个其实大差不差，不是很有所谓说实话

```
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTrack(n, 0, chessboard);
        return res;
    }


    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }

        for (int col = 0;col < n; ++col) {
            if (isValid (row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }

    }


    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }


    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        for (int i=0; i<row; ++i) { // 相当于剪枝
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查45度对角线
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查135度对角线
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

- 解数独

最后我们再来讲一道经典的重量级题目，解数独，这题还真的就是重量级了，还贴近生活，先来看看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2ff97fc3a357bc2a0378567572f59e8e.png)

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfc5a9b475cd3038b22e2d668c834854f.png)

解开这题的思路其实非常简单粗暴，就是进行二维上的迭代递归，利用两个for循环递归判断数独的各种情况，若如何则继续，不符合就排除。与前面的题目不同的是，我们之前判断的时候，是用deep这样的参数来作为纵向的坐标来帮助我们完成递归，当时我们使用deep来协助完成递归的原因在于我们需要这个参数来进行停止递归的判断

而我们这里，我们要做的事情是，我们要递归判断所有的不含有数字的位置，并且遍历其所有的可能情况，每次递归前我们都要判断我们的当前位置的放置数字是否适合，若适合则递归，反之则跳过，这个和我们的N皇后的思路其实很像

接着我们要解决的问题是，我们的递归结束的条件是什么？其实，我们这里并不需要对我们的递归构造任何的结束条件，我们这里递归例程做的事情就是将我们对应位置的数值改为适合的数值，改完之后自动结束即可，由于是原地修改，我们等待其自动结束即可，不需要构造递归结束条件并收集

最后我们来简单看看其递归的过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE550d84a73be67a2a3e3964dd04229d2a.png)

然后我们可以构造代码如下

```
class Solution {
    char[] chars = new char[]{'1','2','3','4','5','6','7','8','9'};
    public void solveSudoku(char[][] board) {
        dfs(board);
    }

    private boolean dfs(char[][] board) {
        for (int i = 0; i < chars.length; i++) {
            for (int j = 0; j < chars.length; j++) {
                if(board[i][j]=='.'){
                    for (int k = 0; k < chars.length; k++) {
                        if(judge(board,chars[k],i,j)){
                            board[i][j]=chars[k];
                            if(dfs(board)){
                                return true;
                            }
                            board[i][j]='.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    private boolean judge(char[][] board, char c, int x, int y) {
        //查找横
        for (int i = 0; i < chars.length; i++) {
            if(board[x][i]==c){
                return false;
            }
        }

        //查找纵
        for (int i = 0; i < chars.length; i++) {
            if(board[i][y]==c){
                return false;
            }
        }

        //查找九宫格
        int hengs,henge,zongs,zonge;
        int m = x / 3, n = y/3;
        hengs = m*3;zongs = n*3;
        henge = hengs+3;zonge = zongs+3;
        for (int i = hengs; i < henge; i++) {
            for (int j = zongs; j < zonge; j++) {
                if(board[i][j]==c){
                    return false;
                }
            }
        }

        return true;
    }
}
```

这里的这份代码最值得讲是我们的递归例程，首先我们的递归例程都是从i=0和j=0中开始的，我们每次递归都要从第一个起点开始来时进行暴力搜索，当然，由于我们的搜索并修改的特点，我们之前修改过的位置的值会被跳过

如果我们这里使用x和y的两个参数来执行我们的递归的话，最终我们会只能修改一部分的数独的值，后续的值会由于我们的边界问题导致无法被修改，因此我们这里每次递归我们都需要让我们的递归例程从0开始

最后是我们这里令其返回布尔类型的值，这招可以让我们收集到第一个符合条件的值就立刻停止递归，但是要注意的是，我们之前确实也用过这招，虽然说套路是这个套路，但模板并不是死的，我们这里不用简单的依葫芦画瓢单纯把前面的代码构造样式给拷贝过来，我们需要进行分析并构造一个适合的例程才能让我们的布尔返回值发挥作用，达到收集到第一个合适例程就结束递归的效果

我们这里分析我们的递归例程，我们每次递归都要判断该递归是否成功，若成功我们则返回真，每次我们递归时会执行一个for循环，如果我们的例程成功了，那么我们就找到了合适的值，此时后续的代码就不会执行，但是如果我们的代码最终执行到了选择数字1-9的后面，说明1-9都没有一个合适的值给他用，此时我们返回false，说明该例程不适合，最后我们的代码最终执行完，此时说明我们的递归例程已经完成，且没有出错，那么此时我们就要返回true。注意，我们这里一定要返回true，因为我们的递归例程中的结果同时也是我们的例程执行的条件，如果我们返回的是false，那么我们的代码就永远不会进入到最终的结束代码中，那就寄了，所以我们这里一定要返回true