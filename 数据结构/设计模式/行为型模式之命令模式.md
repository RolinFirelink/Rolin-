现在我们来学习命令模式，先来看看下面的案例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8c7ac5ce3ee66f334c7673e62f67d827.png)

在我们这里有服务员、订单、厨师对象，服务员要将订单提供给厨师，一般我们会让服务员类聚合厨师类，这样服务员就可以往对应的厨师提供订单，但是我们的厨师是有可能会更换的，如果我们更换厨师，就要修改服务员的源代码，不符合开闭原则

此时我们就可以使用命令模式，将一个请求封装为一个对象，服务员通过该对象来联系厨师，这样就实现了解耦合

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE119ea492809ff3979db77832ca344660.png)

接着我们来看看命令模式里具有的结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7e10ecfb8b8ca08d79627e8aba9e9967.png)

接着我们将上面的案例用代码实现，在上面的案例中，如果用命令模式实现，那么服务员就是调用者角色、厨师就是接收者角色，而订单则是命令类角色，来看看其类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9276f575feeeaced0df4cb4e72b9f43d.png)

首先我们创建订单类，要发送请求当然需要一个订单类，我们这里提供餐桌号码的属性，所用户所辖的餐品和份数则使用Map集合来存储，我们最后提供一个设置食物的方法，这个方法就类似于往订单中写入顾客要的数据，要求提供事物名字和数量，然后我们将其设置到Map集合中

```
public class Order {
    //餐桌号码
    private int diningTable;

    //所下的餐品及份数
    private Map<String,Integer> foodDir = new HashMap<>();

    public int getDiningTable() {
        return diningTable;
    }

    public void setDiningTable(int diningTable) {
        this.diningTable = diningTable;
    }

    public Map<String, Integer> getFoodDir() {
        return foodDir;
    }

    public void setFood(String name,int num) {
        foodDir.put(name,num);
    }
}
```

然后我们当然要创建厨师对象，厨师对象只有一个执行做菜的方法，需要传入对应的名字和份数

```
public class SeniorChef {
    public void makeFood(String name,int num) {
        System.out.println(num + "份" + name);
    }
}
```

接着我们设置抽象命令类，只是一个接口

```
//抽象命令类
public interface Command {
    void execute();
}
```

接着我们写入具体命令类，具体命令类中要实现我们的抽象命令类，然后其下应该要持有接收者对象，也就是厨师对象，以及被接受的对象，也就是订单类，其是请求的根本，提供对有的构造方法，然后重写发送请求的方法

这里我们发送请求的方法就是遍历订单中的Map集合，拿到所有的内容之后调用厨师的做菜方法做菜就完了

```
//具体命令类
public class OrderCommand implements Command{

    //持有接收者对象
    private SeniorChef receiver;
    private Order order;

    public OrderCommand(SeniorChef receiver, Order order) {
        this.receiver = receiver;
        this.order = order;
    }

    @Override
    public void execute() {
        System.out.println(order.getDiningTable()+"桌的订单：");
        Map<String, Integer> foodDir = order.getFoodDir();
        //遍历map集合
        Set<String> set = foodDir.keySet();
        for (String foodName : set) {
            receiver.makeFood(foodName,foodDir.get(foodName));
        }
        System.out.println(order.getDiningTable()+"桌的饭菜准备完毕");
    }
}
```

最后我们要定义请求者对象，也就是服务员，服务员可以拥有多个订单，所以拥有List属性，提供设置新订单的方法，这是当然，服务员当然要可以接受订单，然后提供发起命令的方法，如果命令没有问题，就调用请求对象中的发送请求方法，其会调动厨师的做菜方法来做订单中对应的菜

```
public class Waiter {

    //持有多个命令对象
    private List<Command> commands = new ArrayList<>();

    public void setCommand(Command cmd){
        //将cmd对象存储到list集合中
        commands.add(cmd);
    }

    //发起命令的功能
    public void orderUp() {
        System.out.println("服务员对厨师说订单来了");
        for (Command command : commands) {
            if(command!=null){
                command.execute();
            }
        }
    }
}
```

最后我们在测试类中写入代码如下，我们这里首先设置两个订单对象，然后创建一个厨师对象和两个命令对象，命令对象需要厨师对象和订单对象，我们这里相当于是让两个命令对象将厨师和对应的命令绑定起来，然后将这两个命令对象设置到服务员对象中，接着让服务员发起命令，即可让服务员发起所有的命令请求，令其正确执行

```
public class Client {
    public static void main(String[] args) {
        //创建第一个订单对象
        Order order = new Order();
        order.setDiningTable(1);
        order.setFood("西红柿鸡蛋面",1);
        order.setFood("小杯可乐",2);

        //创建第二个订单对象
        Order order2 = new Order();
        order2.setDiningTable(2);
        order2.setFood("尖椒肉丝盖饭",1);
        order2.setFood("小杯雪碧",2);

        //创建厨师对象
        SeniorChef receiver = new SeniorChef();
        //创建命令对象
        OrderCommand cmd1 = new OrderCommand(receiver,order);
        OrderCommand cmd2 = new OrderCommand(receiver,order2);

        //创建调用者（服务员对象）
        Waiter waiter = new Waiter();
        waiter.setCommand(cmd1);
        waiter.setCommand(cmd2);

        //让服务员发起命令
        waiter.orderUp();
    }
}
```

最后我们来看看命令模式的优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3939eacc337e307df25c94d18d78164f.png)

- JDK源码解析

JDK中的Runable就是一个典型的命令模式，Thread是调用者，而start则是我们要执行的请求命令，接收者是有我们程序员自己定义的一个全新的类

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb2b113b60c8acdf726403ddb2134e46.png)

