那么学习完了入门案例之后，接着我们来学习我们对springmvc的的配置。

- 常规配置（Controller加载控制，静态资源加载控制，中文乱码处理）

首先我们要学习的是对我们的Controller的加载控制，我们如果要SpringMVC的处理器值按照规范的格式开发，我们就要避免加入无效的bean，这一点我们可以用过bean的加载过滤器来进行对应的包含设定或者是排除设定，因为我们表现层的bean标注通常设定为Contrller注解，因此我们可以通过包含注解来进行排除，我们这里进行排除代码设置的位置是在我们的核心配置文件spring-mvc.xml中，我们其实还有注解方式可以用于设置排除，但我们这里先演示使用配置文件来设置的方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf937bae08248cc4d315737f8b78001a3.png)

我们可以写入排除的代码如下，直接在对应的扫描加载的控制类的代码下写其对应的子标签就行了，我们这里使用包含性过滤，因为用排除过滤的话要设置太多东西了

```
<!--扫描加载所有的控制类类-->
<context:component-scan base-package="com.itheima">
    <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>
```

最后我们来看看其设置的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa626b4dd5970a3d4e1083102acaca711.png)

然后我们接着要解决的是关于静态资源的加载问题，由于我们最开始设置的拦截是将所有请求都拦截，这样的话我们如果想要加载图片都不行，因为也会被拦截，因此我们可以设置对应的放行代码，将我们的图片资源一类的静态资源进行放行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe4fd9b0fb4a68e68f47c96fd071182a1.png)

那么按照这个思路，我们可以写入其放行代码如下

```
<mvc:resources mapping="/img/**" location="/img/"/>
<mvc:resources mapping="/js/**" location="/img/"/>
<mvc:resources mapping="/css/**" location="/img/"/>
```

但实际上我们还有更加简单的方法就可以对我们所有的静态资源进行放行，只需要写入下面这一行代码到核心配置文件中

```
<mvc:default-servlet-handler/>
```

这个了解下就行了，以后我们肯定都是直接写上这一行代码就完了的。当然，不要忘了我们这里也需要加入对应的命名空间。所以最后我们放出整个配置的所有代码

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--扫描加载所有的控制类类-->
    <context:component-scan base-package="com.itheima">
        <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>

<!--    <mvc:resources mapping="/img/**" location="/img/"/>
    <mvc:resources mapping="/js/**" location="/img/"/>
    <mvc:resources mapping="/css/**" location="/img/"/>-->

    <mvc:default-servlet-handler/>

</beans>
```

最后我们要解决中文的乱码问题，这个没啥特别值得说的，我们只需要配置一次就一劳永逸了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb5a5b5c82360311495f8e64f470c365.png)

那么我们可以写入我们的中文过滤的代码如下

```
<filter>
  <filter-name>CharacterEncodingFilter</filter-name>
  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
  <init-param>
    <param-name>encoding</param-name>
    <param-value>UTF-8</param-value>
  </init-param>
</filter>
<filter-mapping>
  <filter-name>CharacterEncodingFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

- 注解驱动

那么接着我们就来做我们的注解驱动，简单来说就是使用纯注解形式来做我们的案例。这个我们了解下就可以了，因为我们实际开发的时候都是使用注解结合配置文件的方式的，很少使用纯注解来进行开发

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa738cceb49d6b0f99ecc0b057af3f443.png)

首先我们创建一个核心配置类，该配置下我们写入其头文件注解Configuration，然后我们写入其扫描路径注解ComponentScan，接着写入对应的过滤设置

```
package com.itheima.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;
import org.springframework.stereotype.Controller;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@ComponentScan(value = "com.itheima",includeFilters =
        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})
    )
public class SpringMVCConfiguration implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry){
        registry.addResourceHandler("/img/**").addResourceLocations("/img/");
        registry.addResourceHandler("/js/**").addResourceLocations("/js/");
        registry.addResourceHandler("/css/**").addResourceLocations("/css/");
    }

    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}

```

接着我们要实现对应的放开代码，这里我们要实现这个目的就要令其实现WebMvcConfigurer接口，其下的方法都可以不用去实现，但是我们如果要放开某些情况，我们就要通过重写其方法来达成目的。我们可以重写addResourceHandlers来进行独立的开放设置，也可以重写configureDefaultServletHandling进行将所有的静态资源都开放的设置，这两个保留其中一个就可以了

我们设置好这个就相当于是将spring-mvc.xml给取代了，接着我们要将web.xml给取代，那么我们可以新创建一个配置类，令其继承AbstractDispatcherServletInitializer类，该类就是对应我们的配置文件的实现类，我们写入其代码如下

```
package com.itheima.config;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;

import javax.servlet.DispatcherType;
import javax.servlet.FilterRegistration;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import java.util.EnumSet;

public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {

    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMVCConfiguration.class);
        return ctx;
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }

    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        super.onStartup(servletContext);

        CharacterEncodingFilter cef = new CharacterEncodingFilter();
        cef.setEncoding("UTF-8");

        FilterRegistration.Dynamic registration = servletContext.addFilter("characterEncodingFilter", cef);

        registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST,DispatcherType.FORWARD,DispatcherType.INCLUDE),false,"/*");
    }
}

```

第一个重写的方法就相当于是之前我们在servlet标签中配置我们的核心控制器类，然后中间引入了我们的另一个在注解配置文件并将其加载，然后返回加载好的对象到springmvc的容器中。

而第二个重写的方法就是指定我们要拦截的方法，由于我们要拦截所有方法，所以我们直接返回/就完了。

最后一个重写的方法是用于规定我们的对应的字符集的，用于解决中文乱码的，这个记住就挖了，以后都是一样的内容的

最后我们经过测试会发现其会报编码UTF-8的不可映射字符的警告，这个警告具体体现在我们的yongshiwuaijumupobai图片根本加载不出来，一下子找不到解决方法，反正后续也不一定还会用，这里就先放着吧