接着我们来实现用户添加的操作，我们可以看到在我们的图书管理系统里有添加用户的操作，每次添加用户都只是存放到了 内存上而不是硬盘，因此这里我们要做的是对用户添加操作进行一个持久化，简而言之就是将用户添加在内存中的数据读取到，然后写入到硬盘中

为了实现这个需求，首先我们要研究下关于添加本身的一些情况

首先我们点击添加可以看到这样一个界面

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE72e189243a0302b0413d83b8527109bf.png)

可以看到我们的添加只循序添加姓名和余额，但是我们实际上用户属性是还有状态和编号的，先来说状态，那为什么这里不用添加指定状态呢？因为我们一般创建的用户其默认状态都是正常的，因此我们这里默认其是正常的，而且状态这种东西让用户来添加也会降低用户体验，因此我们默认新创建的用户为正常的

接着再来说编号，编号的作用主要是为了区分不同的用户，因为用户可能余额状态，甚至连姓名都一样，因此我们还需要编号来区分不同的用户，便于我们执行修改动作，当然，我们的编号要具有唯一性，一个简单的想法就是直接将当前最大编号+1就完了，也不用考虑溢出问题，因为

不可能有这么多人用你的东西的

我们先找到对应的窗口，看看其源码分布情况，首先我们进入module包的子包user包下然后进入UserView.fxml，进入用户管理对应的界面文件，可以看到下面的代码

```javascript
<Button mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0"
        onMouseClicked="#userAddView" styleClass="btn-primary" text="添加"/>
```

可以看到对应的添加代码，这个添加意味着这行代码就是添加相关的代码，然后我们可以看到鼠标点击的代码onMouseClicked="#userAddView" ，意味着只要鼠标点击添加就会执行#userAddView" 内的代码，我们点进去看看其内部的代码情况

```javascript
/*
    添加
 */
@FXML
private void userAddView() {
    try {
        initStage(null);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

界面内的代码与内部实际代码关联的方式很简单，就是增添注解就完了，可以看到添加方法里调用了initStage()这个方法，我们点进去看看

```javascript
/*
    初始化stage
 */
private void initStage(User user) throws IOException {
    FXMLLoader loader = new FXMLLoader();
    loader.setLocation(App.class.getResource("/com/bjpowernode/module/user/UserHandleView.fxml"));
    StackPane target = (StackPane) loader.load();
    //Scene scene1 = App.getDecorator().getScene();
    Scene scene = new Scene(target);
```

可以看到这个方法里加载了UserHandleView.fxml界面文件，这个界面文件，其实就对应我们添加的窗口，我们可以点进这个界面文件中看看

```javascript
<children>
    <Label GridPane.columnIndex="0" GridPane.rowIndex="8" prefHeight="30.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" />
    <TextField fx:id="userIdField" GridPane.columnIndex="1" GridPane.rowIndex="9"  visible="false" layoutX="739.0" layoutY="18.0" prefHeight="30.0" prefWidth="151.0" styleClass="rectangle" />
    <Label GridPane.columnIndex="0" GridPane.rowIndex="0" prefHeight="30.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" text="姓名:" />
    <TextField fx:id="userNameField"  GridPane.columnIndex="1" GridPane.rowIndex="0" layoutX="739.0" layoutY="18.0" prefHeight="30.0" prefWidth="151.0" promptText="姓名" styleClass="rectangle" />
    <Label GridPane.columnIndex="0" GridPane.rowIndex="1" prefHeight="30.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" text="余额:" />
    <TextField fx:id="moneyField" GridPane.columnIndex="1" GridPane.rowIndex="1" prefHeight="30.0" prefWidth="151.0" promptText="余额" styleClass="rectangle" />
</children>
```

可以看到这里就三个属性，这三个属性都是TextField，这三个属性分别是姓名余额和编号，编号的visible属性里是false，该属性赋为false意为在窗口中不可见，换言之，其实我们的添加窗口是有这个界面的，但是因为我们设置了false，所以不可见，于是看起来就像是没有这个窗口，但其实它是有的，只是不可见，也无法操作

接着我们来看看界面里关于提交的代码

```javascript
<Button mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0" onMouseClicked="#addOrEditUser" styleClass="btn-primary" text="提交" />
```

可以看到这个提交的代码里有这样一个属性onMouseClicked="#addOrEditUser"，说明点击提交会执行"#addOrEditUser"这个方法，我们点进去这个方法里面看看

```javascript
/*
    添加或修改数据
 */
@FXML
private void addOrEditUser() {
    try {
        String id = userIdField.getText();
        if ("".equals(id) || null == id) {
            //添加操作
            User user = new User();
            populate(user);
            //设置状态为正常
            user.setStatus(Constant.USER_OK);
            users.add(user);
        }else {
            //修改操作
            populate(this.user);
            //刷新
            userTableView.refresh();
        }

        stage.close();
        Alerts.success("成功", "操作成功");
    } catch (Exception e) {
        e.printStackTrace();
        Alerts.error("失败","操作失败");
    }

}
```

首先这个代码的第七行获取了用户的id，如果用户的id为空或者不存在，说明其是添加的操作，反之则是修改，因为添加和修改方法比较像，所以这里放一起去实现了，我们这里先看添加方法，修改方法先放一边

我们可以看到在添加方法里调用了populate()方法，我们点进去看看这个方法到底干了啥

```javascript
private void populate(User user) {
    user.setMoney(new BigDecimal(moneyField.getText()));
    user.setName(userNameField.getText());
}
```

这个方法其实就是将用户输入的姓名和余额获取到并设置到对应的内存对象中，这里userNameField就是对应的输入框对象，这里调用了输入框对象的里的获取文本的方法，上面金额也是同理的，不过金额是个常量，因此这里先创造一个常量对象并传入然后在设置给User对象

所以说其实addOrEditUser()里整个添加代码就是给user对象赋值，然后将user对象添加到对应的集合中

那么学习上面这些之后，我们之后就可以正式去实现添加用户的持久化的操作了，同样我们要利用代码分层的思想，同样，我们先来实现Dao

层

首先我们进入Dao包，然后进入Dao接口，添加一个添加用户的方法，可以写入方法代码如下

```javascript
void add(User user);
```

添加操作不需要修改什么，因此返回值为空，添加功能的实现当然需要有传入的用户才能添加，因此要有传入的用户参数

改动完毕之后我们对应的实现类也要相应变动，我们进入对应实现类UserDaoImpl，实现新添加的方法，我们写入如下代码

```javascript
/**
 * 添加操作
 * @param user
 */
@Override
public void add(User user) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        //创建对象输入流，从硬盘指定位置处读取文件信息
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        //读取文件中的List对象
        List<User> list = (List<User>) ois.readObject();
        if(list!=null){
            //获取list集合中最后一个User对象
            User lastuser = list.get(list.size()-1);
            //生成用户的编号
            user.setId(lastuser.getId()+1);

            //将user对象放入到list集合中
            list.add(user);
        }else {
            //若集合没空则说明创建的是第一个用户，创建新集合并赋予固定ID，然后将该对象传入到集合中
            list = new ArrayList<>();
            user.setId(1001);
            list.add(user);
        }
        //将集合中的数据写入到对应文件中
        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.USER_PATH));
        oos.writeObject(list);
        oos.flush();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

那么我们Dao层的代码就实现完毕了，接着我们去实现Service层的代码，同样我们去Service的接口类添加方法如下

```javascript
void add(User user);
```

改造其实现类的代码如下

```javascript
/**
 * 添加
 * @param user
 */
@Override
public void add(User user) {
    userDao.add(user);
}
```

接着我们Service层就写好了，最后我们去实现controller层

这里我们的controller层是UserServiceImpl类，首先要调用Service层的方法其必须先拥有Service对象，因此我们这里先把Service赋予为该类的成员变量并创建对象

```javascript
private UserService userService = new UserServiceImpl();
```

然后在方法里将代码修改如下

```javascript
try {
    String id = userIdField.getText();
    if ("".equals(id) || null == id) {
        //添加操作
        User user = new User();
        populate(user);
        //设置状态为正常
        user.setStatus(Constant.USER_OK);
        //调用service将user数据持久化到数据中
        userService.add(user);
        users.add(user);
```

这里之所以将持久化方法放在前面，而将内存添加对象的方法放在后面的缘故是两者调用的user对象其实是同一个，我们这里如果持久化方法放在后面的话那么内存添加对象方法就会出现编号没有正确设置的问题，我们这里将持久化方法放在前面，先将编号设置好之后再来放入到内存中展示，就避免了编号没有设置的问题

最后我们还要说的一点是其实我们还应该对我们的姓名和金额输入进行校验的，因为我们输入密码时，理论上我们是只允许用户整数数字的，如果用户输入字符串那肯定不行，姓名也是，理论上不可以太长，这里我们就先不去实现这些校验了，但我们要知道我们实际开发项目时校验步骤是必不可少的，理论上，我们的每一个框目，都是需要进行校验的！



用户修改操作的实现

用户修改操作和用户添加的操作是非常相像的，它们是共用同一个窗口的，不同的是用户添加的操作是不需要选中用户，而修改则是需要的

我们同样先来分析下用户修改的代码，进入UserView.fxml可以看到对应修改界面的代码

```javascript
<Button layoutX="406.0" layoutY="10.0" mnemonicParsing="false" prefHeight="54.0"
        prefWidth="100.0" onMouseClicked="#userEditView" styleClass="btn-info"
        text="修改"/>
```

同样有鼠标点击之后会执行的底层代码，我们点进去看看

```javascript
/*
    修改
 */
@FXML
private void userEditView() {
    try {
        User user = this.userTableView.getSelectionModel().getSelectedItem();
        if (user == null){
            Alerts.warning("未选择","请先选择要修改的数据");
            return;
        }

       initStage(user);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

可以看到这个方法先获取了我们要修改的用户数据，如果这个数据为空，说明我们没有选择用户，此时弹出提醒框，提醒我们选择用户，提醒框的出现就是依赖第9行代码

其实我们之前也看过类似的代码了，比方说下面这行代码

```javascript
    userTableView.refresh();
    stage.close();
    Alerts.success("成功", "操作成功");
} catch (Exception e) {
    e.printStackTrace();
    Alerts.error("失败","操作失败");
}
```

这就是负责弹出添加成功提醒框和失败提醒框的代码，我们也容易知道Alerts这个对象的作用是弹出对应的框

接着我们看到在这个方法里其调用了initStage();方法，我们点进去看看里面到底做了什么

```javascript
/*
    初始化stage
 */
private void initStage(User user) throws IOException {
    FXMLLoader loader = new FXMLLoader();
    loader.setLocation(App.class.getResource("/com/bjpowernode/module/user/UserHandleView.fxml"));
    StackPane target = (StackPane) loader.load();
    //Scene scene1 = App.getDecorator().getScene();
    Scene scene = new Scene(target);


    Stage stage = new Stage();//创建舞台；
    UserHandleViewCtrl controller = (UserHandleViewCtrl)loader.getController();
    controller.setStage(stage);
    controller.setUsers(users);
    controller.setUser(user);
    controller.setUserTableView(userTableView);
```

先看第6行代码，其先将修改界面的窗口载入进来，这样我们就可以看到对应的修改窗口

然后看12行之后的代码，其调用了方法获得了一个controller对象，在这个对象里将用户的数据给传入进去（传入用户对象数据的代码在第16行），我们不妨点进去看看

```javascript
public void setUser(User user) {
    this.user = user;
    if (user != null) {
        //填充修改界面的值
        userNameField.setText(user.getName());
        userIdField.setText(String.valueOf(user.getId()));
        moneyField.setText(user.getMoney().toString());
    }
}
```

这里进行的动作是获取用户的姓名和余额以及编号，然后将这些数据转换为字符串自动填充到窗口中，这也就是为什么我们一选中一个用户点击修改弹出的窗口里就会显示对应的用户的余额和姓名的数据，就是依赖于上面的代码，当然这里其实ID也有的，但是ID的窗口框是不可见的，所以我们看不到

上面就是修改事件的代码分析了，接着我们点击提交，就会进入到下面这行代码的执行

```javascript
/*
    添加或修改数据
 */
@FXML
private void addOrEditUser() {
    try {
        String id = userIdField.getText();
        if ("".equals(id) || null == id) {
            //添加操作
            User user = new User();
            populate(user);
            //设置状态为正常
            user.setStatus(Constant.USER_OK);
            //调用service将user数据持久化到数据中
            userService.add(user);
            users.add(user);
        }else {
            //修改操作
            populate(this.user);
            //刷新
            userTableView.refresh();
        }
```

这里自然能判断到id是存在的，于是就会进行修改操作，我们这里要修改后的用户进行数据的持久化，同样应用代码分层的思想，先进入Dao层接口写入如下方法

```javascript
void update(User user);
```

接着我们进入对应实现类进行实现，代码如下

```javascript
@Override
public void update(User user) {
    //先将list数据从文件中查出来
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.USER_PATH));
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        List<User> list = (List<User>) ois.readObject();
        if(list!=null){
            //利用Stream流从list集合中查找需要的用户对象
            User originUser = list.stream().filter(u -> u.getId() == user.getId()).findFirst().get();
            originUser.setName(user.getName());
            originUser.setMoney(user.getMoney());
            oos.writeObject(list);
            oos.flush();
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

注意我们调用修改方法时，是将内存中的用户修改了的，内存中存储用户对象的是list集合，我们写入文件输入流，获取到的是我们存放在硬盘里的list集合，然后我们的目标是找到在硬盘中的list集合里对应的User对象将其数据修改成我们在内存中修改的对象的数据，接着将其重新序列化

为了找到我们所需要的User对象，我们这里用了stream流，具体是第12行代码，依次取出集合中的用户对象，取其ID与我们在内存中修改的ID进行比对，相同的那个就说明是我们所修改的那个，获得该对象然后修改接着序列化就完了

然后我们去实现service层的代码，找到接口，然后写下方法

```javascript
void update(User user);
```

实现该方法的代码如下

```javascript
/**
 * 修改
 * @param user
 */
@Override
public void update(User user) {
    userDao.update(user);
}
```

目前我们会发现service层的存在似乎有些多此一举，因为其总是重复调用方法，并没有实现什么东西，那么可以不可以将其删除呢？答案是不可以的，因为虽然我们现在啥都没写，但是后面我们是会写的，这个层还是有他的作用的，不着急

那么最后我们来实现controller层，在对应的方法里调用service的方法就完了

```javascript
//持久化操作
userService.update(user);
```

那么到此为止，我们修改操作也就实现完毕了