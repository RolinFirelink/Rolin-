本章节我们来学习持久化，这也是Redis最后一章的内容。我们这一章实际操作的少，理论讲解的部分多，所以要注意听

- 持久化

首先我们来讲解下什么是持久化，持久化简单来说就是利用永久性存储介质将数据进行保存，并且在特定的世界里将保存的数据进行恢复的工作机制。其主要目的是为了防止数据的意外丢失，确保数据安全性

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5dc451ee9aa21528e9ebd43a126fd9d8.png)

持久化有两种方式，一种是直接存储数据的结果，格式简单，关注点在数据，这种方式成为RDB。另一种方式是保存数据的操作过程，其是利用日志形式，关注点在数据的操作过程，成为AOF

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEba9ab1aea4e321151a37a278028bee1a.png)

我们接下来就对这两种数据的保存方式进行逐一的讲解

- save指令完成RDB

RDB有是那种方式可以完成，我们先来介绍第一种方式，也就是使用save指令来完成的方式。这个方式非常简单，直接输入save就行了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd0ab4ab59b4f5f61f9c9f880237d8169.png)

不过输入这个save命令的时候，有一些参数我们需要提前设置，也就是下图中的四个参数，下图中的下个参数是在配置文件里设置的，其中后两个默认开启我们不用管，第二个我们已经设置了，所以我们只需要设置第一个就行了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEad37d32cb84788382a0657956481c8a2.png)

那么我们只需要进入我们对应的conf文件，然后增加对应的配置信息就可以了。接着我们可以开启几个窗口自己去测试，最后测试我们容易发现每次save我们的文件都会保存到data文件夹中，其内容会是乱码的，只有英文名称能稍微看见。每次我们的服务器重启时就会先加载这里的文件进入到内存中接着再运行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa461d3b79ccedb9dcbadb628d940d607.png)

那么这种方式有什么弊端呢？其最大的弊端就是我们的Redis服务器是单线程的，如果我们的数据量较大的话，save指令就可能会耗时过长，最后阻塞Redis服务器，直到当前的RDB过程完成位置，线上环境不建议使用这个方法，当然你非要用也没法是吧

- bgsave指令完成RDB

那有没有什么办法可以解决这个阻塞问题？当然有，那就是使用bgsave指令，该指令可以启动后台保存操作，但不是立刻执行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc854d1bf7834d505bb63bfb8f62890c3.png)

来看看其相关配置，由于我们之前都已经设置过了，所以我们这里就不重复设置了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf74df7b6e105e249436ffb7c57fba85b.png)

最后我们来讲解下bgsave的内部执行过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2bea02a89258d6822c9356208b26cee9.png)

bgsave命令向Redis发送后，Redis会调用fork函数生成子进程来创建rdb文件，创建成功之后再返回成功的消息，这个保存的方式是主流的方式，我们以后所有的save都用bgsave替代

- save配置完成RDB

我们可以设置一个自动持久化的条件，让我们的Redis在满足限定时间范围内的key的变化数量时就进行持久化

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8a2152ce66e082fe38188864fbdbf529.png)

设置这个需要到配置文件中设置，其中second是监控的时间范围，而changes则是key的变化量

然后我们来看看相关配置

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE69abc2d315e0ca83dc134fc824b4a2db.png)

save配置的工作原理是用户没进行一次操作就往Redis中发送一次指令，Redis会返回这个指令的结果并记录，一旦在规定时间内达到了指定数量就进行保存。不过这里返回的结果里只有对数据产生影响的结果才会被计入，比如说我们调用get，这是不会计数的，或者我们调用set但是没有set成功，这样不计入，同时，即使我们修改的数量的一样的，也就是说，我们将1设置为1，这样设置虽然表面看起来没啥变化，但是实际上也是会被计数的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa2d1eb42d4542603655ba35f397701c1.png)

最后一点我们要注意的save配置要根据实际业务情况进行设置，频度过高会有性能问题，过低会有数据不安全的情况，最后save配置启动后执行的是bgsave

- RDB方案比对与优缺点分析

最后我们来分析下RDB的三种方式的优缺点，先看对比图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE94c96c429a5df8216033d919d5c9e4af.png)

其实根本不用看，因为我们肯定都是用bgsave的，然后我们来讲解RDB的特殊启动形式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6d001ca1f25fd96eec20b373b45f1d51.png)

debug reload可以在我们的服务器运行过程中启动，也就是热启动，简单来说就是服务器重启时我们的save指令也会执行

然后是shutdown save，这个指令关闭服务器时是可以指定保存数据的。

最后是全量赋值，这个留到我们明天的课程中讲

最后我们来看看RDB的优缺点分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE30e5477d6da4486fbb30f2f412d30ad7.png)

