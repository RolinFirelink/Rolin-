接着我们来学习Maven高级，这也是我们的阶段性学习的最后一个内容了，加油，冲冲冲。

- 模块拆分思想与pojo模块拆分

接着我们来学习我们的模块拆分思想，所谓的模块拆分思想，也就是我们可以将我们的一个大的项目的几个部分拆分为不同的模块，然后通过maven令其协同工作，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6a60ed3d3786c7d60ffb863f3ea7f5f4.png)

而至于system.exception类，这一个类我们就具体使用到的时候再具体将其放到对应的地方去，目前我们先只对比较要紧的四层进行一个分模块。

首先我们来完成我们的工程里的实体类的一个分模块，那么我们首先创建一个maven工程，不需要指定任何模板，然后我们将对应的工程里的东西直接复制到我们的java文件夹中，值得一提的是，我们推荐先创建对应的文件夹，然后将对应的类放置进去，接着我们对其执行编译命令，可以发现其编译可以通过，那么我们的第一个模块就完成了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf8a85c669c50856a6ce73b6c5acd3f4e.png)

- Dao模块拆分

然后我们来做我们的Dao层模块的拆分，同样我们还是创建对应的工程，然后我们将对应的类复制过来，最终我们的模块目录就如下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE098564ceb3b75d6f016dd9ab27c5045d.png)

这里我们的UserDao文件是会报错的，因为我们的文件里既没有实体类，也没有MyBatis对应的注解依赖，我们后者的问题可以通过导入依赖解决，但是前者该如何解决呢？此时要知道，我们的实体类的模块，其实也是一个maven工程，既然它是maven工程，那么其自身就可以作为一个资源引入到我们的模块中，这样就可以解决报错了。但是这里我们要注意一个问题，虽然我们引入了对应的坐标，但这样只会让我们的idea的编译器能够通过，实际上我们对该类进行编译时，其是会从本地仓库里去寻找我们的资源的，因此我们要先让我们的实体类执行install指令，令其先安装到我们的本地仓库中，这样我们对Dao模块的编译才能够通过

其实这个执行install命令的过程，也是一个打包的过程，到这里我们对打包就又有了更深一步的理解了，打包简单来说就可以理解为把对应的资源下载到我们的本地仓库中，而打包的方式是有很多种的，最基础的两种是打jar包和打war包

最后我们可以改造我们的pom文件的代码如下，我们这里第18-23行就是引入我们的自定义资源的代码，同时第7-9行是我们该类自己的坐标，后续被人引用时需要用到该类，同时我们的组的坐标可以在我们创建对应模块的时候指定，如果后续想修改，直接到pom文件中，也就是这里的第七行去修改也可以

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>ssm_dao</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>

        <!--导入资源文件pojo-->
        <dependency>
            <groupId>com.itheima</groupId>
            <artifactId>ssm_pojo</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>


        <!--spring环境-->
        <!--spring环境-->
        <!--spring环境-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.1.9.RELEASE</version>
        </dependency>


        <!--mybatis环境-->
        <!--mybatis环境-->
        <!--mybatis环境-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.3</version>
        </dependency>
        <!--mysql环境-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.47</version>
        </dependency>
        <!--spring整合jdbc-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.1.9.RELEASE</version>
        </dependency>
        <!--spring整合mybatis-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.3</version>
        </dependency>
        <!--druid连接池-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.16</version>
        </dependency>
        <!--分页插件坐标-->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>5.1.2</version>
        </dependency>

    </dependencies>

</project>
```

首先我们需要讲解一下，我们之前的整个pom文件是因为我们的最开始的Spring环境有下面的关联环境所以我们才没必要特别再导入一次依赖的，而这里我们的每一个模块都是对应的Spring工程，都需要Spring环境，所以我们的任何一个工程都需要引入Spring的依赖，否则其会失效

然后我们重点要讲一下的是，为什么我们的分页坐标我们也跟着导入进来了，一般我们的分页插件是做在业务层的，而我们这里是数据层，按说应该是不用加的才是，那我们这里为什么要加呢？这是因为我们的Dao层的配置文件中是配置了分页插件了的具体设置的，如果分页插件都没有了，那他配置个几把，所以我们这里一定要引入

接着我们还值得一提的是，我们的pom配置文件中，应该还要引入我们的junit依赖的，因为我们的模块总是需要做独立的测试的，但我们这里图个方便就不添加了，毕竟我们连test文件夹都给删除了

最后我们去对应的配置文件中删除掉一些不必要的配置代码

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!--开启bean注解扫描-->
    <context:component-scan base-package="com.itheima"/>

    <!--加载properties文件-->
    <context:property-placeholder location="classpath*:jdbc.properties"/>

    <!--数据源-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--整合mybatis到spring中-->
    <bean class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="typeAliasesPackage" value="com.itheima.domain"/>
        <!--分页插件-->
        <property name="plugins">
            <array>
                <bean class="com.github.pagehelper.PageInterceptor">
                    <property name="properties">
                        <props>
                            <prop key="helperDialect">mysql</prop>
                            <prop key="reasonable">true</prop>
                        </props>
                    </property>
                </bean>
            </array>
        </property>
    </bean>

    <!--映射扫描-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.itheima.dao"/>
    </bean>
</beans>
```

我们这里去除了开启事务的代码，因为我这里不需要开启事务,一般事务都是在业务层里开启的，然后执行编译就可以了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2af2bdb66d5121c88fb934f4f27a7360.png)

- service模块拆分

然后我们来拆分service的模块，同样的步骤，最后我们得到的目录结构如下所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEda190db3d716928b48b27348c261b34f.png)

这里我们为了区分我们不同模块里的配置文件，所以我们这里给我们的对应的配置文件加入service的标识用于区分

首先我们当然是要引入对应的依赖，那么我们可以写入其依赖代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>ssm_service</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>


        <!--导入资源文件dao-->
        <dependency>
            <groupId>com.itheima</groupId>
            <artifactId>ssm_dao</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>


        <!--spring环境-->
        <!--spring环境-->
        <!--spring环境-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.1.9.RELEASE</version>
        </dependency>


        <!--其他组件-->
        <!--其他组件-->
        <!--其他组件-->
        <!--junit单元测试-->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>
        <!--spring整合junit-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.1.9.RELEASE</version>
        </dependency>
    </dependencies>


</project>
```

这里我们引入了测试类，因为我们要进行测试，然后我们引入了dao模块的资源，由于dao模块下已经引入了pojo的资源了，因此pojo的资源也会被一并引入，此时我们就不需要额外配置pojo的依赖了

最后我们要提一下的是，由于我们的配置文件的名字都已经改了，而我们测试时又要引入对应的配置文件，我们的解决方式是可以在对应的注解里引入多个配置文件

```
@ContextConfiguration({"classpath:applicationContext-dao.xml","classpath:applicationContext-service.xml"})
```

然后我们同样配置我们的配置代码，我们这里service层是要开启事务的，所以我们留下开启事务的代码

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!--开启bean注解扫描-->
    <context:component-scan base-package="com.itheima"/>

    <!--开启注解式事务-->
    <tx:annotation-driven transaction-manager="txManager"/>


    <!--事务管理器-->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

</beans>
```

最后我们要注意的是，其编译器会提示我们的这里压根没有dataSource，但这只是一个编译器的提示，虽然报红，但是没有影响，因为我们的数据源已经加载到我们的资源库当中了，因此其实际运行是没有问题的，报红我们不管他就行了（其实这里也能解释我们之前做SB案例的时候依赖中报红但是不影响我们的项目运行的原因）

然后我执行其test命令和install命令

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa5a9718087b5983edf4d12725135aba9.png)

- controller模块拆分

最后我们来进行controller模块的拆分，首先我们要创建一个webapp的模板，我们的表现层的结构与其他的情况不同，所以我们这里要创建对应的webapp模块，最后我们保留其结构如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE57011b5dd603176bc87ad426e024ccc0.png)

可以看到我们这里将控制层以及统一格式类都放到我们的控制层上去了，然后我们来配置我们的pom.xml文件，这里同样是保留自己所需要的对应配置并引入我们的对应依赖，我们这里直接引入springmvc的依赖，其下有spring的依赖，所以我们这里不用特别打开spring的依赖了

```
<dependencies>

    <dependency>
        <groupId>com.itheima</groupId>
        <artifactId>ssm_service</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    
    <!--springmvc环境-->
    <!--springmvc环境-->
    <!--springmvc环境-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.1.9.RELEASE</version>
    </dependency>
    <!--jackson相关坐标3个-->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.9.0</version>
    </dependency>

    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
</dependencies>

<build>
    <!--设置插件-->
    <plugins>
        <!--具体的插件配置-->
        <plugin>
            <groupId>org.apache.tomcat.maven</groupId>
            <artifactId>tomcat7-maven-plugin</artifactId>
            <version>2.1</version>
            <configuration>
                <port>80</port>
                <path>/</path>
            </configuration>
        </plugin>
    </plugins>
</build>
```

接着我们配置的代码就只保留一个springMVC的，然后我们web.xml的代码里要加载的配置文件由于名字发生了改动因此会报红，我们这里的解决方式是将对应的加载代码修改如下

```
<param-value>classpath*:applicationContext-*.xml</param-value>
```

这样就代表会加载所有有该固定前缀的配置文件了，当然其语法检查器还是会报红，还是那句话，我们不管他就可以了，这并不影响我们的正常运行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7394c27f1704d567548f1af23577a8ff.png)

最后我们可以对本章节做一个小结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd028a994a1e6ebd12d705a152dda5e04.png)

