# 抽象类与接口

## abstract抽象类

类之间的共同点抽象之后形成的更高级的类就是抽象类，**抽象类无法实例化**

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/抽象类.png)

抽象类也属于引用数据类型，其次是抽象类的语法是

[修饰符列表] abstract class 类名{ 类体 }

**抽象类没有无法实例化但有构造方法**，抽象类存在的意义就是为了被继承的

那么final和abstract不能连用，因为被final修饰的类是不能被继承的，如果我们用final去修饰抽象类，那抽象类就不能被继承了

同理abstract和private也是不能连用

抽象类的子类可以是类，也可以使抽象类

如果我们在一个abstract类里只写了一个有参数的构造方法让子类（默认子类不做增改）去继承这个抽象类，由于子类的构造方法里是默认有super()语句的，super语句是调用无参数构造方法的，而在abstract类里，我们由于已经给了一个有参数的构造方法了，那么默认的无参数构造器就没了，那么super();就没有办法找到对应的方法，所以会报错

解决方法有两个，一是直接删除这个有参数的构造方法，二是手动写一个无参数的构造器，这也是为什么我们常说写任何一个构造方法前都应该先手动写一个无参数构造器

## 抽象方法

抽象方法是只能存在于抽象类当中的方法，抽象方法的特点是带有abstract并且在方法名的()之后直接加分号，比如public abstract void dosome();

相当于是一个普通的实例方法加了一个abstract

抽象类里可以有抽象方法，也可以有非抽象方法

抽象方法只能出现在抽象类中，非抽象类不能出现

**非抽象类继承子类必须将抽象方法实现，抽象类中可以使用多态机制**

利用多态机制让我们调用抽象类中的方法，就叫做面向抽象编程。面向抽象编程是符合OCP原则的，我们程序员也主要是要用面向抽象的思想来进行编程的，因为面向抽象编程能降低程序的耦合度，提高程序的扩展力

> OCP即是开闭原则（Open Closed Principle）简称 OCP

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/接口.png)

## 接口

接口是一种"引用数据类型"，编译之后也是一个class字节码文件

接口是完全抽象的，而抽象类是半抽象的，或者我们也可以说接口是特殊的抽象类

定义接口的语法是[修饰符列表] interface 接口名{}

接口类支持多继承其他接口类，使用规则是在extends后面用，连接各个接口

非接口类可以同时实现多个接口类，但是必须要在自己的方法体里对接口里的方法都进行实现，该机制弥补了java中类与类之间只能单继承的缺陷

接口中只包含两个内容，一是常量，二是抽象方法，且接口中的元素都是公开的

在interface接口类里定义方法可以省略掉前面的public abstract，直接写抽象方法的名字加上小括号和分号即可

接口类中的变量都是常量，前面的public final修饰符被省略，常量的命名规范是全部大写

接口本身可以当做一个类，可以用类名.的方式调用类里的常量和方法

**一个类实现一个接口，必须实现接口内的所有抽象方法**

接口与其他非接口类中的继承，我们称之为实现，即implements，其实质作用和继承是一样的

**接口类可以和多态联合使用**，我们称之为是面向接口编程

**extends和implements同时可以出现，使用规则是先继承后实现**

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/类型与类型的关系.png)

### 接口在开发中的作用

接口在开发中的作用其实类似于多态在开发中的作用

抽象类是半抽象的，而接口是完全抽象的

我们讲解多态的时候讲过，我们要面向抽象编程，不要面向具体对象编程，其实这句话在以后就改成，我们要**面向接口编程**

因为接口可插拔，可插拔就表示程序的扩展力很强，耦合度很低，这是符合OCP原则的，也是我们程序员应该做出来的程序

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/抽象类2.png)

### 类型与类型的关系

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/接口2.png)

抽象类和接口比较，往往是接口使用得比较多，抽象类使用得比较少

# Object类其下的方法

Object类是所有类的超级父类，所有类都默认继承了Object类

## toStirng()

sun公司设计toString方法的目的是通过调用这个方法可以将一个"java对象"转换成"字符串"的形式，sun公司建议所有的子类都去重写toString方法，同时重写的toString方法应该是简单的，详实的，易阅读的，实际情况中我们可以使用idea的工具来快速重写toString方法

如果我们只输出引用，那么会自动调用该引用里的toString方法

如果toString方法没有重写，其默认输出的当前对象的内存地址

## equals()

equals方法默认比较的两个对象的内存地址，其设计目的是为了用于判断两个对象是否相等

推荐每一个类中都重写该方法，可以使用idea的工具帮助重写

Stirng类以及其他Java类库中提供给我们的类，其都已经事先实现好了这种需要实现的方法



![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/object.png)

我们平时写代码的时候，最好就把每一个equals方法都进行重写，防止我们在以后我们需要调用equals方法的时候，产生不必要的错误

### instanceof简单记忆法

**想要重写那个类，那个类的类名就放在后面，传入的什么引用，引用名就放前面。如果是判断引用是不是它自身，那么前面写this，后面写引用名**

## clone()方法

这个方法的主要作用就是可以克隆一个对象，该克隆又分为深克隆和浅克隆，前者指的是克隆出来的对象以及内部的引用类型都是全新的对象，而后者只有对象是全新的，内部的引用对象还是与克隆前对象还是同一个对象

## hashcode()方法

hashCode方法中有native关键字，其不是抽象方法，其没有方法体，底层调用的是C++程序

hashcode方法会返回对象的经过了哈希算法之后的内存地址，我们也可以简单把它返回的值理解为是另一种形式的表现的对象的内存地址

# 内部类

内部内一共有四个，分别是静态内部类、实例内部类、局部内部类以及匿名内部类

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/内部类.png)

匿名内部类指的是直接在需要对应类的地方实例化一个类，由于该类没有名字，因此无法再次调用，只能在实例化的做作用域中进行一次使用，并不推荐使用

# 数组及数组常见算法

## 一维数组

在java语言中的数组是一种应用数据类型，其父类是Object

数组本身是一个容器，可以容纳多个元素，这些元素可以是基本数据类型也可以是引用数据类型，如果数组存储的是java对象的话，实际就相当于是储存了引用，我们可以通过每一个引用去调用对应对象内部的方法或者是访问或者是修改其变量

数组本身是引用数据类型，存放在堆内存里。其变量名所储存的内存地址值是数组第一个变量的内存地址，以其首地址来当做数组的内存地址

数组长度一旦确定就不可变

在java中所有的数组都有length属性，用于获取数组的个数

java中的数组要求数组的元素类型统一，比如int类型数组只能存储int类型变量，不能存储其他类型的变量

一维数组中的元素的内存地址是连续的，同时数组也是一种数据结构

对于引用数据类型的数组而言，里面存放的引用的内存地址是不同的，但是储存这些引用的位置本身也存在内存地址，这些存放的位置的内存地址是连续的

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/数组.png)

数组检索某个下标的元素时效率极高，但是增删某个元素的效率很低，同时数组不可以存储大数据量，因为在内存中很难找到一块特别大的连续内存空间

### mian方法中的String数组

在我们的main方法本身public static void main(String[] args){}其表示的意思是，我们构造了一个静态方法，方法名为mian，该方法要接受一个String数组作为参数，数组名为args

既然有方法，那就要被人调用，实际上这个方法是被JVM调用的，JVM调用这个方法的时候，会自动传一个String数组过来

编写这种代码可以在控制台中输出args的长度，会得到0的结果

这个0表示数组是实际存在的，但是里面什么东西都没有放，本身也没有位置给别人放东西，可以理解为存在，但是没什么意义

那么这个数组有什么用呢？其实这个数组是留给用户用的

用户可以在控制台上输入参数，然后这个参数会自动转换成数组，JVM会将这个数组创建出来并传给String[] args

那么我们在idea里要怎么在控制台上输入参数呢？

我们只要点击窗口上的Run，在选中Edit Configuration...在左侧选中我们需要输入参数的类，然后在右侧里输入我们想输入的字符串，空格代表输入停止，空格之后输入的会存放在后一个元素的位置里

## 二维数组

二维数组是特殊的一维数组，相当于是一个一维数组内每个位置存放着一个数组

二维数组的定义方法是数据类型[][] 数据名，静态初始化的方式是{{},{},{},.....}

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/String.png)

## 数组中的常见方法

### System.arraycopy()

使用该方法可以实现数组扩容，其本质是通过拷贝进行的，是把一个数组的内容一个个拷贝到更大的数组里去，然后再销毁原来的数组，是一种效率极低的方式，能不用就尽量不用

该方法同时还可以用来实现数组拷贝

这个源码本身是一个名为arraycopy的静态native的含参方法，这种含参方法需要传入五个参数才能调用

第一个参数是要传入我们要拷贝的数组的内存地址

第二个参数是传入我们要拷贝的数组的起始位置的下标

第三个参数是要传入我们要将数组黏贴到那里的数组的内存地址

第四个参数是传入我们要将数组黏贴到哪里的数组的起始位置的下标

第五个参数是要传入我们要拷贝的数组的长度

源码里的数组的引用类型是Object，以此来避免类型转换异常

### Arrays.toString()

使用该方法可以直接打印数组内的值，包括一维数组和二维数组，但是只限于包装类中的数组内容

### 数组的常见算法

有二分法、冒泡排序、选择排序等，在Arrays工具类中有提供对应的排序和二分方法供给我们使用

二分法的使用必须在排序之后，不然是没有意义的

# String类

## 字符串的存储原理

String属于引用数据类型，不属于基本数据类型，在JAVA中规定用""号括起来的都是String对象，不能再次更改，因为其源码中String内的属性是被final修饰的，因此其不可更改

String类构建的字符串其底层也是一个char数组，该数组被final修饰，因此其无法再进行更改，如果想要一个我们的所需要的不同的字符串，那我们就只能创造新的

String类的变量都是储存在方法区的字符串常量池当中的

```java
String s1 = "abcdef";
String s2 = "abcdef"+"xy";
```

上面代码JVM图加载的情况是其会先在方法区内存的字符串常量池中创建一个空间用于存放变量"abcdef"，而s1则会创建在栈内存的主方法所在的空间里，并储存指向常量池变量"abcdef"的引用

而s2则表示其会在方法区内存中多创建一个储存字符串"xy"的空间，只不过这个空间没有引用去指向它，接着会继续在常量池中创建一个空间用于储存"abcdefxy"，然后在栈内存中s2的引用会指向它，这里由于"abcdef"已经有了，所以就不会再次创建了

注意在方法区里的用于储存字符串的空间也是对象，既然是对象，那么就可以调用对应的方法

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/二维数组.png)

如果我们采用String a=new String("Hello");String b=new String("Hello");这种形式来创建字符串，其表示的意思是在方法区内存的常量池里同样创造了一块空间用于存放相同的字符串，但是因为我们用这种代码创造了对象，所以实际上我们堆内存里创建一个对象，这个对象存放的内存地址就指向常量池的字符串空间，但是a是属于栈内空间的存放指向堆内存的对象的内存地址，由于new了两个对象，他们在堆内存的空间必然不一样，此时用==号比较时就必然返回false

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/String2.png)

## String类中的方法

### String(byte[] bytes)

该方法可以将byte数组传进该方法中，其会将对应的byte的值转换为char类型组合并构造一个全新的String变量

使用该方法需要传入一个byte数组

### String(byte[] bytes, int offset, int length)

该方法可以将byte数组里的特定长度的字符取下来将对应的byte值转换成char类型组合并生成一个新的String类型的字符串，使用该方法时要传入一个byte数组，以及我们想要取的位置的下标以及长度

### trim()

调用这个方法可以去除字符串前面和后面的空格，中间的不作处理

### replace()

该方法可以用于替换字符串里的字符，调用此方法时要输入想要替换的字符串和替换该字符串的内容

### getBytes()

将字符串对象转换为一个byte数组对象

### equalsIgnoreCase

判断两个字符串是否相等，比较时忽略大小写

## StringBuffer类



如果使用＋号进行字符串的拼接，会给方法区内存较大的压力，用StringBuffer里的append方法进行拼接比较好

StringBuffer的底层其实是一个byte[]数组，如果我们往里面存放字符串，实际上是存放到byte数组里了，其初始化的容量是16，如果我们进行拼接的时候其字符串的内存大小已经超过16了，那么其会在进行拼接之前先自动进行扩容操作，为了提高性能，可以在创建的时候就给定一个适合的稍微大一点的初始化数组

StringBuffer类底层的char[]数组没有被final修饰，它里面所代表的字符串可以先赋值到一个新的更大的数组里去，然后将原本指向旧的内存地址的引用改成新的，然后旧的数组就被垃圾回收器回收了，通过这种方法达到字符串的拼接，同时省下空间

StringBuilder和StringBuffer都可以完成对字符串的拼接，前者是线程不安全的，后者是线程安全的

# Java对日期的处理

## Date

java中有专门为我们设置好的一个类让我们能够获得当前的日期与时间，其是位于java.until包下的Date类

Date可以传入毫秒数来构造Date对象，传入对应的毫秒数进去到这个构造方法里，这个构造方法本身会将这个毫秒数读取然后返回一个Date类型的引用，打印这个Date类型的引用可以输入对应的时间，后面也可以接日期格式化的对应代码的应用

该可以用来获取昨天的或者是对应哪天的时间，比如我想要获得昨天的现在的时间，那么我只需要调用这个方法，在括号里传入1970到现在的总毫秒数再减去一天的毫秒数就可以了，同理也是可以获得一年的

## SimpleDateFormat

Date里已经重写过toString方法，因此打印的时候会返回一个对人类读者有意义的值，但是因为这是歪果仁搞得东西，所以实际产生的格式仍然不便于我们中国人的阅读

java.text包下的SimpleDateFormat类专门负责日期的格式变换

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/包装类.png)

如果我们想要将一个String类型的日期给转换成Date类型，首先创建对应的字符串，然后创建对应的格式变换对象，调用该对象中的parse方法传入对应字符串即可获得所需的日期对象，此处需要进行异常处理

## System.currentTimeMillis()

该静态方法能够让我们获取自1970年1月1日00.00到当前系统时间的总毫秒数，我们可以用这个方法来确定一个方法运行的所需的时间

# 随机数类Random

随机数Random类存在于java.util包下，可以用于生成随机数

使用时要先new一个Random类的对象出来，然后调用里面对应的方法就可以了

调用方法时如果不传入参数会随机生成该中基本类型的范围内的随机数之一，如果限定了范围则会生成0~length-1的数，其中length代表我们输入的值

# 枚举类型enum

枚举类型可以自定义构建各种我们所需要的情况的表示方式

语法是enum 枚举名{枚举名词,枚举名词...}

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/java中对日期的处理.png)

# 包装类

java中为8中基本数据类型又对应准备了8中包装类型，这8中包装类型都是引用数据类型，包装类内部会提供一些方法供给程序员使用

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/枚举.png)

在Interger类里，是定义了静态代码块的，这个静态代码块会在类加载的时候现在方法区里开辟一个空间，称之为常量池，这个常量池中存储着有-127到127的整数，也就是byte类的取值范围，当我们定义的值在这个区间时，引用就不会再堆内存中开辟空间了，而是会直接指向常量池

为什么要先在方法区内存中开辟这样一个空间呢？这是因为这一段数字使用得真的是太频繁了，所以我们预先开辟出来，这样就可以提高效率

如果我们的数字在常量池之外，则会在堆内存中创建新的对象