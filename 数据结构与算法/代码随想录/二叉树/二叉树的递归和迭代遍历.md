- 二叉树的递归遍历

关于递归，我们不能总是随心而动，随刃而行。瞎几把做，这样我们总是容易做错，而且没有规律去做也不利于我们在思维上的成长。因此我们要学习一套递归上的方法论，请看下文

1. 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

1. 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

1. 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

下面我们就以一道前序遍历的题目来讲解下我们的递归思路，我们的题目是第144题。在本题里，我们要通过递归实现二叉树的前序遍历，那么我们先确定我们递归函数的参数和返回值，首先我们的参数必然是一个结点，然后由于题目需要的是List集合里存放对应的值，因此我们递归的时候直接把值放到List集合中就可以了，不需要什么返回值。接着我们要确定终止条件，我们的终止条件当然就是当我们的结点到达叶结点终止，最后我们要确定单层递归的逻辑，我们单层递归的逻辑是我们每遍历到一个新结点，就将这个节点的值放到集合中，然后继续进行递归，由于前序遍历的顺序是根左右，因此我们总是先取出值，然后先往左递归，接着往右递归。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2af46d5a9745567944f2cd387bbe3ce2.png)

请看前序遍历的代码：

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root==null) return list;
        list.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return list;
    }
}
```

同样我们可以实现二叉树的中序遍历的代码：

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null) return list;
        inorderTraversal(root.left);
        list.add(root.val);
        inorderTraversal(root.right);
        return list;
    }
}
```

也可以实现二叉树的后序遍历

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root==null) return list;
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        list.add(root.val);
        return list;
    }
}
```

- 二叉树的迭代遍历

当然，递归属于是小试牛刀了，大家都会觉得太简单，没有难度，那么现在我们就来试试迭代遍历。前来做做前序遍历的迭代题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE966b6fdae53fe0a67939e103dddeb335.png)

在迭代遍历上，我们可以回忆下我们是怎么处理层序遍历的，那时候我们借助了队列，借助队列这个数据结构通过不断地存取我们的结点类，最终实现层序遍历，这里我们是利用到了队列先进先出的特性。而我们在前序遍历上，我们当然也要借助其他数据结构来辅助解题，这个数据结构就是栈。我们要借助栈先进后出的原理，来完成我们的前序遍历。我们每次让结点入栈，然后弹栈之后获取结点值，接着让其右节点先入栈，左节点后入栈，这样由于栈先进后出的性质，我们总是可以先处理左节点，后处理右节点，这正好是我们所需要的前序遍历的顺序

我们可以写入的代码如下（这里我们用双端队列实现栈）

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.addFirst(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollFirst();
            list.add(node.val);
            if(node.right!=null) deque.addFirst(node.right);
            if(node.left!=null) deque.addFirst(node.left);
        }
        return list;
    }
}
```

接着我们来实现我们的中序遍历，有的同学可能会觉得我还就那个改改我的代码顺序，那就完成中序遍历了，还就那个简单，但实际上不行，要问为什么，因为迭代和遍历不一样，改变顺序没有什么意义，结果还是前序遍历，屁用没有。要知道，遍历时我们改变我们的顺序，是可以很成功的改变我们的代码的逻辑的，但是迭代不同，我们简单改变其顺序，是不能和递归一样顺序完成我们代码逻辑的改变的，我们需要更加大的改动。先来看看中序遍历的题目吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE65d93f78a7b74b04a2a4ddff10fc100f.png)

我们要解决这个题目，我们首先要搞明白我们迭代的时候到底发生了什么，其实我们迭代的时候有两个动作，分别是

1. 处理：将元素放进result数组中

1. 访问：遍历节点

我们实现前序遍历的时候，我们的遍历顺序和我们处理和访问的顺序正好是一样的。我们总是先处理我们的结点，然后我们接着访问我们的结点，前序遍历的顺序是根左右，我们处理时是先拿根，后面去遍历结点，我们这里处理和访问的顺序和我们遍历的顺序正好一致，因此我们的代码可以比较简洁，也可以比较简单的实现。但是到了中序遍历那可就不一样了，因为中序遍历里，我们的顺序是左根右，那我们应该先访问到最左的叶子结点，然后取值，接着处理中间结点，然后处理右节点。这时我们处理和访问的顺序就和遍历的顺序不重合了，此时我们要想办法达到先去访问左子树的叶结点，之后再去处理我们的结点。

我们可以将我们的访问和处理分开，我们让我们的栈专门去负责我们的访问工作，同时将我们的处理情况特殊化，我们每次循环都先让我们的结点进入到左节点，然后只要左节点为空（对应左），我们再处理我们的队列中的结点（对应根），同时让我们的结点往右前进，这个动作对应我们的中序遍历里最后的右的动作（对应右），那么按照这个思路，我们可以构造代码如下

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new ArrayDeque<>();
        while (root!=null || !deque.isEmpty()){
            if(root!=null){
                deque.add(root);
                root=root.left;
            }else {
                root = deque.pollLast();
                list.add(root.val);
                root=root.right;
            }
        }
        return list;
    }
}
```

这行代码里我们要理解的是，我们这里先进行了特判，其实迭代法理论上都要进行特判，因为其无法将根结点为0的特殊情况普通化。然后我们这里不需要先将根结点压入到我们的队列中，因为我们这里再循环条件里先进行了root!=null的判断，这种处理相当于是将第一次的压入的动作也放到了循环中了，然后每次压入时，我们都是压入本结点，然后让结点往左前进（只要结点不为空），一旦结点为空，此时说明我们的左节点为null，我们就让判断的结点成为我们的从队列中弹出的结点，我们队列中弹出的结点就是我们的逻辑意义上的中间结点，然后往右前进一位就代表了最后的右的动作。

我们这里要注意，在中序遍历中，我们的root本身作为while的条件之一，同时最开始的时候不往栈中添加任何结点，所有添加结点的动作都在if成立的情况下完成，且我们总是先加入结点，后让我们的结点往左子树前进。而在else情况中，我们会让我们的结点变成栈中出来的结点并进行处理，然后令其往右前进，注意是往右前进而不是将右子节点添加到我们的栈中，这点要搞清楚。

这个逻辑意义上的左根右可能比较难理解，其实就是我们总是先处理左节点，到了空的时候也是一种左节点的处理，处理完之后就到了中间节点，然后往右节点上走，之所以采用这种有些抽象的方式去理解是因为这种方式能更好地解释我们的代码。

最后就是这个思路本身可能比较难想，没关系，想不到，现在学过了，以后起码就有点思路了

最后我们来解决后序遍历的问题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEca1ffa2728696ecef0a9f72c64435216.png)

其实关于二叉树的后序遍历，我们有一个比较讨巧的方法，就是我们知道，我们前序遍历的代码实现的遍历是根左右，那么我们只要稍加修改，这个实现的遍历就能编程根右左，然后我们只要反转我们集合里的元素，就能够得到我们所需要的左右根的集合了！

按照这个思路我们可以构造代码如下

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            list.add(node.val);
            if(node.left!=null) deque.add(node.left);
            if(node.right!=null) deque.add(node.right);
        }
        Collections.reverse(list);
        return list;
    }
}
```

这个思路虽然可行，但是它的效率属实不咋地，而且未免是有些投机取巧了，这根本就不是合格的迭代，它亵渎了迭代！后续我们是要对这个代码进行改造的，现在我们先这样吧

- 二叉树的统一迭代法

当然，我们这样左边一下，右边一下，每一题用的思路都不一样肯定不行，现在我们来学习统一的迭代方式的代码。先来看看我们的解题思路

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEad3c2507c248c0f7aeaea01714d8ac93.png)

这里我们要注意的是，如果我们的队列是以ArrayDeque实现的，那么其是不可以存入null的，否则会抛出异常。但是用链表实现是可以的。如果我们用前者实现，那么我们的标记元素应该更改为自己创建的一个元素，这样才不会发生异常。

请看前序遍历的代码

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.peekLast();
            if(node!=null){
                deque.pollLast();
                if(node.right!=null) deque.add(node.right);
                if(node.left!=null) deque.add(node.left);
                deque.add(node);
                deque.add(null);
            }else {
                deque.pollLast();
                node = deque.pollLast();
                list.add(node.val);
            }
        }
        return list;
    }
}
```

我们前序遍历是根左右，因此我们重新置入结点的方式是右左根。这里面的逻辑或许比较难理解，又或者是，理解了，但是想不到，但是我们理解不了归理解不了，记住还是可以得是吧，我们可以干脆记住这个代码，以后看到迭代就写出来，换换顺序就完了

接着是中序遍历的代码：

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.peekLast();
            if(node!=null){
                deque.pollLast();
                if(node.right!=null) deque.add(node.right);
                deque.add(node);
                deque.add(null);
                if(node.left!=null) deque.add(node.left);
            }else {
                deque.pollLast();
                node = deque.pollLast();
                list.add(node.val);
            }
        }
        return list;
    }
}
```

因为中序遍历的顺序是左根右，因此我们这里存放的顺序是右根左

最后是后序遍历的代码：

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.peekLast();
            if(node!=null){
                deque.pollLast();
                deque.add(node);
                deque.add(null);
                if(node.right!=null) deque.add(node.right);
                if(node.left!=null) deque.add(node.left);
            }else {
                deque.pollLast();
                node = deque.pollLast();
                list.add(node.val);
            }
        }
        return list;
    }
}
```

其实整体感觉下来，这种迭代方式，其实这个标记的作用就是用于模拟递归过程。其实对于二叉树而言，很多时候也的确是递归要远远好于迭代的，所以我们能用递归就尽量用递归，因为事实上，递归的确很方便。

然后对于这个统一迭代法，我们要明白的是，在统一迭代法里是用null作为标记的，每次循环我们判断我们的头结点是否为空，若为空则处理结点，不为空则按我们所需的顺序放置结点，这里我们主要记住一点，我们在循环中构建ifelse，我们总是在遇到空节点时再处理结点，否则我们都只对结点进行对应的出栈和令其子节点入栈的动作。