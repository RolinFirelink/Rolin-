那么接着我们来进行对我们的贪心算法的进一步学习，有的同学可能会觉得好像学了这么久也不见得有什么套路能一直沿用下去，确实是这样的，因为贪心本身没啥套路，主打的就是一个直觉，直觉到了就会了，没到就寄了

- 买卖股票的最佳时机 II

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE306ed5e3645bfe1da3585ae5e46a299e.png)

这题的暴力思路当然是循环计算求最大值，不过这样的话就太low了，这题还得用贪心来做。那么问题在于，我们应该怎么贪心呢？其实我们在这里的贪心思路可以很简单，我们买股票肯定希望低价格买，高价格卖出，那我们只要看哪天的价格比当天高就把股票卖出去就完了。换言之，局部最优：收集每天的正利润，全局最优：求得最大利润。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc38d34d2999cec1632e5218fd2b3dc81.png)

那么最终我们可以写出我们的代码如下

```
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==1){
            return 0;
        }
        int ans = 0,buy = -1;
        for (int i = 0; i < prices.length-1; i++) {
            if(prices[i]>=prices[i+1] && buy!=-1){
                ans+=prices[i]-buy;
                buy=-1;
            }else if(prices[i]<prices[i+1] && buy==-1){
                buy = prices[i];
            }
        }
        if(buy!=-1){
            ans+=prices[prices.length-1]-buy;
        }
        return ans;
    }
}
```

- 跳跃游戏

做完了上面简单的题目，来做一道重量级一点的题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe4849c9e92c49984c47fbeeb0d5341f1.png)

这题我们最开始的思路是我们的局部最优的贪心就是每次寻找最大的跳跃范围并跳跃，然而，这个贪心思路一开始就是错误的，每次寻找最大的跳跃范围并跳跃至下一个最大范围处的贪心思路并不能让我们精确得到最终答案，尽管我们后面对我们的代码缝缝补补甚至特判掉一个样例最终我们终于过了本题，但那也是毫无意义的，不但效率低下，而且本质上这种做法不会被认可，因为实际上你就是没做出来这题

之所以这样的贪心思路是错误的，是因为实际上很多例子就是最大的跳跃范围位置并不会是最好的跳跃位置，我们的思路一开始就是错的。

那我们这题应该要怎么贪心呢？其实我们最开始的贪心思路已经有些接近了，但是并不是最终答案，我们并不是说每次都取最大跳跃范围处跳跃，我们可以转而关心我们的能够跳跃的最大覆盖范围，如果这个覆盖范围到达了终点，那么返回true，不能我们则返回false，同时我们的移动检测范围不能超过最大的探测范围，最大探测范围应该是随着我们的for循环检测不断更新的

那么最终我们的贪心思路就是，贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE25c48adb5499407239403930ba97daba.png)

那么最终我们容易写入我们的代码如下

```
class Solution {
    public boolean canJump(int[] nums) {
        int length = nums[0];
        for (int i = 0; i < nums.length; i++) {
            if(i>length){
                break;
            }
            length = Math.max(length,nums[i]+i);
            if(length>=nums.length-1){
                return true;
            }
        }
        return false;
    }
}
```

实际上，我们还可以对我们上面的代码做进一步的简化

```
class Solution {
    public boolean canJump(int[] nums) {
        for (int i = 0,length = 0; i <= length; i++) {
            length = Math.max(length,nums[i]+i);
            if(length>=nums.length-1) return true;
        }
        return false;
    }
}
```

- 跳跃游戏 II

接着我们再来做做上一道题的升级版本，先来看看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd8a0d78dcc58ce87138becfcd0d5c826.png)

那么这题我们的贪心思路应该是怎么样的呢？我们容易注意到我们这里要求的是最小的跳跃数，同时其保证我们这里总是能跳跃到最后一位（换言之，我们不用做跳跃不到的判断了），我们的最基本的贪心思路还是跟之前一样要维护我们的最大跳跃范围，但是同时我们还要维护一个当前我们可以跳跃的最大范围，如果我们的范围到达了这个最大范围，我们就执行跳跃，同时将我们的可以跳跃的最大范围更新为当前的最大跳跃范围，同时令步数+1即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE388d009a6ea7e756b18d5d6363e34caa.png)

图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）

最后我们还需要做一个对特殊情况的判断，那就是当我们的最大覆盖范围到达了数组末尾时，此时说明我们只要再跳任意一步就可以直接到达终点，此时我们直接让步数+1然后退出循环即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE48c83094b5f22d4b28d17c025f1715ea.png)

那么最终我们可以写出我们的代码如下

```
class Solution {
    public int jump(int[] nums) {
        if(nums.length==1){
            return 0;
        }
        int maxRight = 0,nowRight = 0,ans = 0;
        for (int i = 0; i < nums.length; i++) {
            maxRight=Math.max(maxRight,nums[i]+i);
            if(maxRight>=nums.length-1){
                ans++;
                break;
            }
            if(i==nowRight){
                nowRight=maxRight;
                ans++;
            }
        }
        return ans;
    }
}
```

实际上，我们还有第二种方法，其可以将我们的特殊情况普通处理，但是那个方法比较难理解，而且说实话我也觉得能理解方法一就行了，没必要说非要去理解第二种方法，毕竟是贪心的题目，无非是写法不同，因此这里就按下不表，有兴趣的可以自己去看看

这两道题的重点都在于，我们不是每次取最大的位置进行跳跃，而是将跳跃本身转化为覆盖范围，通过覆盖范围来解题，我们以后遇上其他题目的时候也可以利用这种思路，不是每次选取最大进行跳跃，而是将题目本身的数据转化为范围，通过不断更新范围的贪心做法来进行解题

- K次取反后最大化的数组和

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc05f8f8e2c69b182231334472773d890.png)

做了前面的两道难题，我们来做一道简单的题目，这题的思路其实非常简单，我们既然要得到最大的数组和，那我们当然希望所有负数的值变为正数，那么我们首先就在k的数量范围内将我们的负数变为正数，全变完之后我们肯定是希望尽可能地对我们的正数不做变动，因此我们可以对同一个数做两次变换，这样数本身就没有任何变化，而k却减少了两次，我们可以按照这个方式直接求k/2的余数，然后我们判断k是否还有值，若无则不用处理，若有我们则将最小的正数变为负数，之后我们再统计数组的和即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbdaa5d5cbbcd36df685361c4641ce319.png)

那么我们容易写出我们的代码如下

```
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            if(k>0 && nums[i]<0){
                nums[i]*=-1;
                k--;
            }else if(nums[i]>0 || k>=0){
                break;
            }
        }
        k%=2;
        Arrays.sort(nums);
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            if(i==0 && k==1){
                nums[i]*=-1;
            }
            ans+=nums[i];
        }
        return ans;
    }
}
```

最后我们值得一提的是，我们这一题里，我们就用了两次贪心思路，第一次的贪心思路的局部最优时让绝对值大的负数变为正数，第二次的贪心思路是找最小的正整数反转其值，这里都有对应的局部最优和整体最优，我们解题的时候，哪怕再简单，也要用局部最优和整体最优的思路来思考贪心题目，将难题分解为局部最优，然后通过局部最优求出对应的解，只有这么做我们才能对贪心算法有些许思路，否则就容易陷入贪心题目靠感觉做的误区

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE25fc69cd78e6ea0cd9d8e8b5debde095.png)

最后提一嘴，就是这一题也可以使用桶排序来做，但是代码上会复杂一些，我们这里还是给出桶排序的代码

```
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        int[] arr = new int[201];
        for (int num : nums) {
            arr[num + 100]++;
        }

        for (int i = 0; i < 100; i++) {
            if(arr[i]==0){
                continue;
            }
            if(k>0){
                if(k>=arr[i]){
                    arr[(i-100)*-1+100]+=arr[i];
                    k-=arr[i];
                    arr[i]=0;
                }else {
                    arr[(i-100)*-1+100]+=k;
                    arr[i]-=k;
                    k=0;
                }
            }
        }

        k%=2;
        if(k!=0){
            for (int i = 0; i < arr.length; i++) {
                if(arr[i]!=0){
                    arr[(i-100)*-1+100]++;
                    arr[i]--;
                    break;
                }
            }
        }

        int ans = 0;
        for (int i = 0; i < arr.length; i++) {
            if(arr[i]!=0){
                ans+=(i-100)*arr[i];
            }
        }

        return ans;
    }
}
```

