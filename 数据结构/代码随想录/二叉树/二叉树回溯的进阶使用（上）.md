本章节我们来学习进一步的回溯应用，以前的题目只能说是轻量级的，现在我们就要进入我们的重量级的题目的学习了

- 二叉树的最近公共祖先

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9c227d88637100b0ab51b48df31d9cf3.png)

首先关于这题，我们如果直接做，那么我们肯定很难，但是我们可以将这种题目一步步分解，这样就比较好做。首先，我们来确定最简单的一种其最近公共祖先的情况，就是如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。这个很好理解，我们的示例1就是这种情况，然后接下来我们要解决第二种情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。此时，我们作为参数的结点本身就是题目中的最近公共祖先，

我们的递归逻辑很简单，首先我们先递归处理所有的结点，每次递归我们寻找该结点是否为空或者是我们所设定的两个结点，如果是，我们就将该结点返回，具体为如果结点为空，返回空节点，不为空且与目标结点相等，则返回目标结点，都不满足，则继续递归。

这里我们的逻辑其实是回溯，我们是先往下递归到底层，最后全部递归完毕之后我们再来对其进行相应的逻辑处理。这里我们如果遇到了目标结点我们是要返回这个节点的，所以我们肯定需要返回值，这个返回值就是结点本身。我们这里可以再来复习一下我们之前学习过的，我们做递归时什么时候需要返回值什么时候不需要，需要与否又应该要怎样处理。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcd694422b3e5db90cd08a748ebeca66f.png)

然后我们要解决的问题是，我们是要搜索一棵树呢，还是要搜索一条边呢？不过在哪之前，我们可以先来介绍下搜索一棵树和搜索一条边时我们的递归处理的代码的不同

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE36d3ce5ff8ed14251255295bab88c4da.png)

容易看出在递归函数有返回值的情况下：如果要搜索一条边且递归函数返回值不为空，立刻返回，如果搜索整个树，则用一个变量left、right接住返回值，这然后eft、right后续还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（就是回溯）。

我们这里会选择第二种做法，为什么要选择这种做法呢？直观来看，似乎我们只要找一条边的答案然后返回这个答案就可以了，类似于下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd1a936a8ba2bb1af10b4fc555a071d10.png)

但最终我们还是选择了搜索所有的树，这是因为如果我们选择搜索一棵树，就做对应的逻辑处理，那么其就会返回一个只包含一棵所需结点的父结点给我们，而这个节点不一定是我们所需要的目标结点，而且我们的判断其是否为最近公共父节点的方式是通过两个搜索得到的结果最后来共同判断的，如果我们选择第一种方式，那么我们就无法进行这样的判断了，因为这时我们只有一个我们所需的目标结点，我们自然无法做对应的判断。

那么最后我们来做回溯的处理，我们在每一个结点中都去寻找其对应的结点，然后返回我们所需要的目标结点，问题是我们应该要怎么返回呢？这里面的逻辑处理是我们现在要实现的东西。这里同样要使用到分步思考的想法，首先我们来解决最简单的一种情况，如果left 和 right都不为空，说明此时root就是最近公共节点。这个很好理解，就不多提了。问题是，如果left为空，right不为空时，我们应该怎么办呢？答案其实是如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然。这是为什么呢？请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE32da667b39f7f742061793e58524ea20.png)

具体我们来看第十的结点，此时其左边搜索不到，但是右边搜索到了一个合适的结点7，此时就返回右节点7，这也是为什么我们当一边为空时，我们要返回另一边的结点，这个内部逻辑要搞清楚

当然还有最后一种情况，就是左右都为空时，此时我们返回空就完了，这个很好理解。

最后我们来看看们的完整的递归回溯过程，如下图所示，可以看到我们是通过回溯完成的搜索，且无论我们搜索到答案与否，我们总是要对所有结点进行搜索，并且将结果返回给最初的结点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdb4eb4f88f04cd79ba53a668e747e3f4.png)

那么我们可以构造我们的代码如下

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null){
            return null;
        }
        if(root==p){
            return p;
        }
        if(root==q){
            return q;
        }
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if(left==null && right==null){
            return null;
        }else if(left!=null && right==null){
            return left;
        }else if(left==null && right!=null){
            return right;
        }else {
            return root;
        }
    }
}
```

这一份代码还可以继续精简，其精简代码如下，就是将最初的结束条件总和到了一起

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) { // 递归结束条件
            return root;
        }

        // 后序遍历
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if(left == null && right == null) { // 若未找到节点 p 或 q
            return null;
        }else if(left == null && right != null) { // 若找到一个节点
            return right;
        }else if(left != null && right == null) { // 若找到一个节点
            return left;
        }else { // 若找到两个节点
            return root;
        }
    }
}
```

最后是一个没啥意义的只追求短的代码

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || root==p || root==q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left==null && right==null) return null;
        else if(left!=null && right==null) return left;
        else if(left == null) return right;
        else return root;
    }
}
```

这个思路，看多了自然也就理清了。这个时候有的同学会说，你这谁寄吧会啊，我承认，的确未必做了这题就会以后的题目，但起码我们能学个思路不是，下次遇上这种题目起码有个大概感觉是吧

迭代的代码就不给了，迭代我不知道怎么搞出这种回溯的效果来说实话。

- 二叉搜索树的最近公共祖先

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd0ff417664947666f86edb16c0474ad8.png)

解决完了第一题之后，我们现在来解决其简单版本的题目，虽然说是简单版本，但如果希望效率达到百分百，那还是不容易的。我们这里要充分利用其实二叉搜索树的特性，那么在二叉搜索树的情况下，其最近的公共父节点又是哪个呢？其实只要节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。根据这个思路，我们很容易就可以做出我们的递归代码如下

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```

如果要加深理解的话，我们不妨对着这张图来看看，自己演示一遍就能理解了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0a7643349104ccf4a0d97d9ddf2d7d09.png)

最后我们来看看其迭代的代码，非常好理解这个，不多说了

```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || root==p || root==q){
            return root;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            if(node.val<p.val && node.val<q.val){
                deque.add(node.right);
            }else if(node.val> p.val && node.val> q.val){
                deque.add(node.left);
            }else {
                return node;
            }
        }
        return root;
    }
}
```

- 二叉树搜索树中的插入操作

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE98dc37f6daf691ff3eb680c362e03664.png)

这个其实没什么特别好说的，这个很好做其实，几乎没什么难度可言，直接看代码吧

首先我们来看看递归代码

```
class Solution {
    int val;
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null){
            return new TreeNode(val);
        }
        this.val=val;
        dfs(root);
        return root;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        if(root.val<val){
            if(root.right!=null){
                dfs(root.right);
            }else {
                root.right=new TreeNode(val);
            }
        }else {
            if(root.left!=null){
                dfs(root.left);
            }else {
                root.left=new TreeNode(val);
            }
        }
    }
}
```

然后我们来看看迭代的代码

```
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null){
            return new TreeNode(val);
        }
        TreeNode node = root;
        while (true){
            if(node.val<val){
                if(node.right!=null){
                    node=node.right;
                }else {
                    node.right=new TreeNode(val);
                    break;
                }
            }else {
                if(node.left!=null){
                    node=node.left;
                }else {
                    node.left=new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
}
```

最后是通过构造新的二叉树来完成本题的代码

```
class Solution {
    TreeNode ans = null;
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null){
            return new TreeNode(val);
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.add(root);
        while (!deque.isEmpty()){
            TreeNode node = deque.poll();
            ans = dfs(ans, node.val);
            if(node.left!=null){
                deque.add(node.left);
            }
            if(node.right!=null){
                deque.add(node.right);
            }
        }
        dfs(ans,val);
        return ans;
    }

    private TreeNode dfs(TreeNode node, int val) {
        if(node==null){
            return new TreeNode(val);
        }
        if(node.val<val){
            node.right=dfs(node.right,val);
        }else {
            node.left=dfs(node.left,val);
        }
        return node;
    }
}
```

- 删除二叉搜索树中的结点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa63d283972c0ddbe36eb20cee81c23b5.png)

