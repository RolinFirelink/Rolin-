接下来我们来学习菜品展示以及相关购买业务的开发，首先我们来开发我们的菜品展示的相关功能

- 地址相关业务开发

在正式做我们的菜品展示的相关功能之前，我们要先将地址簿功能给开发了，首先我们来做地址簿功能的需求分析，首先我们来分析下其拥有的功能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3d35eb6aaa10d867ab163a7c276da1bc.png)

然后我们来看看我们的用户拥有的信息表，这里拥有的字段很多，但是其实需要我们填充的只有前面的打√的几个，后面的字段都可以不填充

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15d1bb96a48660eb68c6a7e49daeec61.png)

然后我们来看看我们的构造地址簿的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1ce4707fa337415aef464bb105311e82.png)

我们首先做经典的MP三层调用配置，这一段我们就省略了，然后我们首先来完成我们的展示我们的所有收货地址的方法，首先我们去我们的地址管理可以看到其请求地址是addressBook且连接list，是GET方式请求

本来这玩意课程要求直接导入就完了，但我还是自己去试着开发了下，结果就是处处出错，对了下答案发现不是我的逻辑有问题，而是前端需要的东西就没有传送对，我可懒得去分析前端的玩意，我直接进行一个复制就完了

我们这里首先来分析下我们的查询所有的方法，这里前端需要的是地址的集合对象，我们这里的逻辑就是查出所有地址并封装到集合对象中，这里调用的是MP提供的list方法实现将地址封装到集合中的操作

```
/**
 * 查询指定用户的全部地址
 */
@GetMapping("/list")
public R<List<AddressBook>> list(AddressBook addressBook) {
    addressBook.setUserId(BaseContext.getCurrentId());
    log.info("addressBook:{}", addressBook);

    //条件构造器
    LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());
    queryWrapper.orderByDesc(AddressBook::getUpdateTime);

    //SQL:select * from address_book where user_id = ? order by update_time desc
    return R.success(addressBookService.list(queryWrapper));
}
```

然后我们来说下新增的方法，我们这里新增前要先设置执行新增操作的用户id在地址中，我们这里利用之前我们学习过的公共字段自动填充的知识，利用我们之前添加的工具类来获得当前用户的id并设置，然后执行保存操作，最后返回这个新增的对象到前端中

```
/**
 * 新增
 */
@PostMapping
public R<AddressBook> save(@RequestBody AddressBook addressBook) {
    addressBook.setUserId(BaseContext.getCurrentId());
    log.info("addressBook:{}", addressBook);
    addressBookService.save(addressBook);
    return R.success(addressBook);
}
```

然后是根据id查询地址的方法，逻辑非常简单，不多提了

```
/**
 * 根据id查询地址
 */
@GetMapping("/{id}")
public R get(@PathVariable Long id) {
    AddressBook addressBook = addressBookService.getById(id);
    if (addressBook != null) {
        return R.success(addressBook);
    } else {
        return R.error("没有找到该对象");
    }
}
```

接着是设置默认地址的方法，这个方法就有点重量级了，逻辑上比较绕，我们这里重点说一下，我们这里首先取出当前用户的所有的地址数据，将其所有的默认地址的数值都改为0，即是否，接着再将其对应要修改的地址改为1，最终返回这个修改的对象

```
/**
 * 设置默认地址
 */
@PutMapping("default")
public R<AddressBook> setDefault(@RequestBody AddressBook addressBook) {
    log.info("addressBook:{}", addressBook);
    LambdaUpdateWrapper<AddressBook> wrapper = new LambdaUpdateWrapper<>();
    wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());
    wrapper.set(AddressBook::getIsDefault, 0);
    //SQL:update address_book set is_default = 0 where user_id = ?
    addressBookService.update(wrapper);

    addressBook.setIsDefault(1);
    //SQL:update address_book set is_default = 1 where id = ?
    addressBookService.updateById(addressBook);
    return R.success(addressBook);
}
```

然后是查询默认地址的方法，这也没啥好说的

```
/**
 * 查询默认地址
 */
@GetMapping("default")
public R<AddressBook> getDefault() {
    LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());
    queryWrapper.eq(AddressBook::getIsDefault, 1);

    //SQL:select * from address_book where user_id = ? and is_default = 1
    AddressBook addressBook = addressBookService.getOne(queryWrapper);

    if (null == addressBook) {
        return R.error("没有找到该对象");
    } else {
        return R.success(addressBook);
    }
}
```

- 菜品展示

接着我们来开发菜品展示功能，首先我们来做一个基本的需求分析，来看看我们的菜品都需要些啥玩意

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE83898cab54a7d220a9305f5075788961.png)

首先我们可以看到我们的菜品展示中是有分类数据的，这个分类方法其实我们之前就已经做好了，实际上这里也发送了对应的请求然后获得了对应的数据，但是为什么我们进入到首页得到的页面是一片空白呢？这其实是因为我们的前端代码里设置了我们进入页面就会向服务器发送两个请求，前者请求分类数据，后者请求购物车数据，只有两者都成功执行才能正确展示界面，但我们这里连购物车的代码都没实现呢，那肯定没法展示了，我们这里为了先让我们的代码展示起来，所以我们这里先将请求购物车数据的代码改为请求一个我们自己编写的实体数据，这样可以简单骗过前端，当然后期肯定是要修改的

别忘了要刷新我们浏览器的缓存，否则我们的手机端页面的请求是不会改变的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE67066b919a99854f161dd6edeb6bdc25.png)

然后我们进入页面，就可以看到我们的分类的菜品的展示数据了，这里我们进入页面就会请求到我们的分类数据，然后点击具体的分类又会请求对应分类的菜品数据

但是我们这里还有一个小问题，那就是我们这里并不会展示我们的口味选择，我们最开始的需求是，如果我们的菜品有各种口味的选择，但我们这里是没有展示的，究其原因是因为我们最开始返回的数据里就没有口味的属性，所以我们这里要对我们的获取菜品数据的代码进行一个修改

容易看到我们的Dto对象是有对应的口味属性的，所以我们希望其返回这个对象

```
package com.itheima.reggie.dto;

import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.entity.DishFlavor;
import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDto extends Dish {

    //菜品对应的口味数据
    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;

    private Integer copies;
}

```

那么我们可以修改我们的代码如下，我们这里突出的就是一个复制，然后查询数据库之后再次赋值到新对象中，能成但是效率不咋地

```
/**
 * 根据条件查询菜品数据
 * @param dish
 * @return
 */
@GetMapping("/list")
public R<List<DishDto>> list(Dish dish){

    //构造查询条件
    LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId());
    //添加条件，查询状态为1（启售状态）的菜品
    queryWrapper.eq(Dish::getStatus,1);
    //添加排序条件
    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);

    List<Dish> list = dishService.list(queryWrapper);

    List<DishDto> dishDtoList = list.stream().map((item) ->{
        DishDto dishDto = new DishDto();

        BeanUtils.copyProperties(item,dishDto);

        Long categoryId = item.getCategoryId();//分类id
        //根据id查询分类对象
        Category category = categoryService.getById(categoryId);

        if(category != null){
            String categoryName = category.getName();
            dishDto.setCategoryName(categoryName);
        }

        //当前菜品的id
        Long dishId = item.getId();
        LambdaQueryWrapper<DishFlavor> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);
        //SQL:select * from dish_flavor where dish_id = ?
        List<DishFlavor> dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);
        dishDto.setFlavors(dishFlavorList);
        return dishDto;
    }).collect(Collectors.toList());

    return R.success(dishDtoList);
}
```

接着我们要实现的套餐的查询，我们的套餐数据是发送的另外一个请求，是在套餐控制层里发送的请求，但我们这里压根没有这个映射，因此我们这里要自己构造这份代码，那么我们容易写入其代码如下，我们这里就查询对应的分类和在启售状态中的套餐并展示

```
@GetMapping("/list")
public R<List<Setmeal>> list(Setmeal setmeal){
    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(setmeal.getCategoryId() != null,Setmeal::getCategoryId,setmeal.getCategoryId());
    queryWrapper.eq(setmeal.getStatus() != null,Setmeal::getStatus,setmeal.getStatus());
    queryWrapper.orderByDesc(Setmeal::getUpdateTime);

    List<Setmeal> list = setmealService.list(queryWrapper);

    return R.success(list);
}
```

那么到此为止，我们的菜品展示的代码就开发完了

- 购物车功能开发

 接着我们来开发我们的购物车功能，首先我们来看看我们的需求分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6a1d16669eb7c5561ed84841ab47a85f.png)

然后我们来看看我们购物车与服务器间的交互过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2212e692da757305117f0699ad734a63.png)

然后我们来看看其准备工作

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE313f775f5e07dd0616acadfa5b7be8ca.png)

整完了准备工作之后，我们容易写出我们的添加套餐或者是菜品到购物车中的代码如下，这里的逻辑是先将用户ID设置到购物车对象中，然后我们查询当前的菜品是否在购物车中，我们这里查询的方式是直接获取菜品的id，如果为空则说明是套餐，不为空则说明是菜品，两种不同的情况我们都设置不同的比较条件，然后我们统一往数据库中查出一个对象，若该对象为空，则说明数据库中没有该数据，此时我们执行插入操作，若有，我们执行更新操作，令其数量+1即可

```
/**
 * 购物车
 */
@Slf4j
@RestController
@RequestMapping("/shoppingCart")
public class ShoppingCartController {

    @Autowired
    private ShoppingCartService shoppingCartService;

    /**
     * 往购物车里添加菜品或套餐
     * @param shoppingCart
     * @return
     */
    @PostMapping("/add")
    public R<ShoppingCart> add(@RequestBody ShoppingCart shoppingCart){
        log.info("购物车数据:{}",shoppingCart);

        //设置用户id，指定当前是哪个用户的购物车数据
        Long currentId = BaseContext.getCurrentId();
        shoppingCart.setUserId(currentId);

        //查询当前菜品或者套餐是否在购物车中
        Long dishId = shoppingCart.getDishId();

        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,currentId);

        if(dishId != null){
            //添加到购物车的是菜品
            queryWrapper.eq(ShoppingCart::getDishId,dishId);
        }else {
            //添加到购物车的是套餐
            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
        }

        //SQL:select * from shopping_cart where user_id ? and dish_id/setmeal_id = ?
        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);

        if(cartServiceOne != null){
            //如果已经存在，就在原来数量的基础上加一
            Integer number = cartServiceOne.getNumber();
            cartServiceOne.setNumber(number + 1);
            shoppingCartService.updateById(cartServiceOne);
        }else {
            //如果不存在则添加到购物车中，其数量默认为一
            shoppingCart.setNumber(1);
            shoppingCartService.save(shoppingCart);
            cartServiceOne = shoppingCart;
        }

        return R.success(cartServiceOne);
    }
}
```

然后我们来开发减少购物车中菜品数量的代码，这种代码其实也非常简单，跟我们的新增的代码差不多，我们这里的逻辑同样是先判断是菜品还是套餐，然后查询处对应的数据，接着我们判断其数量是否为1，若为1则直接删除，反之则更新其数量，令其数量-1，最后返回对应对象的结果

```
/**
 * 减少购物车中菜品数量
 * @param shoppingCart
 * @return
 */
@PostMapping("/sub")
public R<ShoppingCart> subtract(@RequestBody ShoppingCart shoppingCart){
    log.info("购物车数据:{}",shoppingCart);

    //设置用户id，指定当前是哪个用户的购物车数据
    Long currentId = BaseContext.getCurrentId();
    shoppingCart.setUserId(currentId);

    //查询当前菜品或者套餐是否在购物车中
    Long dishId = shoppingCart.getDishId();

    LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,currentId);

    if(dishId != null){
        //添加到购物车的是菜品
        queryWrapper.eq(ShoppingCart::getDishId,dishId);
    }else {
        //添加到购物车的是套餐
        queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
    }

    //SQL:select * from shopping_cart where user_id ? and dish_id/setmeal_id = ?
    ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);
    int num = cartServiceOne.getNumber();

    if(num != 1){
        //如果数量大于1，则在原先的数量上执行-1的更新操作
        Integer number = cartServiceOne.getNumber();
        cartServiceOne.setNumber(number - 1);
        shoppingCartService.updateById(cartServiceOne);
    }else {
        //若数量为1，则直接删除
        shoppingCartService.remove(queryWrapper);
        cartServiceOne = shoppingCart;
    }

    return R.success(cartServiceOne);
}
```

然后是我们的查看购物车的方法，我们这里无非是根据id查出所有的结果，然后封装到一个集合中返回给前端就行了

```
/**
 * 查看购物车
 * @return
 */
@GetMapping("/list")
public R<List<ShoppingCart>> list() {
    log.info("查看购物车...");

    LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());
    queryWrapper.orderByDesc(ShoppingCart::getCreateTime);

    List<ShoppingCart> list = shoppingCartService.list(queryWrapper);

    return R.success(list);
}
```

最后是清空购物车的方法，这个非常简单，直接根据id移除所有菜品即可

```
/**
 * 清空购物车
 * @return
 */
@DeleteMapping("/clean")
public R<String> clean(){
    //SQL:delete from shopping_cart where user_id = ?

    LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());

    shoppingCartService.remove(queryWrapper);

    return R.success("清空购物车成功");
}
```

- 用户下单相关业务开发

最后我们来实现用户下单的相关业务开发，首先我们要实现的下单这个功能的开发，先来看看我们的需求分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5b6a2017cd3c239585699e4e2441340e.png)

然后我们来看看我们的数据模型

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE07db2f7b51231d838303693df33b34a1.png)

订单表里保存着订单的大概信息

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE57807e8b63715f5dda049c5eafda7556.png)

订单明细表则保存订单的详细信息包括点的菜品，套餐分别都是啥之类的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0f3ab66b319b4c9ef529fa78eb17f109.png)

接着我们来看看我们用户下单的交互过程，这里的交互过程其实挺多的，但是我们之前已经完成了大多数了，这里调用的都是之前的方法，所以除了最后一个请求之外我们其他的都不用去理会了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9bafb9656f8a2da118ddf0055c4aaad0.png)

接着我们来做代码开发的准备工作，这一部分的内容我们就省略了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe2e5c7b3985ceea3196cb8ddccfa7c85.png)

由于下单的方法比较繁琐，因此我们新创建一个方法来完成这个请求

```
/**
 * 用户下单
 * @param orders
 */
public void submit(Orders orders);
```

然后我们在下面实现这个方法，前端传过来的内容里的数据可以用一个订单对象承接到，因此我们这里使用该对象承接，接着我们查询对应的购物车数据，用户数据，用户地址数据用于下面的下单功能的实现，由于我们的订单需要一个id，所以我们这里调用MP提供的工具类随机生成一个id，然后我们要统计下单金额，而正好我们的下单内容里还需要将具体数据保存到我们的订单明细表中，因此我们用stream流的形式构建这么一个对应的集合，我们这里使用我们的AtomicInteger对象来统计，这个对象在多线程高并发的情况下也有良好的表现，所以我们用这个对象

接着中间的一大堆的有的没的设置内容我们就不提了，都是些没什么含金量的内容，我们这里直接复制即可，最后我们往订单表和订单明细表中插入数据即可，插入之后我们则是下单完成，别忘了此时要清空购物车的数据

```
@Service
@Slf4j
public class OrdersServiceImpl extends ServiceImpl<OrdersMapper, Orders> implements OrdersService {

    @Autowired
    private ShoppingCartService shoppingCartService;

    @Autowired
    private UserService userService;

    @Autowired
    private AddressBookService addressBookService;

    @Autowired
    private OrderDetailService orderDetailService;

    /**
     * 用户下单
     * @param orders
     */
    @Override
    @Transactional
    public void submit(Orders orders) {
        //获得当前用户id
        Long currentId = BaseContext.getCurrentId();

        //查询当前用户的购物车数据
        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,currentId);
        List<ShoppingCart> shoppingCarts = shoppingCartService.list(queryWrapper);

        if(shoppingCarts == null || shoppingCarts.size()==0){
            throw new CustomException("购物车为空，不能下单");
        }

        //查询用户数据
        User user = userService.getById(currentId);

        //查询地址数据
        Long addressBookId = orders.getAddressBookId();
        AddressBook addressBook = addressBookService.getById(addressBookId);

        if(addressBook == null){
            throw new CustomException("用户地址信息有误，不能下单");
        }

        long orderId = IdWorker.getId();

        AtomicInteger amount = new AtomicInteger(0);

        List<OrderDetail> orderDetails = shoppingCarts.stream().map((item) ->{
            OrderDetail orderDetail = new OrderDetail();
            orderDetail.setOrderId(orderId);
            orderDetail.setNumber(item.getNumber());
            orderDetail.setDishFlavor(item.getDishFlavor());
            orderDetail.setDishId(item.getDishId());
            orderDetail.setSetmealId(item.getSetmealId());
            orderDetail.setName(item.getName());
            orderDetail.setImage(item.getImage());
            orderDetail.setAmount(item.getAmount());
            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());
            return orderDetail;
        }).collect(Collectors.toList());

        orders.setId(orderId);
        orders.setOrderTime(LocalDateTime.now());
        orders.setCheckoutTime(LocalDateTime.now());
        orders.setStatus(2);
        orders.setAmount(new BigDecimal(amount.get()));//总金额
        orders.setUserId(currentId);
        orders.setNumber(String.valueOf(orderId));
        orders.setUserName(user.getName());
        orders.setConsignee(addressBook.getConsignee());
        orders.setPhone(addressBook.getPhone());
        orders.setAddress((addressBook.getProvinceName() == null ? "" : addressBook.getProvinceName())
                + (addressBook.getCityName() == null ? "" : addressBook.getCityName())
                + (addressBook.getDistrictName() == null ? "" : addressBook.getDistrictName())
                + (addressBook.getDetail() == null ? "" : addressBook.getDetail()));

        //向订单表插入一条数据
        this.save(orders);

        //向订单明细表中插入一条或多条数据
        orderDetailService.saveBatch(orderDetails);

        //清空购物车数据
        shoppingCartService.remove(queryWrapper);
    }
}

```

最后我们在对应的控制层中调用我们创建的方法即可

```
/**
 * 用户下单
 * @param orders
 * @return
 */
@PostMapping("/submit")
public R<String> submit(@RequestBody Orders orders){
    log.info("订单数据:{}",orders);
    ordersService.submit(orders);
    return R.success("下单成功");
}
```

