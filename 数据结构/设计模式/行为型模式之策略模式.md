现在我们来学习策略模式，先来看看策略模式的概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0b4e4c01f0da85490710e31a95f6ec94.png)

简而言之是，我们可以选择的策略可以有很多，但是我们最终的目的总是一样的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb14151aaae814aef92d93062016575f8.png)

同样我们是用一个案例来加深我们的理解，来看看案例需求和类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE35073406983b61ac99aa8952a50d672f.png)

首先我们创建抽象策略内，内部存放对应的抽象策略方法

```
public interface Strategy {
    void show();
}
```

然后创建具体的策略类，当然要实现我们的具体策略

```
public class StrategyA implements Strategy{

    @Override
    public void show() {
        System.out.println("买一送一");
    }
}
```

然后是我们的环境对象，其内部应该聚合策略类对象

```
public class SalesMan {

    //聚合策略类对象
    private Strategy strategy;

    public SalesMan(Strategy strategy) {
        this.strategy = strategy;
    }

    //由促销员展示促销活动给用户
    public void salesManShow() {
        strategy.show();
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
}
```

接着我们在对应的测试类中写入代码如下，可以得到我们想要的结果，能够正确调用不同的策略

```
public class Client {
    public static void main(String[] args) {
        //春节来了，使用策略1
        SalesMan salesMan = new SalesMan(new StrategyA());
        salesMan.salesManShow();

        salesMan.setStrategy(new StrategyB());
        salesMan.salesManShow();

        salesMan.setStrategy(new StrategyC());
        salesMan.salesManShow();
    }
}
```

然后我们来看看策略模式的优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4ee6596a6dac801540d8b5d872b2cf49.png)

- JDK源码解析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd7cffd03626a95e4b5d7728f707b5872.png)

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeb1d5607d3afcff72922f0115b609671.png)

直接记忆重点，我们的Arrays.sort方法使用了策略模式即可