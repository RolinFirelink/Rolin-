接着我们来学习创建者模式中的原型模式，该原型模式是通过复制原型对象来创建一个和原型相同的新对象，并通过该对象的功能来实现我们的需求

原型模式中必须拥有抽象原型类、具体原型类和访问类，更加详细的信息请看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0884183a87a6fc7d196fd8a49dcf524c.png)

这里我们值得一提的是，克隆分为浅克隆和深克隆。前者指的是对于被克隆的对象的引用类型的属性，其仍然指向同一个地址，而对于后者而言，其是创建了一个新对象同时其中为引用变量的属性也会被克隆，会指向不同的地址。但是不管是哪个克隆方式，被克隆的对象都会是一个全新的对象，会存放在另一个不同的内存地址

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd3d6b2019800889989bf5a918e2a821a.png)

而java中提供了clone方法来实现浅克隆，那么我们可以写入我们的代码如下

```
public class Realizetype implements Cloneable{

    public Realizetype() {
        System.out.println("具体原型对象创建成功");
    }

    @Override
    protected Realizetype clone() throws CloneNotSupportedException {
        System.out.println("具体原型复制成功");
        return (Realizetype) super.clone();
    }
}
```

首先我们创建一个Realizetype类令其实现Cloneable接口（规定克隆的类必须实现该接口，否则无法克隆），然后我们重写其克隆方法即可，当然，我们这里的重写其实也是直接调用父类的克隆方法，实际上也没重写

最后我们在测试类中写入我们的代码如下，最后的结果为false

```
public class client {
    public static void main(String[] args) throws CloneNotSupportedException {
        //创建一个原型类对象
        Realizetype realizetype = new Realizetype();

        //调用Realizetype类中的clone方法进行对象的克隆
        Realizetype clone = realizetype.clone();

        System.out.println(clone == realizetype);
    }
}
```

从上面我们会发现，自己创建的对象的方法和克隆对象的方法并不是一个方法，克隆的方法是另外的方法，而创建对象的方法则是构造方法，这两者不存在联系，且最终创造出的两个对象的地址也是不同的

接着我们来实现原型模式实现一个三好学生对象的案例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE493f81a6362dd43bd8eed5c913f1ce8d.png)

首先我们创建这么一个三好学生对象，然后我们给其添加一个属性对象，令其实现Cloneable接口，然后重写clone方法，接着设置对应的setandget方法，最后提供一个展示其用户名的show方法

```
public class Citation implements Cloneable{

    //三好学生上的姓名
    private String name;

    @Override
    protected Citation clone() throws CloneNotSupportedException {
        return (Citation) super.clone();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Citation() {
    }

    public Citation(String name) {
        this.name = name;
    }

    public void show(){
        System.out.println(name+"是三好学生");
    }
}
```

然后我们在测试方法中创建原型对象并克隆新对象，然后给其分别设置上名字，接着调用其用于展示的show方法，然后我们可以看到这两个三好学生的对象都显示了不同的名字，此时就说明的克隆方法是成功的

```
public class client {
    public static void main(String[] args) throws CloneNotSupportedException {
        //1.创建原型对象
        Citation citation = new Citation();
        //2.克隆奖状对象
        Citation clone = citation.clone();

        citation.setName("张三");
        clone.setName("李四");

        //3.调用show方法展示
        citation.show();
        clone.show();
    }
}
```

那么我们什么时候需要使用原型模式呢？在下面的两种场景下，我们推荐使用原型模式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcaebc5178d20b5f42db13d7162c620d9.png)

有人可能会说，String不是也是引用变量吗？为啥没有被一起修改啊？他们指向的内存地址不是一样的吗？那为啥我们这里修改了名字之后结果两个对象输出的名字不是一样的啊？这就涉及到String这个引用类型的特性的，具体可以见这篇文章的解释https://blog.csdn.net/SJB2MLN/article/details/74910223，简单来说就是我们创建不一样的字符串，会产生一个全新的引用类型的对象，然后这个对象的内存地址会被赋值到字符串属性上，所以在这种情况下，这两个字符串的内存对象已经被改变了，从原来的同一个字符串对象已经改为了两个不同的字符串对象

接着我们来构造一个场景来模拟一下浅克隆会产生的问题，首先我们创建一个学生对象，并实现其对应的方法

```
public class Student {

    //学生姓名
    private String name;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Student() {
    }

    public Student(String name) {
        this.name = name;
    }
}

```

然后我们写入其测试类代码如下

```
public class client {
    public static void main(String[] args) throws CloneNotSupportedException {
        //1.创建原型对象
        Citation citation = new Citation();

        //创建学生对象
        Student student = new Student();
        student.setName("张三");
        citation.setStu(student);

        //2.克隆奖状对象
        Citation clone = citation.clone();
        Student stu = clone.getStu();
        stu.setName("李四");

        //3.调用show方法展示
        citation.show();
        clone.show();
    }
}
```

我们这里最终显示的结果就会是两个都是李四是三好学生，这是因为我们创建的两个对象的内部指向的是同一个学生对象，这样我们修改其内部引用对象的属性最终会导致两个对象都发生变动，此时产生的结果就不是我们想要的

要想要解决这个问题，我们就要使用深克隆，我们可以用输入输出流的方式来实现深克隆，最终我们得到的对象就会是完完全全的全新的两个对象，就连其下的引用变量的地址也是全新的地址

```
public class client {
    public static void main(String[] args) throws Exception {
        //1.创建原型对象
        Citation citation = new Citation();

        //创建学生对象
        Student student = new Student();
        student.setName("张三");
        citation.setStu(student);

        //创建对象输出流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("d:/robin/a.txt"));
        //写对象
        oos.writeObject(citation);
        //释放资源
        oos.close();

        //创建对象输入流
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("d:/robin/a.txt"));
        //读取对象
        Citation clone = (Citation) ois.readObject();
        //释放资源
        ois.close();

        Student stu = citation.getStu();
        stu.setName("李四");

        //3.调用show方法展示
        citation.show();
        clone.show();
    }
}
```

> 注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。

