那么学习完顺序表与链表之后，现在我们来学习栈的数据结构，在古代，栈其实就是客栈，基本作用是等用户来吃饭睡觉，酒足饭饱之后，再离开客栈，这是现实生活里的客栈

接着我们来看看计算机语言中的栈

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8e926439e2cdd7323b2e663b7caa1581.png)

栈是一种基于先进后出(FILO)的数据结构，FILO是First in last out的缩写，也就是先进后出的英文缩写。我们称数据进入栈的动作为压栈，数据从栈中出去的动作为弹栈

简单讲解完原理之后，我们来看看栈的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0a77c915d96b50f4c8c40488709bd0db.png)

首先我们要明确一点，栈是一种逻辑层面的数据结构，他将数据存储到计算机内部，其是要用到物理存储结构来存储数据的，而物理存储结构分为顺序存储结构和链式存储结构，也就是数组或者链表。这里我们采用链表的形式来去实现，课后如果自己有想法可以用数组的形式自己去实现下

由API设计我们可以实现栈的代码如下，注意这里我们已经实现了其遍历方法了

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class Stack<T> implements Iterable{
    //记录首结点
    private Node head;
    //栈中元素的个数
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }

    //栈的构造方法，调用该方法将创造一个数据内容为null的结点对象并将引用传递给head
    public Stack() {
        this.head = new Node(null,null);
        this.N=0;
    }

    //判断当前栈中元素的个数是否为0
    public boolean isEmpty(){
        return N==0;
    }

    //获取栈中元素的个数
    public int size(){
        return N;
    }

    //把t元素压入栈

    /*
     *该方法的原理是不断往链表里增加元素，如果增加的结点为1，那么就
     * 让新结点被首结点指向，如果不为1，则让首结点指向该新结点，同时
     * 该新结点指向原来的旧结点。这里就模仿了栈的数据的先进后出特点，
     * 我们只要按照上述方式来构建链表，那么等到我们遍历时，我们的链表
     * 所遍历的元素会先从最后一个加入的元素遍历到我们第一个加入的元素
     */
    public void push(T t){
        //找到首结点指向的第一个结点，并将其赋予给oldFirst
        //私以为这里有问题，运行时会发生空指针异常
        //但实际却没有发生空指针问题，我感到无法理解
        Node oldFirst = head.next;
        //创建新结点
        Node newNode = new Node(t,null);
        //让首结点指向新结点
        head.next = newNode;
        //让新结点指向原来被首结点指向的旧结点
        newNode.next=oldFirst;
        //元素个数+1
        N++;
    }

    //弹出栈顶元素
    public T pop(){
        //找到首结点指向的第一个结点，并将该结点用oldFirst保存
        Node oldFirst = head.next;
        //如果oldFirst为null则直接返回null，不必再做判断
        //这里代表的意思是已经取到底了，没有元素可以取了
        if(oldFirst==null){
            return null;
        }
        //让首结点指向原来的第一个结点的下一个结点
        head.next=oldFirst.next;
        //元素个数-1
        N--;
        return oldFirst.item;
    }

    @Override
    public Iterator iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private Node n;

        public SIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
```

那么到此为止，我们栈的数据结构就讲完了，接着我们来看看关于栈的一些应用案例

栈数据结构最简单的应用案例就是括号匹配问题

我们先来简单看看括号匹配问题的描述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE888375380758ed7da4a8b6e2fbf3a7c3.png)

那么我们应该怎么去解决这种问题呢？其实我们的思路很简单，我们只要对这个字符串进行遍历，如果我们检测到左括号，那么我们就将其压栈，如果我们检测到右括号，我们就进行弹栈，如果弹栈弹出的结点不为空，就说明右括号有左括号为之对应，如果为空则说明有括号不对应，那么我们直接返回false。遍历完之后我们检查栈中还有没有元素，若没有则说明该括号匹配，若有则说明还有括号是没有对应的右括号进行匹配的，这时我们也返回false

那么我们可以构建代码如下

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        String str = "(())";
        System.out.println(isMatch(str));//true
    }

    public static boolean isMatch(String str){
        //1.创建栈对象，用于存储左括号
        Stack<String> chars = new Stack<>();
        //2.从左往右遍历字符串
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i)+"";
            //在char类型后加个空字符串能够自动将该类型转换成String类型

            //3.判断当前字符是否为左括号，若是则将该左括号入栈
            if(currChar.equals("(")){
                chars.push(currChar);
            }else if(currChar.equals(")")){
                //继续判断其是否为右括号，若是则进行弹栈
                String pop = chars.pop();
                //判断弹栈的内容是否为null，是则说明没有对应的左括号，直接返回false
                if(pop==null){
                    return false;
                }
            }
        }
        //5.判断栈中还有没有剩余的左括号，若有则说明括号不匹配
        if(chars.size()==0){
            return true;
        }else {
            return false;
        }
    }
}
```



逆波兰表达式

刚刚我们用栈解决了括号的匹配问题，那么现在我们就要学习如何用栈数据结构来解决逆波兰表达式的计算问题，要想搞明白什么是逆波兰表达式，我们要先搞清楚什么是中缀表达式，且看中缀表达式的定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd9006df0a2cd5c2fdc88038d8aaf6586.png)

中缀表达式的特点是两个运算符总是放在操作数的中间，这是我们人类计算最爱使用的运算表达式，但是对于计算机而言，这种表达式要进行大量的优先级相关操作，因此对于计算机来说，中缀表达式是不友好的，因此在计算机语言里我们要使用逆波兰表达式来代替中缀表达式

现在让我们来看看逆波兰表达式的定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc771a2b22e6877e68b5b83e18d789f11.png)

逆波兰表达式的运算原理在于将二元运算符前面两个值进行运算然后生成一个新的值，接着如果后续还有二元运算符，那么就拿这个新的值与其最靠近二元运算符的值进行运算，讲起来可能很不明朗，直接举例就行了

比如对于abc-d*+而言，是先进行b-c，设结果为p，那么继续进行p*d的运算，结果设为q，最后再进行a+q的运算，最后就能得到结果

对于abc-*d+而言，先进行b-c的运算，设为p，再进行a*p的运算，设为q，最后进行q+d的运算，最后就能得到结果

那么接下来如果我们要设置一个方法用于计算逆波兰表达式的值，那我们应该怎么构建我们的代码呢？

我们可以先遍历整个逆波兰表达式，判断每一个字符是否为运算符，若不是则入栈，若是则弹出两个操作数，然后计算这两个操作数之后再将这两个操作数的结果进行入栈，就这样不断进行遍历，到最后栈中必然剩余一个总和结果，那个结果就是我们的逆波兰表达式的值

请看原理图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE63cd4034382807480d1d163ded1b5fbe.png)

按照原理图，我们可以构建代码如下

```javascript
package algorithm.sort;

public class test {
    public static void main(String[] args) {
        String[] notation = {"3","17","15","-","*","18","6","/","+"};
        System.out.println(caculate(notation));//9
    }

    public static int caculate(String[] notaion){
        //1.定义一个栈，用于储存操作数
        Stack<Integer> oprands = new Stack<>();
        //2.遍历逆波兰表达式，得到每一个元素
        for (int i = 0; i < notaion.length; i++) {
            //取出逆波兰表达式里的对应值并保存在字符串curr中
            String curr = notaion[i];
            //定义三个用于取出栈中元素和保存其计算值的Integer变量
            //之所以定义在这里是因为在Switch里不能重复定义
            //如果在Switch里定义的话会因为重复定义而报错
            Integer o1,o2,result;
            switch (curr){
                //用Switch来判断其对应的二元运算符
                case "+":
                    //若为运算符则弹出两个操作数，完成运算后将结果压入栈中
                    o1 = oprands.pop();//弹栈并保存于o1
                    o2 = oprands.pop();//弹栈并保存于o2
                    result = o2 + o1;//进行计算
                    oprands.push(result);//将结果压栈
                    break;
                case "-":
                    o1 = oprands.pop();//弹栈并保存于o1
                    o2 = oprands.pop();//弹栈并保存于o2
                    result = o2 - o1;//进行计算
                    oprands.push(result);//将结果压栈
                    break;
                case "*":
                    o1 = oprands.pop();//弹栈并保存于o1
                    o2 = oprands.pop();//弹栈并保存于o2
                    result = o2 * o1;//进行计算
                    oprands.push(result);//将结果压栈
                    break;
                case "/":
                    o1 = oprands.pop();//弹栈并保存于o1
                    o2 = oprands.pop();//弹栈并保存于o2
                    result = o2 / o1;//进行计算
                    oprands.push(result);//将结果压栈
                    break;
                default:
                    //若为操作数，则将该操作数压栈
                    oprands.push(Integer.parseInt(curr));
                    //调用Integer.parseInt方法将字符串内容
                    //转换成Integer内容，用于存放
            }
        }
        //最后弹出栈中的最后一个元素，其就为逆波兰表达式的结果
        return oprands.pop();
    }
}
```

那么到此为止，我们就实现了逆波兰表达式的计算代码了，栈的内容也讲完了



队列

现在我们来学习队列这一数据结构

首先我们要知道队列是一种基于先进先出（FIFO），FIFO是First in first out的简写，是一种只能在一端进行插入，在另一端进行删除的特殊线性表，我们直接来看看其图示说明

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcdf504007f95e103f3319e6491980a62.png)

接下来我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE481a43e93b46404d84a3737a75d93f4e.png)

同栈一样，队列也是可以通过链表或者是数组的方式来实现的，这里我们采用链表的方式来实现，那么我们可以构建其代码如下，注意，这里我们的队列也是已经实现了遍历方法的

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class Queue<T> implements Iterable{
    //记录首结点
    private Node head;
    //用于记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }

    public Queue() {
        this.head = new Node(null,null);
        this.last = null;
        this.N = 0;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //返回队列中的元素个数
    public int size(){
        return N;
    }

    /*
     * 我们这里的这个方法的主要作用是向队列中插入元素t，那当我们是队列
     * 数据结构时，我们应该怎么实现插入方法呢？我们可以按顺序在链表中
     * 添加元素，每次添加都让新添加的元素成为尾结点
     */
    public void enqueue(T t){
        //先判断队列中有无元素，通过last是否为null来判断
        if(last==null){
            //如果当前尾结点为null，也就是队列为空
            //直接将last定位到新创建的结点上，此时可以理解为新结点成为了尾结点
            last = new Node(t,null);
            //首结点指向尾结点
            head.next=last;
        }else {
            //当前尾结点的last不为null，此时先将last的结点记录于oldLast上
            Node oldLast = last;
            //令last指向新的尾结点
            last = new Node(t,null);
            //让上一个结点的尾指针域指向尾结点
            oldLast.next=last;
        }
        //元素个数+1
        N++;
    }

    //从队列中拿出一个元素

    /*
     * 这个方法的主要作用是从队列中拿出一个元素，但是注意在队列的数据
     * 结构中拿出元素是要按照先进先出的原则的，因此我们要想办法在取出
     * 元素时做到先取出第一个放置的元素。我们可以先取出首结点的下一个
     * 结点，然后让首结点指向被取出结点的下一个结点，按照这个方式取出
     * ，我们就可以达到先进先出的效果
     */
    public T dequeue(){
        //先判断队列是否为空
        if (isEmpty()){
            return null;
            //若为空则直接返回null
        }

        //将头结点指向的下一个结点用oldFirst记录起来
        Node oldFirst = head.next;
        //令头结点指向被取出结点的下一个结点，这个动作相当于删除结点同时下一个结点称为新结点
        head.next = oldFirst.next;
        N--;//元素个数-1

        //这个动作其实是在删除元素，如果队列的元素被删除完了，那么要重置last
        if(isEmpty()){
            last=null;
        }
        return oldFirst.item;//返回被删除元素的数据
    }

    @Override
    public Iterator iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator{
        //定义一个记录头结点的结点变量
        private Node n;

        public QIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```

那么至此，我们队列也讲完了，那么线性表这一章节就算是讲完了