线性表概述

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的优先序列

该数据结构的样子有点类似于排队

先来讲讲线性表的知识

若A元素在B元素的前面，则称A为B的前驱元素

若B元素在A元素的后面，则称B为A的后继元素

再来讲讲线性表的特征

首先第一个数据元素没有前驱元素，这个数据元素被称之为头结点

其次最后一个数据元素没有后继元素，这个数据元素被成为尾结点

除了第一个和最后一个元素外，其他数据元素有且仅有只有一个前驱元素与后继元素

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE35db3a02a21b62402e511810c14c5121.png)

用数学语言来表述则是如图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc11d705c0aed0497ee74feee71d37c48.png)

最后我们来讲讲线性表的分类

线性表数据存储的方式可以是顺序存储，也可以是链式存储，按照数据存储方式的不同，可以把线性表分为顺序表和链表。



顺序表

我们先来讲讲顺序表，首先我们应该先实现顺序表，顺序表在计算机内存中是以数组形式保存的线性表，现在我们来实现这个实现这个顺序表，先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE65fd3414ae207951d7ab5c3f90ad999b.png)

由API我们可以实现其代码如下

```javascript
package algorithm.sort;

public class SequenceList<T> {
    //存储元素的数组
    private T[] eles;//该数组还没有进行初始化，没有赋予空间大小
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //之所以采用这种方式，是因为this.eles=new T[capacity];这种语法无法通过
        //其原因在于泛型T无法被直接实例化

        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    private void clear(){
        this.N=0;
        //个人认为这里只是将记录数组长度的变量赋值为0，并没有真正将数组的元素清空
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线性表中添加元素t
    public void insert(T t){
        eles[N++]=t;
        //将数值赋给对应位置之后，将长度+1
        //同样我认为这方法只是将记录的值+1，实际上没有创建新的用于存放数据的空间
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        for (int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;
        //这里利用倒序遍历法来将数组插入后续的值都后移一位的思想值得学习
        //但是我认为这里同样存在没有增加存放插入数据的空间的问题
        //而且应该会报数组下标越界异常才对，但是实际运行没啥问题，就有点小怪

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素一次向前移动一位
        for (int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;
        return current;
    }

    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for (int i=0;i<N;i++){
            if(eles[i].equals(t)){//使用equals方法进行比较
                return i;
            }
        }
        return -1;
    }
}
```

虽然在这个代码的注释里我写了很多我认为的问题，但实际运行的时候，居然没啥问题，我猜想这是因为底层代码有对应处理机制的结果

一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们要给我们的顺序表提供遍历方式。

值得一提的是，这里面的遍历是java特有的一种方式，即使我们不提供遍历，这个顺序表也是能够正常运行的，所以这一块的内容作为了解即可

接着我们来讲讲关于顺序表的遍历，首先我们来看看其遍历时我们应该实现的要求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2b0f2d8c8f81a6c8d7d743bd1c3162e1.png)

接下来我们将遍历实现

```javascript
package algorithm.sort;

import java.util.Iterator;

//若想要遍历，就应该要先实现Iterable接口
public class SequenceList<T> implements Iterable<T> {
    //存储元素的数组
    private T[] eles;//该数组还没有进行初始化，没有赋予空间大小
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //之所以采用这种方式，是因为this.eles=new T[capacity];这种语法无法通过
        //其原因在于泛型T无法被直接实例化

        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    private void clear(){
        this.N=0;
        //个人认为这里只是将记录数组长度的变量赋值为0，并没有真正将数组的元素清空
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线性表中添加元素t
    public void insert(T t){
        eles[N++]=t;
        //将数值赋给对应位置之后，将长度+1
        //同样我认为这方法只是将记录的值+1，实际上没有创建新的用于存放数据的空间
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        
        //把i索引处的元素及其后面的元素依次向后移动一位
        for (int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;
        //这里利用倒序遍历法来将数组插入后续的值都后移一位的思想值得学习
        //但是我认为这里同样存在没有增加存放插入数据的空间的问题
        //而且应该会报数组下标越界异常才对，但是实际运行没啥问题，就有点小怪

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素一次向前移动一位
        for (int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;
        return current;
    }

    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for (int i=0;i<N;i++){
            if(eles[i].equals(t)){//使用equals方法进行比较
                return i;
            }
        }
        return -1;
    }

    //实现Iterable接口需要重写Iterator方法
    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    //重写该方法要令其返回一个Iterator，但是Iterator是接口，无法直接new对象
    //因此我们自己写一个内部类令其继承Iterator并重写其内部的方法
    //这样就可以通过new这个类来达到返回一个Iterator的目的了
    private class SIterator implements Iterator{

        //定义一个指针用于遍历
        private int cursor;

        //定义一个构造方法，调用该方法初始化指针为0
        public SIterator(){
            this.cursor=0;
        }

        //继承Iterator需要重写hasNext和next两个方法
        @Override
        public boolean hasNext() {
            return cursor<N;
            //该方法用于判断指针指向的位置是否还有元素，因此使用cursor<N
        }

        @Override
        public Object next() {
            return eles[cursor++];
            //该方法用于获取元素之后使指针指向下一位，因此是cursor++
        }
    }
}
```

但是我们现在创造的数组也有问题，一个经典问题就是我们的数组无法完成扩容，这样如果我们一开始规定了我们的容量为3，那么我们就只能够存储3个元素了，实际上，如果会自动扩容或者是会自动减容的话，会更加符合我们的思维习惯，因此我们应该要给我们的数组增加自动扩容/减容的机制

那么我们现在先来确定我们什么时候需要扩容，什么时候需要减容，以及要减容多少。我们不妨先确定如果我们增加元素时需要扩容，那么我们就扩容到其原来的二倍，删除元素时，如果剩余元素小于原数组的1/4，那么我们就将数组减少到其一半

那么我们可以实现其代码如下

```javascript
package algorithm.sort;

import java.util.Iterator;

//若想要遍历，就应该要先实现Iterable接口
public class SequenceList<T> implements Iterable<T> {
    //存储元素的数组
    private T[] eles;//该数组还没有进行初始化，没有赋予空间大小
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //之所以采用这种方式，是因为this.eles=new T[capacity];这种语法无法通过
        //其原因在于泛型T无法被直接实例化

        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    private void clear(){
        this.N=0;
        //个人认为这里只是将记录数组长度的变量赋值为0，并没有真正将数组的元素清空
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线性表中添加元素t
    public void insert(T t){
        if(N==eles.length){
            resize(2*eles.length);
        }
        eles[N++]=t;
        //将数值赋给对应位置之后，将长度+1
        //同样我认为这方法只是将记录的值+1，实际上没有创建新的用于存放数据的空间
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        if(N==eles.length){
            resize(2*eles.length);
        }

        //把i索引处的元素及其后面的元素依次向后移动一位
        for (int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;
        //这里利用倒序遍历法来将数组插入后续的值都后移一位的思想值得学习
        //但是我认为这里同样存在没有增加存放插入数据的空间的问题
        //而且应该会报数组下标越界异常才对，但是实际运行没啥问题，就有点小怪

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素一次向前移动一位
        for (int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;

        if(N<eles.length/4){
            resize(eles.length/2);
        }

        return current;
    }

    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for (int i=0;i<N;i++){
            if(eles[i].equals(t)){//使用equals方法进行比较
                return i;
            }
        }
        return -1;
    }

    //根据参数newSize，重置eles的大小
    public void resize(int newSize){
        //定义一个临时数组，指向原数组
        T[] temp=eles;
        //创建新数组
        eles=(T[])new Object[newSize];
        //把原数组的数据拷贝到新数组即可
        for(int i=0;i<N;i++){
            eles[i]=temp[i];
        }
    }

    //实现Iterable接口需要重写Iterator方法
    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    //重写该方法要令其返回一个Iterator，但是Iterator是接口，无法直接new对象
    //因此我们自己写一个内部类令其继承Iterator并重写其内部的方法
    //这样就可以通过new这个类来达到返回一个Iterator的目的了
    private class SIterator implements Iterator{

        //定义一个指针用于遍历
        private int cursor;

        //定义一个构造方法，调用该方法初始化指针为0
        public SIterator(){
            this.cursor=0;
        }

        //继承Iterator需要重写hasNext和next两个方法
        @Override
        public boolean hasNext() {
            return cursor<N;
            //该方法用于判断指针指向的位置是否还有元素，因此使用cursor<N
        }

        @Override
        public Object next() {
            return eles[cursor++];
            //该方法用于获取元素之后使指针指向下一位，因此是cursor++
        }
    }
}
```

最后我们来分析下该方法的时间复杂度，直接贴图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE520b4af4a9ed586c6a871f5b2307b7c8.png)

这些结论其实JavaSe里也学过了，这里算是对知识了解的进一步补充



java中ArrayList实现

java中ArrayList集合的底层也是一种顺序表，同样使用数组实现，也同样提供了增删改查的功能

通过查看ArrayList的源码，来确定这三件事

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3ec029903734caf85042c9765f095012.png)

显然，这三个都是确定的，因为我们都已经知道了在工具类里我们是可以调用这些方法的，那自然他们也实现了这些功能。

那既然java里已经实现好了这些类，那我们为什么还要自己学一个呢？因为java中的工具类为了其通用性和安全性，总体而言是写得比较臃肿的，有1500多行代码，实际运行的时候可能其写好的数据结构不符合我们的需求，也可能发生效率过低的情况，因此我们要学习自己写这种数据结构，未来能够自己实现这种类型的数据结构来增强效率