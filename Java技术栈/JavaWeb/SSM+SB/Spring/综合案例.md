学习完了spring的基础环境之后，我们现在来正式搞一个spring的案例

- spring整合mybatis案例基础环境介绍

先来看看我们的案例分析，先对比下非spring环境与spring环境下的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEadbb6f7b18168b9dc36d51d1332bf95d.png)

首先我们要明白，我们要完成的案例的内容是，通过spring框架实现从数据库中查找出对应的数据并封装成对象后在控制台上打印

接着我们来看看我们的基础准备工作

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0f7c49463fb8c370f8c74a851d480b9a.png)

这里我们有一点要注意，就是我们用于查找数据的dao层不需要我们去定义，我们利用代理自动生成

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe12fba49c955e98fc49c614cd16d12f5.png)

首先我们先来讲讲关于maven的pom文件里，dependency标签，也就是写入依赖的作用，我们在dependency标签中只要输入对应的地址，我们的idea就会根据这个地址自动将其对应的包导入进来，其实就相当于是自动导入jar包，为了完成我们的案例，我们首先要在我们的pom.xml文件中写入如下代码

```
<dependencies>
  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.3</version>
  </dependency>
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.1.9.RELEASE</version>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.1.9.RELEASE</version>
  </dependency>
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
  </dependency>
  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>1.3.0</version>
  </dependency>
```

可以看到，我们这里先写入了mybatis的依赖，然后我们写入了mysql的依赖，接着是spring框架的依赖，然后是druid连接池的依赖，最后是spring整合mybatis的依赖（注意这个jar是属于mybatis的，我猜测任何整合类技术都归属于其jar的提供方，也就是被整合方，而不是整合方，比如这里是属于mybatis而不是属于spring），我们先导入这些依赖的目的非常简单，就是因为我们的项目中需要用到这些依赖，也就是需要用到这些jar包，所以我们需要导入。这里值得一提的是我们注意到我们还多导入了一个spring-jdbc的依赖，之所以导入这个依赖是因为在spring中其有其自己的jdbc策略，我们之前导入了spring-context，其下还包括了许多该jar包会用到的其他jar包，其也将我们导入了，但是其不一定用到jdbc，因此其这里并没有帮我们自动导入spring中的jdbc的jar包，因此我们这里还需要手动导入，否则会报错

然后我们需要介绍下我们的项目里所具有的内容

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa2eb4b016e2734248ef245e81fe59ac0.png)

可以看到我们的项目的整体内容其实是先创建dao层的对应接口，然后对应接口的实现类由资源中的AccountDao.xml来自动实现，接着我们就要通过调用service接口的实现类来调用Dao层的查询方法，最后实现查询

我们首先需要创建service层的接口和其实现类，其接口代码如下

```
package com.itheima.service;

import com.itheima.domain.Account;

import java.util.List;

public interface AccountService {

    void save(Account account);

    void delete(Integer id);

    void update(Account account);

    List<Account> findAll();

    Account findById(Integer id);

}
```

其实现类代码如下

```
package com.itheima.service.impl;


import com.itheima.dao.AccountDao;
import com.itheima.domain.Account;
import com.itheima.service.AccountService;

import java.util.List;

public class AccountServiceImpl implements AccountService {

    private AccountDao accountDao;

    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }

    public void save(Account account) {
        accountDao.save(account);
    }

    public void update(Account account){
        accountDao.update(account);
    }

    public void delete(Integer id) {
        accountDao.delete(id);
    }

    public Account findById(Integer id) {
        return accountDao.findById(id);
    }

    public List<Account> findAll() {
        return accountDao.findAll();
    }
}

```

可以看到实现类的代码其实就是在调用Dao层的代码，那么接着我们来看看Dao层接口的代码

```
package com.itheima.dao;

import com.itheima.domain.Account;

import java.util.List;

public interface AccountDao {

    void save(Account account);

    void delete(Integer id);

    void update(Account account);

    List<Account> findAll();

    Account findById(Integer id);
}

```

Dao层接口是通过配置文件动态实现的，我们继续来看其对应的配置文件

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.AccountDao">

    <!--配置根据id查询-->
    <select id="findById" resultType="account" parameterType="int">
        select * from account where id = #{id}
    </select>

    <!--配置查询所有-->
    <select id="findAll" resultType="account">
        select * from account
    </select>

    <!--配置保存-->
    <insert id="save" parameterType="account">
        insert into account(name,money)values(#{name},#{money})
    </insert>

    <!--配置删除-->
    <delete id="delete" parameterType="int">
        delete from account where id = #{id}
    </delete>

    <!--配置更新-->
    <update id="update" parameterType="account">
        update account set name=#{name},money=#{money} where id=#{id}
    </update>
</mapper>
```

可以看到我们这里指定了对应的命名空间，然后写入了对应的查询方法，如果忘记了这一部分的内容，可以去mybatis章节复习。然后我们先在我们的applicationContext.xml文件下写入对应的代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!--加载perperties配置文件的信息-->
    <context:property-placeholder location="classpath:*.properties"/>

    <!--加载druid资源-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--配置service作为spring的bean,注入dao-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>
```

我们这里先对我们的xml文件的固定格式进行了引入，使得我们可以加载配置文件的信息，然后在第10-11行加载了我们的配置文件的信息，配置文件的内容其实就是连接我们的druid连接池的一些对应的数据，然后我们在其下创建对应的bean标签，然后通过加载properties的方式给对应属性赋值。最后我们当然还需要创建service实现类，因此我们又创建了一个bean标签生成此对象，同时给其下的属性赋值，当然，这时候我们的accountDao对象还没有生成，所以子在编译器上会报红

然后此时我们查看下我们的mybatis的映射配置文件，看看有哪些可以去除的，去除的部分就是已经在刚刚的配置文件里写入的部分

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEccbcaef65f389011d5a6fcee4eba5fb9.png)

显然，连接部分，以及读取配置文件的部分都可以去除掉，因此我们可以将我们代码省略为如下部分

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb9585d1bd02d3c15c8d05af896b9f83b.png)

此时我们就知道我们接下来需要在spring中实现的部分，分别是上面的两个包的内容，只有实现了，才算是给这个文件进行了全部的搬家，才算是用spring实现了mybatis的案例。我们上面的两个内容，分别是类型别名和映射别名，前者用于指定我们要封装的对象的类型，后者用于指定我们要动态生成的类的对象的类型（也就是用于增删改查的接口的类），但是他们都是用包来实现的，我们只需要填入一个包的地址，其就能自动寻找到合适的类型，不需要我们去操心

那现在我们就来实现这两个内容，首先我们肯定需要spring中整合mybatis之后得到的对象，但是这个对象到底是哪个？这个我们还不知道，因此我们要去自己找，我们首先进入我们的资源图书馆，然后在其中我们能找到我们之前引入的spring整合mybatis的jar包，点开之后在点开里面的文件夹，能找到一个工厂类，一般来说，工厂类里往往会有创建我们所需对象的方法，因此我们进入工厂类中看看

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE84e14b95ea67198cf9bd54421a030a6f.png)

我们查看其所有的set方法，看看里面有没有我们想要的东西，我们注意到我们之前的类名别名的标签是typeAliases，我们正好在这里能找到对应的方法，有两个，我们同时还注意到我们在配置文件里要填入的内容是包名，那么对于的setTypeAliasesPackage方法，就很有可能是我们所需要的方法。同时我们创建的对象一定要有一个连接，因此我们肯定还需要DataSource方法，在下面也有对应的方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4e1d56e8479fcfb35297e7a387b066b4.png)

根据上面的内容，我们可以再对应的配置文件中写入代码如下

```
<!--spring整合mybatis后控制的创建连接用的对象-->
<bean class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="typeAliasesPackage" value="com.itheima.domain"/>
</bean>
```

可以看到我们这里代码自身是用于获得创建连接的工厂类对象的，其下我们给对应的两个变量赋值，分别是dataSource，也就是连接，dataSource对象我们在上面已经获得了，然后我们将其注入

接着我们给typeAliasesPackage指定路径，由于是指定路径，因此我们是填入value，同时我们指定对应的domain包，其指定的是我们的数据最后要封装的对象，那么到此为止，我们的第一个类名别名的标签就已经成功搬运过来了

然后我们接着去整第二个，第二个是映射扫描的配置，我们注意到在我们的spring整合mybatis的jar包中有mapper包，在其下有MapperScannerConfigurer（映射扫描配置），这显然就是我men所需要的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb30f420c46fd083138f9a5d8233f100.png)

接着同样我们进入其set方法中看看，我们可以看到一个setBasePackage的方法，设置基础包，正好我们的映射配置里要设置的也是一个包，那么这个方法，就是我们所需要的方法了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdfe0155ed12941138dfde59258e212a0.png)

因此我们可以写入代码如下

```
<!--加载mybatis映射配置的扫描，将其作为spring的bean进行管理-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.itheima.dao"/>
</bean>
```

我们这里创建了一个MapperScannerConfigurer对象，然后我们给里面的basePackage属性赋予了对应的包地址。这里我们提一下，我们的name的设置规则是将对应方法中的set去掉之后填入的名字，这是我们的Spring中的一个规范，因为实际上我们查看能够看到其成员变量的属性名就是我们根据规则得到的名字，开发中这也是一个规范来的，有了这个规范，就能够便于程序员的使用。同时，这也是为什么我们总是去寻找包中的set方法的原因，一是因为set方法有这个规范，我们可以知道其对应的成员变量，二是因为我们的Spirng的开发规范就是需要Set方法来提供给配置文件，这样配置文件才能给对面的属性注入对应数据。

我们搞定了这两个之后，我们的所有东西就搬家成功了，此时我们就不再需要原来的mybatis的映射文件了，我们创建一个App类并进行测试

```
import com.itheima.domain.Account;
import com.itheima.service.AccountService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        AccountService accountService = (AccountService) ctx.getBean("accountService");
        Account ac = accountService.findById(1);
        System.out.println(ac);

//        Account account = new Account();
//        account.setName("Tom");
//        account.setMoney(123456.78);
//
//        accountService.save(account);

    }
}

```

测试之后会发现没有问题，我自己的代码搞出来会出一些奇怪得不行的问题，一直报出绑定错误，说是没有第十行的代码的方法，百度了很久也没有好的解决方法，那就先这样吧

最后我们再来看看我们放置在jdbc中的配置文件的代码

```
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://175.178.114.158:3306/spring_db
jdbc.username=root
jdbc.password=itheima
```

