接着我们已经学习完了常用注解了，接着我们就使用这些常用注解来将我们的第三方技术进行整合，使得我们的案例全部用注解形式来体现

- 注解整合mybatis分析

那么我们要做的事情就是注解整合MyBatis，我们的目标很简单，就是将Mybatis中的核心配置文件的内容全部用注解来表示，首先是加载配置文件的信息，这个我们通过@PropertySource注解来实现。我们判断我们是用Bean还是用Component，主要取决于我们看我们要生成的对象是自己的创建的，还是别人提供的，如果是别人提供的我们就是Bean，反之则用Component。并且前者内部是通过java代码的形式来实现的，其实都是这样的，别人的东西我们不能坐改动，因此往内部都是写入java代码的来赋值的，而不是用注解注入

相应的配置类我们则通过对应的注解来注入

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc4f318a8814a464458e604afcc767dea.png)

然后我们来看看步骤分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE00146c6593c85fc0c71a5ffc9f858039.png)

最后是具体的步骤分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5be72bdad5c4f280d7d6e582675fc579.png)

- 注解整合mybatis

接着我们进行一个注解的整合mybatis的动作，我们为此的做法非常简单，我们先打开我们的对应的MyBatis的核心配置文件，然后我们对着核心配置文件来做注解整合，一步步把里面的代码都搬家到我们的注解上去，首先是我们的固定格式的头代码和引入注解扫描区域的代码

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!--加载perperties配置文件的信息-->
    <context:property-placeholder location="classpath:*.properties"/>
```

首先我们要创建一个对应的注解核心配置类，然后我们在该类上加入如下代码

```
@Configuration
@ComponentScan("com.itheima")
```

这两行代码，第一行代表的是头文件，而第二行代表的是要扫描的注解区域，我们这里写入相对比较精确的位置的包路径

接着我们要加载druid资源，我们加载druid资源的方式就是自己创建一个druid对象然后将其返回，同时，由于我们的路径一类的代码仍然是要放到properties文件中去的，因此我们在使用其代码创建对应的对象的时候，要将传入的参数用注解的形式从properties文件中获得

```
<!--加载druid资源-->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

那么首先我们创建一个jdbc的配置类，然后我们构建我们的代码如下

```
package com.itheima.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;

import javax.sql.DataSource;

public class JDBCConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean("dataSource")
    public DataSource getDataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}

```

可以看到我们这里为了和properties文件有所联立，多创建了四个成员变量，通过其进行一个赋值，这里由于我们使用的不是自己的代码，因此我们使用@Bean注解，同时我们的这个对象在后面会被人所使用到，因此我们这里给其取名dataSource，在配置文件中我们也可以看到后面还有内容引用了这个对象的id，因此我们这里也要加入id，最后我们再来看看properties的代码

```
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://175.178.114.158:3306/spring_db
jdbc.username=root
jdbc.password=itheima
```

最后不要忘了其配置是需要在核心配置文件中进行一个导入的

接着是我们的自己的代码，也就是我们需要创建出一个service层的调用的对象，这个比较简单

```
<!--配置service作为spring的bean,注入dao-->
<bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
    <property name="accountDao" ref="accountDao"/>
</bean>
```

在对面的实现类里加入注解然后取名就可以了，这里由于我们的AccountDao是引用变量，因此要加入Autowired注解，令其自动寻找对应的类

```
package com.itheima.service.impl;


import com.itheima.dao.AccountDao;
import com.itheima.domain.Account;
import com.itheima.service.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;

    public void save(Account account) {
        accountDao.save(account);
    }

    public void update(Account account){
        accountDao.update(account);
    }

    public void delete(Integer id) {
        accountDao.delete(id);
    }

    public Account findById(Integer id) {
        return accountDao.findById(id);
    }

    public List<Account> findAll() {
        return accountDao.findAll();
    }
}

```

接着是创建整合mybatis后控制创建连接的对象，也就是创建一个工厂对象

```
<!--spring整合mybatis后控制的创建连接用的对象-->
<bean class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="typeAliasesPackage" value="com.itheima.domain"/>
</bean>
```

我们新创建一个MybatisConfig用于存放这些对象，然后我们首先创建一个返回SqlSessionFactoryBean对象的方法，加入@Bean注解，这里不用取名是因为我们只要有这个对象就可以了，不需要被人再次调用，因此括号内不用填入什么。然后既然在配置文件里其能创建对应的对象，那么其必然有无参构造方法，因此我们首先利用无参构造方法获得我们所需要的对象，然后对其进行对应的赋值，我们首先调用setTypeAliasesPackage方法，然后填入我们设置的包路径，该方法设置的路径里是有我们得到的数据要被封装的对象的。然后我们再调用setDataSource()方法，该方法需要传入一个数据源，这个数据源从哪里来捏？我们一个简单的想法就是从我们的方法中传入，同时我们给其加入@Autowired注解，令这个对象能够自动获得我们之前创建好的数据源对象。

```
@Bean
public SqlSessionFactoryBean getSqlSessionFactoryBean(@Autowired DataSource dataSource){
    SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
    ssfb.setTypeAliasesPackage("com.itheima.domain");
    ssfb.setDataSource(dataSource);
    return ssfb;
}
```

最后我们来整最后一个内容，创建我们的映射扫描对象，这个其实是依葫芦画瓢了

```
<!--加载mybatis映射配置的扫描，将其作为spring的bean进行管理-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.itheima.dao"/>
</bean>
```

那么我们可以写入其代码如下

```
@Bean
public MapperScannerConfigurer getMapperScannerConfigurer(){
    MapperScannerConfigurer msc = new MapperScannerConfigurer();
    msc.setBasePackage("com.itheima.dao");
    return msc;
}
```

最后我们将这个配置文件的代码用Import注解传入到注解核心配置文件中，最后我们的注解核心配置文件的代码如下

```
package com.itheima.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.PropertySource;

@Configuration
@ComponentScan("com.itheima")
@PropertySource("classpath:jdbc.properties")
@Import({JDBCConfig.class,MyBatisConfig.class})
public class SpringConfig {
}

```

最后我写入测试类的代码如下

```
import com.itheima.config.SpringConfig;
import com.itheima.domain.Account;
import com.itheima.service.AccountService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = (AccountService) ctx.getBean("accountService");
        Account ac = accountService.findById(2);
        System.out.println(ac);
    }
}

```

经过测试发现我们的代码没有问题，此时就说明我们已经成功整合了

- 注解整合Junit

我们上面已经将我们的Mybatis成功整合好了，但是我们的测试还是用的比较随意的一个自己创建的类，这样虽然能够成功，但是是不规范的，我们要使用Junit进行测试，因此我们本节来将我们的Junit也整合到我们的项目中且也用注解形式来进行整合

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb94231dc1607a8597d642b0585f15b81.png)

首先我们要知道，我们一般的Junit是自己整个类加载器然后把我们的类加载到里面进行测试的，而我们这里是要用spring整合Junit，因此我们要让Spring接管Junit的运行权，为此我们要使用Spring专用的Junit类加载器

这里要注意两件事，一是从spring5.0之后，就要求Junit的版本必须是4.12及以上，因此我们在写入依赖时要写入合适的版本，第二是Junit仅用于单元测试，我们不可以将Junit的测试类配置成spring中的bean，否则这个测试类也会被打包到工程中

下图是导入的Junit的坐标以及spring整合Junit测试用例的注解格式，我们看到我们这里配置了Junit的依赖，同时配置了spring-test的依赖，也就是spring技术的测试依赖

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9b5f1f7029d5c764ad5f2710ef5c089e.png)

此时我们要创建对应的代码就不是在原来的地方上创建了，我们要在test包下创建对应的包并在其下写入对应的测试类代码，这是当然的，因为本来我们这个文件夹就是用于测试的，我们创建对应的测试类，然后写入代码如下

```
package com.itheima.service;

import com.itheima.config.SpringConfig;
import com.itheima.domain.Account;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.ArrayList;
import java.util.List;

//设定spring专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
//设定加载的spring上下文对应的配置
@ContextConfiguration(classes = SpringConfig.class)
public class UserServiceTest {
    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        Account ac = accountService.findById(2);
        System.out.println(ac);
        Assert.assertEquals("Jock1",ac.getName());
    }

    @Test
    public void testFindAll(){
        List<Account> list = accountService.findAll();
        Assert.assertEquals(2,list.size());
    }
}

```

我们首先在对应的类上写入@RunWith注解，该注解用于设定我们spring专用的类加载器，因此我们这里传入对应的类加载器的class对象，然后我们要设定加载的spring上下文的对应的配置，这里使用@ContextConfiguration注解，这里需要设定classes=，后面填入我们的核心配置文件的class对象。接着我们在我们的测试类里传入我们的需要进行测试的对象，上面写入注解@Autowired令其自动获得对应的对象

然后我们创建对应的方法并加上@Test注解，注意我们这里要进行判断例子能否通过不是用打印方法，我们是要使用断言语句，断言中填入我们与其的参数及其获得的实际数据，若断言正确，则在控制台中会显示通过，若不正确，则不通过，同时会在控制台中打印对应的不通过的信息

可以填入多个测试方法，然后一起运行，想要一起运行就直接运行对应的类就完了

