之前我们以及学习完线性表了，我们能够知道线性表里的元素每次都是存储了一个元素的，但是在现实生活中，我们的很多时候不只是需要存储一个元素，有时候是需要存储两个对应的元素的，而符号表就能满足我们的这种需求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE18e5b12aeca82e306f7575e06d581f67.png)

符号表内的数据我们称之为键值对，有一个键key，和一个值value组成的，我们可以根据键来查找对应的值，符合表中，键具有唯一性，既不能出现重复的键

键值对在生活中的应用场景是非常广泛的，最简单的就比如说查找，假设书籍编号就是key，value是书名，那么我们就可以通过key来查找书名，非常简单。这只是一个最简单的应用的举例，实际上还有很多例子这里就不再赘述了

接下来我们来看看其API设计

首先是结点类的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb6d873b545cd615bdf2fdd27d6cf462a.png)

由于采用键值对的方式进行储存，因此其用于储存元素的结点类也不尽相同。再来看看符号表的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE751f1354d1ad4b5afb63f83426bf7232.png)

那么根据上面的API设计我们可以实现其代码如下，我们这里采用链表的方式来进行实现

```javascript
package algorithm.sort;

import java.util.Iterator;

public class SymbolTable<Key,Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    //符号表中的结点类
    private class Node{
        //键，此处的Key是泛型标识
        public Key key;
        //值，此处的Value是泛型标识
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key,Value value,Node next) {
            this.key=key;
            this.value=value;
            this.next=next;
        }
    }

    //符号表的构造方法
    public SymbolTable() {
        //创建不存储任何元素的首结点，其主要作用是指向下一个结点
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    /*
     *要实现该方法要先进行传入的key是否已经在符号表中存在的判断，如果
     * 已经存在了那么我们就替换对应value的值就可以了。如果不存在那么
     * 就正常插入，插入的方式不是让尾结点指向新结点，而是让头结点指向
     * 新的结点，让新的结点指向原先首结点指向的下一个结点，有点类似于
     * 队列中的插入方式，将新结点插入到链表的头部
     */
    //往符号表中插入键值对
    public void put(Key key,Value value) {
        //先进行符号表中有无该key的键值对的循环判断
        Node n = head;//用n保存首结点便于后续遍历
        while (n.next!=null){//只要不为空说明还没循环到底，继续循环
            //令n进入其原先所指向的下一个结点，由于n是首结点，所以
            //其先进入下一个结点没有问题，因为首结点只负责指向
            n = n.next;
            //判断n结点存储的key与传入的key是否相等
            if(n.key.equals(key)){
                //若相等则替换对应结点内的value的值
                n.value = value;
                return;//插入完毕，直接结束该方法
            }
        }
        //代码执行到此说明不存在与其相等的key，则创建新结点
        Node newNode = new Node(key,value,null);
        //用oldFirst保存首结点指向的第一个结点
        Node oldFirst = head.next;
        //令新结点指向首结点指向的下一个结点
        newNode.next = oldFirst;
        //让首结点指向新结点
        head.next = newNode;
    }



    /*
     * 该删除方法的实现原理是先找到对应的结点，然后将对应结点的上一个
     * 结点指向对应结点的下一个结点
     */
    //删除符合表中键为key的键值对
    public void delete(Key key){
        //先构建循环找到键为key的结点
        Node n = head;//同样先创建n保存头结点
        while (n.next!=null){
            //判断n结点的下一个结点是否为key，若是就进入方法
            //由于n最初是头结点，因此先构建代码n.next没有问题
            if(n.next.key.equals(key)){
                //令被删除结点的上一个结点的尾指针域指向被删除结点
                //的下一个结点
                n.next = n.next.next;
                N--;
                return;
            }
            //若不是则令n进入下一个结点
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while (n.next!=null){
            //令n进入其所指向的下一个结点
            n = n.next;
            //判断是否是与传入的key的值相同的结点
            if(n.key.equals(key)){
                //若是则返回该结点的value
                return n.value;
            }
        }
        //代码执行到此说明符号表内压根没有对应的key，返回null
        return null;
    }
}
```

但其实，我们上面所实现的符号表，它是没有序的。因为我们插入元素的时候，我们只是将其暴力地直接查到头结点处，而没有进行判断，如果我们想要实现有序符号表的话，那么我们应该要重新改造我们的put方法，让put方法可以做到插入时排序，使得插入完毕之后我们的符号表就处于有序的状态。

那我们应该怎么做到呢？我们先来看看实现该方法的原理演示图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1e438116166157bd661fa175eca2ae2b.png)

我们让我们的key值与链表中的元素互相比较，直到发现比我们要插入的key值要大的元素，我们就让我们的要插入的结点指向该结点，再让该结点的上一个结点指向我们要插入的结点，接着消除原先上一个结点对下一个结点的指向就完了

那我们现在来实现下这个代码

```javascript
package algorithm.sort;

import java.util.Iterator;

//令key继承Comparable接口，给Key所代表的元素提供比较方式，便于实现排序
public class OrderSymbolTable<Key extends Comparable<Key>,Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    //符号表中的结点类
    private class Node{
        //键，此处的Key是泛型标识
        public Key key;
        //值，此处的Value是泛型标识
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key,Value value,Node next) {
            this.key=key;
            this.value=value;
            this.next=next;
        }
    }

    //符号表的构造方法
    public OrderSymbolTable() {
        //创建不存储任何元素的首结点，其主要作用是指向下一个结点
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    /*
     *要实现该方法要先进行传入的key是否已经在符号表中存在的判断，如果
     * 已经存在了那么我们就替换对应value的值就可以了。如果不存在那么
     * 就正常插入，插入的方式不是让尾结点指向新结点，而是让头结点指向
     * 新的结点，让新的结点指向原先首结点指向的下一个结点，有点类似于
     * 队列中的插入方式
     */
    //往符号表中插入键值对
    public void put(Key key,Value value) {
        //定义两个Node变量分别记录当前结点与当前结点的上一个结点
        Node curr = head.next;//记录当前结点
        Node pre = head;//记录当前结点的上一个结点
        while (curr!=null&&key.compareTo(curr.key)>0){
            /*
             *构建while循环进行判断，要求当curr不为null且curr
             * 的key值小于我们进行比较的传入的key值，满足条件
             * 则说明结点定位还没到我们想要的传入值不小于结点key值
             * 的那个位置，那么我们就让结点继续前进
             */
            pre = curr;//令记录当前结点的上一个结点的结点前进一位
            curr = curr.next;//令当前结点前进一位
        }
        //代码执行到此说明已经到达了我们想要的传入值不小于结点key值
        //的位置，但是我们还要进行判断其是否相等
        if(curr!=null&&key.compareTo(curr.key)==0){
            curr.value = value;//如果相等则替换value
            return;//结束方法
        }
        //代码执行到此说明传入值比小于结点值key
        //创建新结点，令该结点指向其key值小于它的第一个结点
        Node newNode = new Node(key,value,curr);
        //令原先curr的结点的上一个结点指向这个新结点
        pre.next = newNode;

        //元素的个数+1
        N++;
    }



    /*
     * 该删除方法的实现原理是先找到对应的结点，然后将对应结点的上一个
     * 结点指向对应结点的下一个结点
     */
    //删除符合表中键为key的键值对
    public void delete(Key key){
        //先构建循环找到键为key的结点
        Node n = head;//同样先创建n保存头结点
        while (n.next!=null){
            //判断n结点的下一个结点是否为key，若是就进入方法
            //由于n最初是头结点，因此先构建代码n.next没有问题
            if(n.next.key.equals(key)){
                //令被删除结点的上一个结点的尾指针域指向被删除结点
                //的下一个结点
                n.next = n.next.next;
                N--;
                return;
            }
            //若不是则令n进入下一个结点
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while (n.next!=null){
            //令n进入其所指向的下一个结点
            n = n.next;
            //判断是否是与传入的key的值相同的结点
            if(n.key.equals(key)){
                //若是则返回该结点的value
                return n.value;
            }
        }
        //代码执行到此说明符号表内压根没有对应的key，返回null
        return null;
    }
}
```

