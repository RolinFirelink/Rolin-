现在我们来学习行为型模式里的最后一个模式，解释器模式，我们先来看看其概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE591a2b7ecbbff929df736d610fd3ac9a.png)

也就是说，我们的确可以通过几个简单的方法来实现加减法，但是这样实现的内容不但形式单一，而且不符合要求，那么我们就需要一种可以翻译的机器，可以解析我们传入的运算序列

我们可以将运算符和数字都看做结点，那么我们目标就是希望能够对逐个结点进行读取并解析运算，这就是解释器模式的思维

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE433b6c4e7c48f252dba1b7b960f6c5ea.png)

我们的解释器就是要解析出来的语句的含义，那么剩下的问题就在于我们要如何描述我们的语法规则

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfd62f77d302606037ab12b899f9ae861.png)

上面的图中，expression表达的是我们的表达式，表达式中的 | 指的是与操作，也就是说，我们的一个表达式可以由value，plus以及minus组成，这三个在下面都有定义

我们的plus操作应该由两个表达式以及一个+号连接组成，minus操作则是有-号连接，而value的值我们这里规定只能为Integer类型的值，上面的内容则定义了我们的语法结构的形式规则，其本身就作为一个文法

在计算机科学中具有抽象语法树结构，简称语法树，我们一般用这种结构来表达符合文法结构规则的句子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE284563da9f1abf8a1ced331ca8828af5.png)

接着我们来通过一个案例来加深我们对解释器模式的理解，首先我们来看看其案例的需求和类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdbd16d66322d772a76fbd3c29f8ac899.png)

首先我们创建抽象表达式类，其是一个抽象类，定义了一个抽象方法，该方法需要传入一个环境类（当前未创建），然后返回一个int类型的结果

```
//抽象表达式类
public abstract class AbstractExpression {
    public abstract int interpret(Context context);
}
```

然后我们定义我们的环境角色类，其下拥有Map集合类，用来存储变量以及对应的值，我们还提供了添加变量的方法，需要提供保存变量的Variable类以及具体的值（保存变量的类还未定义），还有一个获取对应值的方法

```
//环境角色类
public class Context {

    //定义一个Map集合，用来存储变量及对应的值
    private Map<Variable,Integer> map = new HashMap<>();

    //添加变量的功能
    public void assign(Variable var,Integer value){
        map.put(var,value);
    }

    //根据变量获取对应的值
    public int getValue(Variable var){
        return map.get(var);
    }
}
```

接着我们定义封装变量的类，这里我们往其中定义一个封装变量的类，其当然要继承我们的抽象表达式类，其中提供一个String属性用于保存我们的变量名，重写的方法中我们直接返回变量的值即可，因此我们这里直接调用传入的环境类的getValue方法，传入当前的变量对象，即可从环境类中的map集合中获得我们所需要的值

最后我们还重写了toString方法，重写这个方法是为了让我们后期能够正确打印我们的文法语句

```
//封装变量的类
public class Variable extends AbstractExpression{

    //声明存储变量名的成员变量
    private String name;

    public Variable(String name) {
        this.name = name;
    }

    @Override
    public int interpret(Context context) {
        //直接返回变量的值
        return context.getValue(this);
    }

    @Override
    public String toString() {
        return name;
    }
}
```

接着我们定义我们的加法表达式类，其下应该聚合了两个表达式类的属性，分别保存+号左右两边的内容，我们重写父类的方法，让我们的方法调用我们的属性中的计算结果的方法并将环境对象继续传入，最后我们提供一个toString方法用于打印我们的语法表达式

```
//加法表达式类
public class Plus extends AbstractExpression{

    //+号左边的表达式
    private AbstractExpression left;
    //+号右边的表达式
    private AbstractExpression right;

    public Plus(AbstractExpression left,AbstractExpression right){
        this.left=left;
        this.right=right;
    }

    @Override
    public int interpret(Context context) {
        //将左边表达式的结果和右边表达式的结果进行相加
        return left.interpret(context)+right.interpret(context);
    }

    @Override
    public String toString() {
        return "("+left.toString()+"+"+right.toString()+")";
    }
}

```

同样对于减法表达式类也是一样的

```
//减法表达式类
public class Minus extends AbstractExpression{

    //-号左边的表达式
    private AbstractExpression left;
    //-号右边的表达式
    private AbstractExpression right;

    public Minus(AbstractExpression left, AbstractExpression right){
        this.left=left;
        this.right=right;
    }

    @Override
    public int interpret(Context context) {
        //将左边表达式的结果和右边表达式的结果进行相减
        return left.interpret(context)-right.interpret(context);
    }

    @Override
    public String toString() {
        return "("+left.toString()+"-"+right.toString()+")";
    }
}
```

最后我们再测试类中写入我们的代码如下，这里我们来解释下我们的这份代码的执行过程，因为还是有点复杂的，先解释下好，免得以后看不懂

首先我们创建对应的环境变量，然后我们创建多个变量对象，提供唯一标识，然后我们将对应的变量存储到我们的环境对象中，这里我们还设置了对应的值，分别是1234，接着我们来获取我们的抽象语法树，我们这里通过直接创建对应的类的方式来指定构建我们的语法树，而每个语法树中都应该要设置两个变量对象，每一个new的对象代表的是要两个变量要执行的运算，并且其都会返回一个新的保存变量对象，最终我们构造出了我们的语法树

然后我们调用语法树中的计算方法，我们的语法树最开始的真实对象是Minus对象，首先我们就调用Minus类中的interpret方法，然后我们需要调用两个保存的变量类中的interpret方法获得对应的值用于计算，如果最终我们往内部传入的值并不是一个变量类，而是一个计算类，那么其就会递归调用方法，继续进入到同样的方法中去执行计算过程，而由于我们总是能保证我们任何一个计算类最终总是保存了两个变量类的，因此最终我们虽然调用同样的方法，但是由于类的特殊性，我们总是能够让我们的方法正确停止，这也是为什么我们的保存变量的类也叫做终结符表达式，计算类又被称为非终结符表达式

```
public class Client {
    public static void main(String[] args) {
        //创建环境对象
        Context context = new Context();

        //创建多个变量对象
        Variable a = new Variable("a");
        Variable b = new Variable("b");
        Variable c = new Variable("c");
        Variable d = new Variable("d");

        //将变量存储到环境对象中
        context.assign(a,1);
        context.assign(b,2);
        context.assign(c,3);
        context.assign(d,4);

        //获取抽象语法树 a+b-c+d
        AbstractExpression expression = new Minus(a,new Plus(new Minus(b,c),d));

        //解释（计算）
        int interpret = expression.interpret(context);
        System.out.println(expression+"="+interpret);
    }
}

```

最后我们可以得到这个结果，左边是我们对应的语法树，右边是我们的结果

```
(a-((b-c)+d))=-2
```

最后我们来看看该模式的优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc5d3155b3f08951b2a476b542be9a7ca.png)

