我们研究算法的最终目的是如何花更少的时间，如何占用更少的内存去完成相同的需求

有关算法的时间耗费分析，我们称之为算法的时间复杂度分析

有关算法的空间损耗分析，我们称之为是算法的空间复杂度分析

现在我们先来研究下算法的时间复杂度分析



算法的时间复杂度分析

算法的时间复杂度分析方法有两种，一种是事前分析估算方法，另一种是事后分析估算方法



事后分析估算方法

先来讲讲事后分析估算方法，请看代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb718a7d121cd2ef1e1c5e18d3995f71.png)

简而言之事前分析估算方法就是方法执行前获取一个当前时间，执行后获取一个当前时间，然后打印时间差，这样来获得方法运行需要的时间

这个方法很简单，但是这种方法缺陷很大，需要耗费大量时间去做一个测试程序，耗费时间高，因此一般不用



事前分析估算方法

事前分析估算方法是指在计算机编写程序前依据统计方法对算法进行估算，我们已知影响算法的运行时间的有以下原因

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE158a96c4c440150151fc42abbab05100.png)

其中2和4是我们程序员所无法决定的，是无法改变的东西，因此我们不予理会，只用1和3进行分析

这样一个程序的运行时间就只依赖于算法的好坏和问题的输入规模了，如果算法还固定了，那么就只和输入规模有关系了

那么我们再次回到我们之前的求和案例，进行分析

先看第一种解法的代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe6a49735d93548fe358a25ee3e0adf62.png)

我们不难发现，这个代码真正执行的次数的总和为2n+3次，而用于计算结果的代码执行的次数则为n次

在看第二种解法的代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf5afb559454c2027aeeada4c7d0c1be2.png)

而这个代码发真正执行次数的总和为3次，用于计算结果的代码执行了1次

由于n次执行显然比1次执行要慢，所以我们肯定会采用1次执行的代码好

这里我们不用总和来进行比较，而用核心的用于计算的代码进行比较，这是因为如果我们关注总和，用总和来进行比较的话，那光是分析总和到底有几次都有够折磨了，为了我们算法分析的渐变和统一，我们只关注其核心代码的执行次数，这里是进行了一个简化分析

我们分析一个算法的运行时间，最重要的是把核心操作的次数和输入规模关联起来

接下来我们来看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1dbce3c6ce79bb721ba8c95e4bcc6923.png)

在本图里，n是我们的输入规模，f(n)是我们的运行时间，而f则是我们的代码核心运行次数

在这里，显然黄函数要优于红函数优于紫函数，我们写代码时，也要尽量追求我们的代码达到红函数和黄函数的函数关系，而不是紫函数



接下来我们来研究函数的渐变增长

先来看看概念

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb31e76faf46379265060cf61f18c4ec.png)

其实也不难

比方说当A1(2n+3)与B1(3n+1)时，易知当n>2时，y1恒大于y，此时我们就可以说当n>2时，算法A1的渐进增长小于算法B1的渐进增长，其中n是输入规模

我们由分析易知当N极大时，A1与B1几乎的曲线几乎一致

因此我们可以得出结论，随着输入规模的增大，算法的常数操作可以忽略不计

我们可以再举一个例子，比方说当A2(n^2)与B2(2*(n^2)+1)，当我们的n很大很大时，最终他们的曲线都会十分接近，而他们不止是有着常数的不同，还有着还有着与最高次数项相乘的常数的不同

由此我们可以得出结论，随和输入规模的增大，与最高次项相乘的常数可以忽略

我们再举一个例子，比方说当A3(2n^2+3n+1),B3(2n^3+3n+1)，我们不难发现当n大于2之后，B3的增长速率远高于A3

由此我们可以得出结论，最高次项指数大的，随着n的增长，结果也会变得增长特别快

再经过一些其他图像的分析和推导，我们得出一个结论是算法函数中n的最高次幂越小，算法效率越高

最后我们总结一下规则

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE77f71d5d9f7bb6211a1357c24165edf4.png)



大O记法

我们先来看看它的定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9819fcd42c4a3cb2a1636b4de1df3d60.png)

或许你看不懂，但没关系，我也看不懂，看不懂就先放着，反正影响不大

在这里我们先记住两点就行了

第一点是，我们在大O记法里，明确了执行次数=执行时间

其次是，一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优解

我们先来看看下面三个代码

首先是第一个代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc0b42682b29482a5b27409f2c44803f2.png)

这个代码的总执行次数为3次

接着是第二个代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8bc0c34b98fb35ccaf9efcc5b4d2d711.png)

第二个代码的总执行次数为n+3次

最后是第三个代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9416e658a90013dcd60e2f4f00073017.png)

第三个代码的总执行次数是n^2+2次

那么我们要如何用大O记法来表示上面三个算法的时间复杂度呢？

首先基于我们之前学习过的对函数渐进增长的分析，我们有以下三条规则可以使用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc8ee30e5e07617005c507fcc22ca13ff.png)

这样，第一个算法的总执行次数是3，由于只有一个常数，运用规则1，所以用大O记法表示为O(1)

第二个代码的总执行次数是(n+3)次，由于3是常数，因此3先改为1，又因此规则2，所以最终表示为O(n)

第三个代码的总执行次数是n^2+2次，同理其表示为O(n^2)



常见的大O阶

O(1)为常数阶，一般不涉及循环操作的都是常数阶

O(n)为线性阶，一般含有非嵌套循环涉及线性阶

O(n^2)为平方阶，一般嵌套循环属于这种时间复杂度

O(n^3)为立方阶，一般三重嵌套循环属于这种时间复杂度

来看看下面的代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0f29c248d6027b2e334f1d2bac303cf1.png)

在这个代码里，我们可以设程序执行次数为x，即是假设有x个2相乘之后会跳出循环，则可得式子2^x=n;则可得x=log(2)，其中x为程序执行的次数，即是我们平时用大O阶表示的n

则这个算法的时间复杂度是O(logn)，之所以我们这里直接写log，是因为log的底数无论是多少，随着输入规模的增大，到最后都是趋于一致的，因此可以省略，这种大O阶叫对数阶

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcf7f0e0656dcb50dfec9afdc77504767.png)

上述大O阶的复杂度从低到高分别为

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb78b79f0b92efeb9e533a22e39883c12.png)

一旦我们的复杂度倒数两位甚至更高，比如说平方阶或者立方阶时，即说明我们的算法效率很低，需要优化



函数调用的时间复杂度分析

实际我们写的算法里，我们常常会运用到函数，我们计算其时间复杂度时，肯定会不可避免的要对函数调用时进行分析，因此我们接下来学习函数调用的时间复杂度分析

请看代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2df9be3ebe4f0bac24954f1b61c7ae67.png)

在上面的代码里我们的核心代码，第四行代码执行了n次，在方法里的代码都会执行一次，那么总和为n，而在方法里没有循环，则其为线性阶O(n)

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa29fb0708822ad3cdab8ac589117296f.png)

上面的算法里，调用了n次方法，而在方法里又进行了n次循环，则代码的执行总次数为n^2，则其为平方阶O(n^2)

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1353a3b70d0c6af31e4715b980db9dde.png)

在上面的算法里，我们先调用了一次方法，在方法里的代码执行了n次，然后们调用了n次方法，在方法里的代码又执行了n次，接着我们跳出了方法之后又执行了一个嵌套循环，又执行n^2次，所以我们的方法总共执行2(n^2)+n

则其为平方阶O(n^2)

我们的算法总是有最好情况与最坏情况的，好的情况下第一次就找出来了，坏的情况下查找到最后还能查找出来，我们要写的算法必须要保证其在最坏情况下也能够高效率的运行，而不能整出只有在特定情况下才能运行良好的程序来

以后我们研究的算法的时间复杂度时，一般也是以最坏情况来分析的



算法的空间复杂度分析

