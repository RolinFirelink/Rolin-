现在我们来学习结构型模式中的适配器模式，我们先来看看什么是适配器模式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE11cc19ad7bd181d0b7e47bd82293bc63.png)

其定义就是将一个类的接口通过适配器类转换成我们所需要的另外一个接口，适配器模式又分为两类，分别是类适配器模式和对象适配器模式，前者的耦合度比后者高，且对程序员的要求也高，因此现在都是后者用得比较多

适配器模式主要包含三个主要角色，分别是目标接口（用户所期待的抽象类或者是接口）、适配器类（是一个转换器，将适配者接口转为目标接口）、适配者类（最初提供的组件接口）这三个

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1c6345a7b84acd009f8b42dad2a71a8b.png)

接着我们来做一个案例来加深我们对适配器类的理解，一台电脑只能读取SD卡，而如果需要读取TF卡的内容就需要用到适配器模式，我们创建一个适配者类（相当于读卡器），让我们的电脑也能够读取TF卡

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdfe4fecd9e23b0d857edc03a033a817f.png)

我们先来用类适配器模式来实现这个案例，首先我们需要创建对应的SD卡和TF卡类的接口及其实现类

首先我们创建SD卡类的接口，其拥有最基本的读取与写入数据的方法

```
public interface SDCard {

    //从SD卡中读取数据
    String readSD();

    //往SD卡中写数据
    void writeSD(String msg);
}
```

然后我们写入其实现类

```
public class SDCardImpl implements SDCard{

    @Override
    public String readSD() {
        return "SD卡读取数据成功";
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("往SD卡中写入数据："+msg);
    }
}
```

然后我们创建TF卡的接口，其同样拥有两个方法，也是写入写出

```
public interface TFCard {

    //从TF卡中读取数据
    String readTF();

    //往TF卡中写数据
    void writeTF(String msg);
}
```

我们同样写入其实现类

```
public class TFCardImpl implements TFCard{

    @Override
    public String readTF() {
        String msg = "TF卡读取数据";
        return msg;
    }

    @Override
    public void writeTF(String msg) {
        System.out.println("写入数据："+msg);
    }
}
```

然后我们创建一个电脑类，其提供一个往SD卡中读取数据的方法

```
public class Computer {

    //从SD卡中读取数据
    public String readSD(SDCard sdCard){
        if(sdCard == null){
            throw new NullPointerException("SD卡不能为空");
        }
        return sdCard.readSD();
    }
}
```

接着我们需要创建一个适配器类，该适配器类可以将实现让我们的电脑类能够读取TF卡的数据，相当于这个适配器类可以让TF卡的数据被只能读取SD卡数据的电脑读取，那我们应该要怎么创建这个适配器类呢？

我们注意看我们之前的图中里的实现方式，适配器类要实现当前系统的业务接口，同时又需要继承现有组件库中已经存在的组件。那么我们可以让我们的适配器类继承我们的已经存在的TFCard的实现类的组件，然后再令其实现SD卡读取的方法的系统中的业务接口

然后在对应的读写方法中调用我们的TF父类中的方法即可

```
public class SDAdapterTF extends TFCardImpl implements SDCard{

    @Override
    public String readSD() {
        System.out.println("适配器类读取TF卡");
        return readTF();
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("适配器类往TF卡中写入数据");
        writeTF(msg);
    }
}
```

接着我们写入我们的测试类的代码如下

```
public class Client {
    public static void main(String[] args) {
        //创建计算机对象
        Computer computer = new Computer();
        //读取SD卡中的数据
        String msg = computer.readSD(new SDCardImpl());
        System.out.println(msg);

        System.out.println("========================");
        //使用该电脑读取TF卡中的数据
        //定义适配器类
        String s1 = computer.readSD(new SDAdapterTF());
        System.out.println(s1);
    }
}
```

可以看到我们这里计算机对象，读取SD卡的数据就传入SD卡的实现类，如果要读取TF卡的数据就往内部传入TF卡的适配器对象，最终我们就可以得到我们的所需要的读取TF卡数据的结果

在我们的上面的例子中，SDCard和SDCardImpl是目标接口，而TFCard和TFCardImpl是适配者类，而SDAdapterTF是适配器类。当然，有的同学可能会说，我们这个原来就有sd卡功能，后面我们要实现的是读取TF卡功能，显然TF类才是目标接口，SD卡才是最初的适配者类吧？其实，我也是这么觉得的，但是事实上就是我们只能按照上面的方式去理解，最终我们才能够得到我们想要的结果，否则最终我们得到的结果还是读取SD卡的数据，而非TF卡的数据，所以我们只能这么理解了，暂时先记住就得了，反正类适配器模式也不是很重要

后面我们对这个例子进行了一些尝试性的修改，看看能不能用我们的理解去完成这个例子想要的效果，最终的结果是不可以，我认为这个例子本身应该是没有问题的，但是我们的常识理解和代码设置的方式出现了问题，这个问题具体要怎么理解合适现在还不是很懂，总之先放着吧。不过可以确定的是，要实现的接口肯定是我们的目标接口，这个目标接口必然是我们的客户端已经存在的功能，我们的适配器类也必须实现这个接口，否则适配器类就无法被我们的最先的客户端类调用，而适配器类继承或者是聚合的内容必然是最初提供的组件类，也就是一开始我们拥有但是还不是我们所需要的类的类

最后我们来提一下类适配器的缺点，类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。

- 对象适配器

现在我们来讲下对象适配器模式，首先我们来看看其实现方式和改造后的类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE30e0572f60938e796eeca278786a8c99.png)

其实我们只需要对我们的适配器类稍作改动即可，我们需要将继承我们的先有的组件库TFCard类改为聚合TFCard类，具体到代码中就是往里面注入TFCard类对象并提供一个设置对应的属性值的构造方法，然后重写的方法就调用该属性的内部的对应方法即可

```
public class SDAdapterTF implements SDCard{

    //声明适配者类
    private TFCard tfCard;

    public SDAdapterTF(TFCard tfCard) {
        this.tfCard = tfCard;
    }

    @Override
    public String readSD() {
        System.out.println("适配器类读取TF卡");
        return tfCard.readTF();
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("适配器类往TF卡中写入数据");
        tfCard.writeTF(msg);
    }
}
```

最终我们的测试类代码修改成如下形式，我们这里创建适配器类对象，然后直接往其内部传入TFCarl的子实现类，然后我们调用中的读取方法时只要将对应的适配器类对象传入即可

```
public class Client {
    public static void main(String[] args) {
        //创建计算机对象
        Computer computer = new Computer();
        //读取SD卡中的数据
        String msg = computer.readSD(new SDCardImpl());
        System.out.println(msg);

        System.out.println("========================");
        //使用该电脑读取TF卡中的数据
        //创建适配器类对象
        SDAdapterTF sdAdapterTF = new SDAdapterTF(new TFCardImpl());
        String s1 = computer.readSD(sdAdapterTF);
        System.out.println(s1);
    }
}
```

其实这个就相当于是我们构造了适配器类，这个适配器类中有SD卡的接口，我们的电脑可以通过操作这个适配器类来完成对SD卡的具体操作

- 注意事项和应用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7ec5d464447c6782903a21651efeff7b.png)

- JDK源码解析

这个直接看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE944710beaab90ba2b007c2a4672e188a.png)

最后提一嘴，这一节说实话我不是很理解，我觉得这个课程这一部分讲的也是有点烂，以后有时间还是要自己去看点别的课程重新理解下