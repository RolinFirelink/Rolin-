现在我们来学习装饰者模式，我们先来看一个快餐店的例子

快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦

来看看类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa93fb67a1662c2b1ad500eb2445fd901.png)

那么我们采取继承的方式来实现上面的快餐店案例存在什么问题呢？

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE885ef5c3d00e22a5232bdd7295d638f8.png)

接着我们来看看装饰者模式的定义和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7898057f7211d9197c7bcbe390d9753a.png)

光看上面的描述肯定是不足够的，我们现在来用我们的装饰模式来完善我们上面的案例来加深我们的理解

我们先来看看类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE157ee5bc3d1e8f73338895d7fccbd154.png)

首先我们要创建最重要的抽象构件角色，该角色是作为我们后续接受其他对象的一个规范对象，我们在其中定义两个最基本的菜品属性，分别是名字和价格，然后提供对应的构造和getandset方法，最后我们还写入一个抽象的cost方法

```
//抽象构件(Component)角色
public abstract class FastFood {

    private String desc;
    private float price;

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public FastFood() {
    }

    public FastFood(String desc, float price) {
        this.desc = desc;
        this.price = price;
    }

    public abstract float cost();
}

```

然后我们来创建具体的构建角色，这里我们的具体构建角色有两个，分别是炒面和炒饭类

由于这两个类都大差不差，我们这里就只展示一个了，我们这里令其继承最初的抽象构建类，然后构造方法中我们存入自己的构造方法来创建一个快餐对象，存入的东西当然则是我们自己指定的对应快餐的名字和价格，然后我们还要实现其对应的花费方法，这里我们直接调用父类的获得价格的方法即可

```
//具体构件角色
public class FriedNoodles extends FastFood{

    public FriedNoodles() {
        super("炒面",12);
    }

    @Override
    public float cost() {
        return getPrice();
    }
}
```

接着我们构建抽象装饰者角色，该类是抽象类并且继承最初的抽象构建类，且其下还聚合了抽象构建类的实例，我们同样提供对应的构造方法，构造方法做两件事情，第一件事是将类中的属性注入对应的快餐类，第二件事情是设置该类继承父类的快餐类对应的数据，这样我们的装饰者类中就可以表示两个快餐对象，一个是我们属性中的快餐类，另外一个是我们自己注入的快餐类

```
//装饰者类(抽象装饰者角色)
public abstract class Garnish extends FastFood{

    //声明快餐类的变量
    private FastFood fastFood;

    public Garnish(FastFood fastFood,String desc, float price) {
        super(desc, price);
        this.fastFood = fastFood;
    }

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;
    }
}
```

最后我们则要设置具体的装饰者角色，我们这里需要设置鸡蛋和培根类两个，同样因为大差不差所以我们这里只展示一个，我们的具体装饰者角色要继承我们的抽象装饰者类，同样提供构造方法，构造方法必须要提供当前的快餐对象，用于给装饰者类注入该对象到其属性中，然后自己在传入自己要设置的快餐数据进去

同时提供计算价格和名字的方法，计算的价格就从注入对象和自己设置的快餐对象中计算总和并返回，获得全名的方法也是同理

```
//鸡蛋类(具体的装饰者角色)
public class Egg extends Garnish{

    public Egg(FastFood fastFood) {
        super(fastFood,"鸡蛋",1);
    }

    @Override
    public float cost() {
        //计算价格
        return getPrice()+getFastFood().cost();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}
```

最后我们写入我们的测试类代码如下

我们稍微来解释一下这些代码的工作流程，不然别以后再回来看的时候直接看不懂了。我们这里首先创建一份炒饭对象，然后我们打印炒饭的名称和钱

接着我们通过Egg的构造方法通过炒饭对象构建一个蛋炒饭对象，这里发生的过程是，我们的炒饭对象进入到Egg的构造方法中，该构造方法又会调用其继承的Garnish的构造方法，这样我们的对象就拥有了一个快餐类变量，该变量存储着我们炒饭对象，然后其自身又是一个快餐，其内部就存放着我们的鸡蛋的菜品的数据，由于其本身的究极父类还是一个快餐对象，因此我们可以用最初的快餐对象去承接这个新对象，然后我们同样调用其获得名字和花费的方法，此时我们调用的获取名字方法会从鸡蛋类中调用获取名字的方法，该对象会调用当前具有的快餐对象的名字并且拼接属性上的快餐名字然后返回，最终我们会得到我们拼接的新菜品的名字，对于获取价格的方法，也是一样的

然后我们再点一个鸡蛋，也是依葫芦画瓢，同样将对应的菜品对象设置到父类的属性中，然后将自己的数据设置到当前的菜品数据中，不过这样我们的最后构造的对象就会形成一个嵌套的形式，具体表现在于，我们的一个菜品的属性还会有下一个菜品属性，我们对方法的调用也会变成一个嵌套的调用，这有些类似于递归，递归的话就要考虑溢出问题，不过这里显然不需要考虑，因为一般没人能点一个菜品加东西加到超出我们的内存

```
public class Client {
    public static void main(String[] args) {
        //点一份炒饭
        FastFood friedRice = new FriedRice();

        String s1 = friedRice.getDesc() + " " + friedRice.cost();

        System.out.println(s1);


        System.out.println("====================");

        friedRice = new Egg(friedRice);
        s1 = friedRice.getDesc() + " " + friedRice.cost();
        System.out.println(s1);

        System.out.println("====================");

        friedRice = new Egg(friedRice);
        s1 = friedRice.getDesc() + " " + friedRice.cost();
        System.out.println(s1);

        System.out.println("====================");

        friedRice = new Bacon(friedRice);
        s1 = friedRice.getDesc() + " " + friedRice.cost();
        System.out.println(s1);
    }
}
```

可以得到如下结果，这种结果就是我们想要的动态的结果了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0658fede7ed8af1b5740fa38768a97d3.png)

那么到此为止，我们的案例就算是改善完了，如果我们想要添加菜品，我们就只需要添加一个类令其继承FastFood对象即可，如果我们想要继续添加配料，那么只要创建一个类令其继承Garnish即可，这样就非常的方便，非常地好用

最后我们再来看看其好处和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3bfe59a5a15e9f0e6e0051a53c7be12c.png)

- JDK源码解析

IO流中的包装类就用到了装饰着模式，我们先来看看其使用方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE39ddcbb58ea0784aa678094aadfd6da8.png)

最后我们来看看其结构，一分析我们会发现它的确是装饰者模式的结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc791c6e1841a678ede3f51bceff68730.png)

最后我们来看看代理模式和装饰者模式的区别

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe47a7d29e41978943e9f57e1af98c354.png)

