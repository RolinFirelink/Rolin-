然后我们来学习软件的设计原则，其下的设计原则有很多种，我们先来学习第一种原则，开闭原则

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE057afb3c70ee1e6a4889ba4544f43669.png)

开闭原则的最简单的例子就是以搜狗输入法为例，我们可以将皮肤设计定义为一个抽象类，然后任何一个不同的皮肤都可以以实现类的形式接入到我们的软件中，用户修改皮肤，就不需要更改源代码，只需要自己增加一个实现类即可（当然，我们会有工具来帮忙生成这个实现类）

我们下面的类图表示的意思是，我们有两个类继承了一个抽象的父类，同时一个类实现了这个抽象的父类

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE49368add266e9b6f83932248ed7eaf83.png)

- 开闭原则案例实现

这个案例非常简单，我就不写了，我们记住我们的开闭原则的本质是要对修改关闭，对扩展开放。也就是说，我们允许别人添加代码，但是我们不允许别人修改我们的代码，就是这么简单。

- 里氏代换原则

接着我们来学习里氏代换原则，其是面向对象涉及的基本原则之一，其基本原则就是任何父类可以出现的地方，子类一定可以出现。通俗的来说，子类可以扩展父类的功能，但是不可以改变父类原有的功能。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbbb6f1f1a331ead2ff705a762314343c.png)

比方说我们可以举一个长方形和例子，首先我们构建长方形类的代码如下

```
public class Rectangle {
    private double length;
    private double width;

    public double getLength() {
        return length;
    }

    public void setLength(double length) {
        this.length = length;
    }

    public double getWidth() {
        return width;
    }

    public void setWidth(double width) {
        this.width = width;
    }
}
```

我们顺理成章的会让我们的正方形类继承我们的长方形类，那么我们还可以构造我们的正方形类的代码如下

```
public class Square extends Rectangle {

    public void setWidth(double width) {
        super.setLength(width);
        super.setWidth(width);
    }
    public void setLength(double length) {
        super.setLength(length);
        super.setWidth(length);
    }
}
```

接着我们写入我们的测试类的代码如下

```
public class RectangleDemo {

    public static void resize(Rectangle rectangle) {
        while (rectangle.getWidth() <= rectangle.getLength()) {
            rectangle.setWidth(rectangle.getWidth() + 1);
        }
    }

    //打印长方形的长和宽
    public static void printLengthAndWidth(Rectangle rectangle) {
        System.out.println(rectangle.getLength());
        System.out.println(rectangle.getWidth());
    }

    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle();
        rectangle.setLength(20);
        rectangle.setWidth(10);
        resize(rectangle);
        printLengthAndWidth(rectangle);

        System.out.println("============");

        Rectangle rectangle1 = new Square();
        rectangle1.setLength(10);
        resize(rectangle1);
        printLengthAndWidth(rectangle1);
    }
}
```

这里我们的测试类提供了更改对应的长方形的边长的代码，我们更改长方形的边长的方法就是更改长方形对应的长宽，而正方形的话则是直接改其长和宽，那么我们的这行测试代码就是产生不断重复进入死循环的问题，为了解决这个问题，我们的一个方法就是我们用一个四边形的接口来实现正方形和长方形类，这样正方形和长方形不存在继承关系，那么就不会违背里氏代换原则了

最后我们来说一下图里的类图的关系，我们有两个类实现了一个四边形的父类，然后我们的测试类在执行某些方法的时候会依赖这个四边形接口的实现类，不过这里应该是依赖的关系画错了，画成了实线，应该是虚线的，而且这个线我觉得也不该对这个接口有指向，因为其依赖的是他的实现类而不是其四边形类

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE86ee05974cdc0cfeb42d7dcbba200291.png)

- 依赖倒转原则

接着我们来学习依赖倒转原则，所谓的依赖倒转原则，其实就是我们的开闭原则的ProMax版。这个原则讲起来很麻烦，但是其实本质很好理解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE54230bc9aa6bf18148621fff1bef8a4a.png)

比方说我们要做一台电脑，电脑下有许多的配件，如果我们直接定义对应的实现类为成员变量的话，那么我们要更换成员变量的时候，我们就必须要重新修改原来的代码，那样就很麻烦，但如果我们将每个实现类的特点抽取出一个接口，然后用这些接口去代替我们的实现类，这样的话就可以达到我们所需要的更换效果，用新的实现类直接换就行了，不需要修改原来的代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8d68022ce5f518a9e92f226fa2a3bf8d.png)

- 接口隔离原则

接着我们来学习接口隔离原则，所谓的接口隔离原则，简单理解就是如果子类继承父类时，同时继承了父类中自己不需要的方法，那么就应该将方法抽离成接口，以接口的形式赋予给父类和子类。

我们可以举一个安全门的例子，比方说我们要建造一个安全门，其拥有防火防盗防水的功能，于是我们就将这三个功能抽离成一个接口，但是如果我们还要建造一个安全门，其拥有防火防盗但没有防水的功能，此时我们如果还是用原来的接口，那么就会有一个功能没有用到，直接继承原来的类，也会是同样的情况，所以此时我们的改进方法就是将这三个功能都抽离出来，然后在对应的类中实现这三个技能即可，因为java是支持多继承的，因此创建多个接口是可行的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd55320e809c073036c7327c2ab5f8456.png)

- 迪米特法则

迪米特法则简单来说，就是创建一个中间类，这个中间类用于帮助两个类的协作（当然，如果有一些必须要直接沟通，那么就不必创建中间类），这就类似于是明星和经纪人之间的关系，具体可以看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc9c2b7e2846eca791ea6b7c2baf77127.png)

最后我们要提一下的是就是迪米特法则里的朋友指的是当前对象本身、当前对象的成员变量、当前对象所创建的对象、当前对象的方法参数等

- 合成复用原则

接着我们来学习我们的最后一个原则，合成复用原则。合成复用原则指的是，我们的类如何和其他的类有关系，那么我们尽量使用组合或者是聚合等关联关系来实现，其次再考虑使用继承关系来实现。简单来说，如果我们可以将另一类令其成为一个类的成员变量来达到我们的使用的目的，那么就尽量用这种方法，而不要去使用继承关系，至于原因就请看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE42a5d7a37c2a81c6bc4eb8b776508ac3.png)

我们可以举一个汽车分类管理程序的例子来帮助我们的理解，假如我们采用继承的方式来添加我们的汽车组合，那么我们要重新定义一个新的汽车类，然后还要令其继承原来的新汽车类，再定义颜色类，这样太麻烦了

但如果我们将其改为聚合复用，将颜色改为汽车的一个属性，那么我们一个就可以省略定义不同颜色的类了，依葫芦画瓢我们还可以将不同的汽车类也定义为属性，这样就可以省略很多类的构建了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE06fe62d6dc1779be61b32686d3f3bba4.png)

