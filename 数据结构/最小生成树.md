我们不妨先来看看最小生成树的定义，先搞明白到底什么是最小生成树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2447949285490ad9ec85e6d87de86ef1.png)

首先图的生成树是其一颗含有所有顶点的无环连通子图，这里有三个重点，一是含有所有顶点，二是无环，三是连通子图，最小生成树则是一副加权无向图中一颗权值之和最小的生成树，比方说在这里，红色边与其连接的顶点组成了该图的最小生成树

同时为了便于我们的理解，我们这里做两个约定，一是我们的图只考虑连通图，二是我们的图的每一条边的权重是不能相同的。这两个约定的出现主要是为了便于我们理解和实现最小生成树的数据结构

那我们要如何从一副图中找到其最小生成树呢？这就要用到切分定理

在我们正式去实现最小生成树的数据结构之前，我们必须先学习切分定义，而如果我们要学习切分定理，我们就要先来学习一些概念上的知识，首先是关于最小生成树的性质

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3095c3817aeb6166e865e39148e663b4.png)

接着我们要先了解一些相关术语代表的意思，首先是切分和横切边

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4162800c773ea499b6628fd5e71b51f3.png)

切分指的是将所有顶点按照某种规则将其分为两个非空无交集的集合

横切边指的是连接像个属于不同顶点的横切边，比方说在上图里，黑色集合和白色集合是两个非空无交集的集合，而上图里的黑色线就都属于横切边

那么学习完了上面的知识之后，我们现在正式来学习下什么是切分定理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE113b92980f592ae6e9db1ea65eb36515.png)

所谓切分定理，即是在一副加权图中，给定任意的切分，那么其横切边中权重最小的边必然属于图中的最小生成树。这里值得注意的是，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边

比方说在上图中ef，虽然f在这一次的切分中不是最小生成树的边，但是在其他的切分中，其就有可能是最小生成树的边

那么学习完切分定理之后，我们来学习由切分定理为基础的构造的贪心算法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4558a29e192f18ea625ad76ad3b253f6.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd30adacb843bcffbc3f1cdeaf19aea8f.png)

我本来想写一大堆关于这个贪心算法的分析的，但是我认真看了之后我属实整不明白他的切分规则到底是怎么设置的，似乎它是在瞎几把切，反正大体思路是看整个子图，先找到未有红色标记的边，然后观察整个图，用一定的规则将其切分成两个集合（每次切分时不用管前面所定义的集合），最后我们找到权重最小的边，这个边就是其最小生成树的边，最后我们发现我们所标注的红边已经把所有的点都连接起来的时候，我们的贪心算法就完成了，此时我们就找到了最小生成树，包含V-1条边

计算最小生成树的方法有很多种，但无论是哪种都可以看做是贪心算法的特殊情况，这些算法的不同在于保存切分和判定权重最小的方式

那么接下来我们来学习第一种计算最小生成树的方法，Prim算法

该算法的原理是先将图中的任意一个结点当做最小生成树的一个结点，然后切分定理将该结点集合与其他结点集合找出权重最小的横切边，将该横切边连接的另一个结点也当做是最小生成树的一部分，然后继续进行上面所说的切分过程，直到最小生成树里连接了所有的边

光说定义可能不好理解，我们直接来看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3a42cdb98c6e0fd490be6f1ce08fef29.png)

比方说在这里，利用Prim算法先将1结点视为最小生成树的一个结点，而其他的则是非最小生成树的结点，那么其横切边就容易找到，假设权重最小的横切边是1-2之间的边，那么改变就是最小生成树的边，将该边连接的两个结点都视为是最小生成树的一部分，然后继续进行切分，此时又会产生横切边，假设产生的最小横切边是2-3之间的边，那么同样将该边连接的结点视为最小生成树的一部分，与之前的一部分共同组成新的最小生成树，然后继续切分.......

接下来让我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE505f845645528208fff5bbdf74107b98.png)

其中edgeTo表示当前顶点和最小生成树的最短边，因为可能存在当前顶点与最小生成树存在多个边的情况，比如对于前一张图的w，我们假设其连接了两个最小生成树的顶点，那么此时我们这里的edgeTo数组的值就是保存当前顶点和最小生成树直接的最短边，其中索引表示顶点

而第四个索引优先队列的存在意义是存放树中与非树中顶点的有效横切边，由于其是索引优先队列，因此我们能利用其数据结构的特性来达到快速找出最小权重的横切边

学习完了上面的内容之后，我们再来学习下Prim算法的实现原理，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1e2699b8b67301d9a74b5b9879585023.png)

8指的是总结点树，16指的是总边数，这里初始化默认0位最小生成树的唯一结点，那么和0相连的边就是横切边，此时我们将对应的结点与最小生成树的边加入到索引优先队列中

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1089827a31423cf7dbbec511dfb6938d.png)

那么接下来我们找出其中最小的边，显然是0-7的边，那么其必然是最小生成树的边，那么我们就将该边和该边的结点添加到最小生成树中，其他的就不是最小生成树的边了，那么此时由于0-7这条边我们已经加入到最小生成树中了，其已经不是横切边了，因此我们需要将0-7的边从索引优先队列中消除，然后我们对新的生成子树做重复的上述动作给我们的索引优先队列完成添加，但此时我们要注意的是，此时2结点和4结点都有两条指向最小生成树的链接，此时我们要判断这两条连接的大小，我们只将小的连接的边加入到索引优先队列中，最后完成添加，然后继续重复上述动作，直到完成添加

这里使用索引优先队列的缘故是我们不但要查找处最小权重，还需要对权重值进行修改，因此用能够完成修改的索引优先队列

那么综上我们可以构造代码如下

```javascript
package algorithm.sort;

public class PrimMST {
    //索引代表顶点，值表示当前顶点和最小生成树的最短边
    //该成员变量有后面用于获取最小生成树的重要作用
    private Edge[] edgeTo;
    //索引代表顶点，值表示当前顶点和最小生成树的最短边的权重
    private double[] distTo;
    //索引代表顶点，如果当前顶点已在最小生成树中则标记为true，反之则为false
    private boolean[] marked;
    //存放树中顶点与非树中顶点的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权无向图，创造最小生成树创建计算对象(构造方法)
    public PrimMST(EdgeWeightedGraph G){
        //初始化edgeTo
        this.edgeTo = new Edge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            //赋予结点的权值为最大，便于后面不断去更新最小的权值
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化marked，成员变量默认全部赋值为false
        this.marked = new boolean[G.V()];
        //初始化pq
        pq = new IndexMinPriorityQueue<Double>(G.V());

        //默认让0进入到最小生成树中，此时0结点不关联任何边，因此其权值赋值为0.0
        distTo[0]=0.0;
        pq.insert(0,0.0);
        /*
         * 遍历索引最小优先队列,拿到最小横切边对应的顶点并将该顶点加入到最小生成树中
         * 这里调用delMin()方法会自动删除最小的索引并且返回被删除的索引，而索引代表
         * 结点，因此visit();方法这样构造代码可以理解为队列里执行了出队列的动作，并
         * 且同时将弹出的元素，也就是结点，和我们要寻找最小生成树的加权无向图一并传给
         * 了visit方法
         */
        while (!pq.isEmpty()){
            visit(G, pq.delMin());
        }
    }

    /*
     * 这里上面构建了while循环所以可以重复调用visit方法，每调用一次就会从队列中删除掉最小的结点
     * 但是在visit方法中，又会往pq中添加最小生成树的对应点和横切边，因此其能够实现不断调用，最后
     * 成功生成了最小生成子树时，不断调用visit方法的结果都不会再执行往pq中增添新结点和新边的代码
     * 最后其能够成功结束这个循环，然后此时保存在edgeTo中的边就是我们所需要的最小生成树的边，索引
     * 代表对应的结点
     */
    //将顶点v添加到最小生成树中，并且更新数据
    private void visit(EdgeWeightedGraph G,int v){
        //将该顶点标记为已加入最小生成树中的状态
        marked[v] = true;
        //将该顶点加入最小生成树，此处的e表示是对应的v结点的边，随着遍历的进行，其所代表的边也在不断变化
        for (Object e: G.adj(v)) {
            //获取e边上的另外一个顶点w(当前顶点是v)
            int w = ((Edge)e).other(v);
            //判断另外一个顶点是否已经在树中，若已经在树中则跳过添加
            if(marked[w]){
                continue;
            }
            //代码执行到此说明不在树中
            //判断边e的权重是否小于从w顶点到树中已经存在的最短边的权重，之所以用w，是因为这里的w就是
            //e边所对应的结点，对于第一次添加的结点而言distTo[w]自然是最大的，但是如果是第二次添加
            //就可能存在distTo[w]比起更大或更小的情况，这里你如果更小，那么就说明有必要更新最小权值
            //以及最小边
            if(((Edge) e).weight()<distTo[w]){
                //小于则更新最短边为该边
                edgeTo[w] = (Edge) e;
                //更新最小权值为该权值
                distTo[w] = ((Edge) e).weight();
                //判断pq中是否已经存放了该点的横切边
                if(pq.contains(w)){
                    //若已经存放则改变对应横切边的权值
                    pq.changeItem(w,((Edge) e).weight());
                }else {
                    //没有则添加新点到pq中
                    pq.insert(w,((Edge) e).weight());
                }
            }
        }
    }

    //获取最小生成树的所有边
    public Queue<Edge> edges() {
        //创建队列对象
        Queue<Edge> allEdges = new Queue<>();
        //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中，edgeTo里存放的是edge对象
        //是程序员自己定义的对象，如果没有赋值的话，调用构造方法时默认赋值为null，因此我们这里可以
        //采用这种方式进行边的添加
        for (int i = 0; i < edgeTo.length; i++) {
            if(edgeTo[i]!=null){
                allEdges.enqueue(edgeTo[i]);
            }
        }
        return allEdges;
    }
}
```



kruskal算法

那么我们在学习完了prim算法来查找加权无向图的最小生成树之后，现在我们来学习另外一种查找最小生成树的算法，kruskal算法。在学习kruskal算法之前，我们同样的也要先了解该算法的原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8c91fa9dd1f8d7f977714d2f68659b27.png)

这里讲似乎不太明了，但是我们可以用演示和与prim算法的对比来直观感受kruskal算法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE24ff605ae6368c89b905dfefc781c34c.png)

简而言之，prim算法时将一个无向加权图的一个结点默认为最小生成树，然后利用该结点遍历完整个树，每次切分添加一条边最终构造出整个最小生成树。而kruskal算法则是会将整个无向加权图视作一个森林，无向图中有几个结点，里面就有几棵树，而kruskal算法每一次处理都会将两棵树连接成一棵树，这个过程是通过将两棵树看做两个集合，然后运用切分定理每次找出最小横切边，然后将两个树利用这条边结合成一棵树，这样不断周而复始最终构造出一个最小生成树

那么现在我们来看看kruskal算法的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE292aee3f21739562fd7581c3b257b8a8.png)

在实现其数据结构之前，我们先来看看其实现原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4fbff77b2bf3b623cd067e6b5bb2c55b.png)

简单来说，kruskal算法的实现原理是先用最小优先队列存储所有的加权边，然后每次取出其最小边和该边的两个顶点，然后通过并查集判断其是否连通，若联通则跳过，反之则将两节点添加入并查集中形成一棵树，然后将该边加入到mst中，最终mst中存储的边就是最小生成树的所有加权边

我们不妨来看看图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE83283bb3ffd8c90ebce52bc2b051be92.png)

这里我们先将最小加权边0.16联立，判断其是否在并查集上，也就是判断是否已经在一棵树上了，不是，那我们就将这两点都加入到并查集中，就相当于是把两棵树合并成一颗，然后同样的过程添加0.17第二小的加权边，也是移除了0.16之后最小的加权边，用同样的过程将其添加

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0dc704cb05a3396d1bc568f00e6c2459.png)

依葫芦画瓢，我不多讲这里

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE537218b78778b4f953919211d1d044f4.png)

最后我们添加玩0.4加权边以及62两个结点之后，剩下的三个加权边都会因为在并查集判断里无法通过而不加入

那么最后综上我们可以构造其代码如下

```javascript
package algorithm.sort;

public class KruskalMST {
    //保存最小生成树的所有边
    private Queue<Edge> mst;
    //索引代表顶点，使用uf.connect(v,w)来判断两结点是否在同一棵树中
    //若不在则调用uf.union(v,w)将顶点v所在的树与w所在的树合并
    private UF_Tree_Weighted uf;
    //存储图中所有的边，使用最小优先队列，按照权重进行排序
    private MinPriorityQueue<Edge> pq;

    //根据一副加权无向图，创造最小生成树计算对象
    public KruskalMST(EdgeWeightedGraph G){
        //初始化mst
        this.mst = new Queue<Edge>();
        //初始化uf,由于uf存储的是边，因此这里指定的大小是无向图中边的数量
        this.uf = new UF_Tree_Weighted(G.V());
        //初始化pq,注意我们的最小优先队列是利用堆实现的，而堆中是把数组的第一个位置舍弃不用了
        //因此理论上我们应该要在指定的空间上+1的，但是这里不加也可以，因为我们最小优先队列的
        //源码里就已经先进行过+1的操作了
        this.pq = new MinPriorityQueue<>(G.E());
        //将图中的所有边存储到pq中,这里的添加操作也是后续while能够持续运作的前提
        for (Object e:G.edges()) {
            pq.insert((Edge) e);
        }

        //遍历pq队列，每次拿到权重最小的边并进行添加动作

        //pq不为空时继续循环很好理解，但是为什么这里要求mst存放的最小生成树的边不大于其结点数
        //-1呢？这是因为对于任何一个加权无向图而言，如果其有最小生成树，那么其最小生成树的边的
        //数量就正好等于其结点的数量-1，因此这里加上这个条件，可以提高我们程序的运行效率，避免
        //重复无意义的运算
        while (!pq.isEmpty()&&mst.size()<G.V()-1){
            //找到权重最小的边
            Edge e = pq.delMin();
            //找到改变的两个顶点
            int v = e.either();
            int w = e.other(v);

            //若两个顶点已经在同一个树中则跳过添加动作
            if (uf.connect(v,w)){
                continue;
            }

            //代码执行到此说明两顶点不在同一颗树中，执行添加动作
            uf.union(v,w);//执行将两棵树合并的动作

            //令添加的边e进入到mst的队列中
            mst.enqueue(e);
        }
    }

    //获取最小生成树的所有边
    public Queue<Edge> edges() {
        return mst;
    }
}

```

说实话，这可比prim算法好理解多了，代码也好写多了

