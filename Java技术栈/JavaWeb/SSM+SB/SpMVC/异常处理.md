本节我们来学习SpringMVC中的异常处理，之前我们的异常处理都是使用我们的try...catch来做的，但是这种做法实在是太烂了，难看就算了，还不算适用，因此SpringMVC提供了对应的异常处理接口给我们，我们本章就来学习如何利用该接口进行对应的异常处理

- 异常处理器

在进行我们的案例的学习之前，我们先来看看我们的项目环境。

首先我们创建了一个ajax.jsp的页面文件，并写入代码如下

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>

<a href="javascript:void(0);" id="testException">访问springmvc后台controller，传递Json格式POJO</a><br/>

<script type="text/javascript" src="${pageContext.request.contextPath}/js/jquery-3.3.1.min.js"></script>

<script type="text/javascript">
    $(function () {
        $("#testException").click(function(){
            $.ajax({
                contentType:"application/json",
                type:"POST",
                url:"save",
                data:'{"name":"Jock","age":"39"}',
                dataType:"text",
                //回调函数
                success:function(data){
                    alert(data);
                }
            });
        });
    });
</script>
```

我们这里做的事情就是用弹窗打印服务器返回给我们的对象的文本内容而已

web.xml不做改变，spring-mvc除了重新引入jQuery的对应库之外也不做改动，然后我们创建对应的User对象

接着我们写入我们的控制层的代码如下

```
package com.itheima.controller;

import com.itheima.domain.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

@Controller
public class UserController {

    @RequestMapping("/save")
    @ResponseBody
    public List<User> save(@RequestBody User user) {
        System.out.println("user controller save is running ...");

        //模拟业务层发起调用产生了异常
        int i = 1/0;

        User u1 = new User();
        u1.setName("Tom");
        u1.setAge(3);

        User u2 = new User();
        u2.setName("Jerry");
        u2.setAge(5);

        List<User> al = new ArrayList<>();

        al.add(u1);
        al.add(u2);

        return al;
    }
}

```

可以看到我们这里给予了一个异常，我们这样做是为了模拟业务层接口抛出异常的情况

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2682a8019e98508203f2a52cb30ba857.png)

然后我们要创建一个自己的异常处理类并令其实现HandlerExceptionResolver接口

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd2fc0dad4b729e599ad445c82e67b913.png)

那么我们可以写入代码如下

```
package com.itheima.exception;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class ExceptionResolver implements HandlerExceptionResolver {

    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        System.out.println("my exception is running ...");

        ModelAndView modelAndView = new ModelAndView();

        modelAndView.addObject("msg","出错了");

        modelAndView.setViewName("error.jsp");

        return modelAndView;
    }
}

```

我们细看这个方法，会发现这个方法和我们之前的拦截器里的第三个执行完成的方法非常像，事实上，他们的确是几乎一模一样，无非是有无返回值的区别罢了。我们这里之所以有返回值是因为我们对异常进行了处理之后，我们就应该返回一个新的页面，一般是一个错误的提示页面

当然不要忘了在这个类上加入对应的Component注解，令其加入到spring容器中，有同学可能会问spring容器怎么知道这个类是专门用于处理异常的类呢？很简单，因为这个类实现了HandlerExceptionResolver接口，这个接口本身也可以作为一个标识

最后我们的只要出现了异常都会进入到这个异常处理类中，我们还可以对我们的异常处理类做一个改动，令其能够实现对不同异常的不同处理，具体代码请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE84c4cee56fb1cc44eb37dd3662c676e9.png)

那么我们可以写入我们的代码如下

```
package com.itheima.exception;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//@Component
public class ExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler,
                                         Exception ex) {
        System.out.println("my exception is running ...."+ex);
        ModelAndView modelAndView = new ModelAndView();
        if( ex instanceof NullPointerException){
            modelAndView.addObject("msg","空指针异常");
        }else if ( ex instanceof  ArithmeticException){
            modelAndView.addObject("msg","算数运算异常");
        }else{
            modelAndView.addObject("msg","未知的异常");
        }
        modelAndView.setViewName("error.jsp");
        return modelAndView;
    }
}

```

- 注解开发异常处理器

本节我们来学习使用注解来开发我们的异常处理器，我们这里要使用的注解是ControllerAdvice，其作用是设置当前类为异常处理类。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfe529b50d9116e35c56e6f3cfd5be4fc.png)

那么我们可以新创建一个注解异常类并写入其对应的注解

然后我们接着要使用ExceptionHandler实现异常的分类管理，该注解可以设置指定的异常的处理方式。我们要设置一个对应的方法，然后在其上加入该注解，接着在括号内传入我们希望其进行处理的异常的class文件，注意，这种方法可以设置多个，以此来实现对不同异常的不同处理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0ba8ebf0a13dcb47207affd8eb4da6f1.png)

那么我们可以写入其代码如下

```
package com.itheima.exception;

import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

@Component
@ControllerAdvice
public class ExceptionAdvice {

    @ExceptionHandler(NullPointerException.class)
    //@ResponseBody
    public String doNullException(Exception e) {
        System.out.println("null exception...");
        return "error.jsp";
    }

}

```

这里我们要注意，如果我们想要得到其异常对象，可以再传入参数里加入一个异常的形参来获得，但是不可以加入其他的，否则该方法会直接失效。同时如果我们希望其返回一个页面，我们就返回对应的页面字符串就可以了。如果希望其返回我们自己的字符串创建的页面，那么就要加入ResponseBody注解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE728591d07b3c1ef391616662b1937037.png)

最后这注解处理器和非注解处理器的不同在于，前者加载得快，其可以拦截到页面传入的数据的类型转换异常，而非注解处理器则不能。

我们以后都是尽可能使用注解处理器来完成我们的需求的

- 异常处理解决方案

最后我们来学习我们的异常解决方案，我们之前已经做了对应的异常的处理了，但很不幸的是，这些处理方式都是没有用的，实际业务开发的时候我们肯定不可能采用这种方式的。

实际业务开发时，我们是要对我们的异常进行分类并设置对应的解决方式的，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE014f4f856cfc016f9dcb3506e9a9a017.png)

然后我们可以自定义两个异常，并将我们的几乎所有的异常都往这两个异常中转换，然后对其做对应的处理。如果有意料之外的异常，那么我们就将该异常捕获记录，以后我们处理这个异常的时候还是要将这种异常转换为我们的自定义的异常的一种

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE451b26c56a196e6c02bdd59404737a92.png)

那么按照上面的思路，首先我们创建三个自定义的异常类，首先是我们的业务层的异常

```
package com.itheima.exception;

public class BusinessException extends RuntimeException{
    public BusinessException() {
    }

    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }

    public BusinessException(Throwable cause) {
        super(cause);
    }

    public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```

我们做的事情就是令其继承运行时异常然后实现其内部的构造方法，其实也还是跟父类的方法差不多，没啥变化

依葫芦画瓢构建系统异常

```
package com.itheima.exception;

public class SystemException extends RuntimeException{
    public SystemException() {
    }

    public SystemException(String message) {
        super(message);
    }

    public SystemException(String message, Throwable cause) {
        super(message, cause);
    }

    public SystemException(Throwable cause) {
        super(cause);
    }

    public SystemException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```

最后我们创建对应的能够将我们的异常封装成我们的自定义异常的类

```
package com.itheima.service.impl;

import com.itheima.exception.SystemException;

import java.sql.SQLException;

public class UserServiceImpl {
    public void save() {
        try {
            throw new SQLException();
        } catch (SQLException e) {
            throw new SystemException("数据库连接超时!",e);
        }
    }
}

```

可以看到我们上面做的事情就是捕获我们的异常，然后写入一个字符串，接着将对应的异常传入到我们的自定义异常中，最后再返回这个新创建的对象

这就是一个将异常封装为我们的自定义异常对象的一个简单方法，按照这个思路，我们可以写入其他的将异常封装为我们的自定义的异常如下

```
package com.itheima.controller;

import com.itheima.domain.User;
import com.itheima.exception.BusinessException;
import com.itheima.exception.SystemException;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

@Controller
public class UserController {

    @RequestMapping("/save")
    @ResponseBody
    public List<User> save(@RequestBody User user) {
        System.out.println("user controller save is running ...");

        //模拟业务层发起调用产生了异常
        //int i = 1/0;
//        String str = null;
//        str.length();

        if(user.getName().trim().length() < 8){
            throw new BusinessException("对不起，用户名长度不满足要求，请重新输入");
        }
        if(user.getAge() < 0){
            throw new BusinessException("年龄须在0-100");
        }
        if(user.getAge() > 100){
            throw new SystemException("服务器连接失败，快叫人来维护");
        }

        User u1 = new User();
        u1.setName("Tom");
        u1.setAge(3);

        User u2 = new User();
        u2.setName("Jerry");
        u2.setAge(5);

        List<User> al = new ArrayList<>();

        al.add(u1);
        al.add(u2);

        return al;
    }
}

```

可以看到我们这里的情况是规定了发生什么情况就返回怎么样的我们的自定义的异常对象，并赋予了对应的异常信息

然后我们在异常处理类中写入对应的处理代码如下

```
package com.itheima.exception;

import org.springframework.stereotype.Component;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@Component
@ControllerAdvice
public class ProjectExceptionAdvice {

    @ExceptionHandler(BusinessException.class)
    public String doNullException(Exception ex, Model m) {
        m.addAttribute("msg",ex.getMessage());
        return "error.jsp";
    }

    @ExceptionHandler(SystemException.class)
    public String doSystemException(Exception ex, Model m) {
        m.addAttribute("msg","服务器出现问题，你去找管理员吧");
        //非用户的规范问题不能传送给用户，要发送给运维人员，发给用户安抚性信息就可以了
        return "error.jsp";
    }

    @ExceptionHandler(Exception.class)
    public String doException(Exception ex, Model m) {
        m.addAttribute("msg",ex.getMessage());
        //需要记录日志，将ex对象保存起来
        return "error.jsp";
    }
}
```

最后我们的异常就可以被正常捕获到了，实际经过测试也发现这个代码的确没有什么问题，此时我们的案例就算是成功了，在本节中，我们最重要要学习的是异常处理的思想。

其思想就是自定义异常类，并将实际的异常转化为我们的自定义异常然后进行对应的处理