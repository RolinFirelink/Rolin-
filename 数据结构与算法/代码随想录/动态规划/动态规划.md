那从今天开始我们就正式进入动态规划的学习哦，这也是我们之前一直都不会的一节知识哈，但是认真想想，递归我们都能干掉了，那么动态规划当然也可以，还是那句话，冲冲冲，勇敢勇敢我的朋友

# 动态规划的理论基础

那么首先我们来讲解下动态规划的理论基础，动态规划中很重要的是递推公式，当然，并不是说只要找到递推公式动态规划就完了，没有其他需要了解的知识了，我们将动态规划拆解为五部曲，每一步我们都要搞清楚，这有把这五步都搞清楚了，我们对动态规划才能算是真的掌握了

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE168702d5842acdeb926da323a06e20fc.png)

我们做动规的题目，就要严格根据这五步来构建我们的代码，当然，有的同学可能会疑问，为什么要先确定递推公式再考虑初始化呢？因为一些情况是递推公式决定了dp数组要如何初始化。因此我们要先确定递推公式后考虑初始化

当然，现在大家可能还处于一种朦胧状态，不知道到底咋做，没事，后面我们做题目会慢慢对这五步加深理解的，现在我们先记着就行，以后不会了就回来看看理论基础，查漏补缺

接着我们要解决的问题是，动态规划应该如何debug？动规就像递归一样，如果我们只是依葫芦画瓢，凭感觉瞎几把做的话肯定是不行的，这样哪怕通过了自己也是没一点长进的，所以我们要学会debug，以正确的方式来发现自己的错误在哪里，这样来提高自己的知识水平和理解

那么我们debug的三个最大步骤就是

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE277e470ae7bf8a9bbd6e018200556e1d.png)

我们做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。如果最后的结果错了，那么我们就要思考到底是哪一步错了，把对应的日志打印下来，然后我们再来查看自己的错误和自己预想的dp数组公式有啥不对，不断确定自己的问题，锻炼自己的能力

OK，那么学完了理论基础之后，我们就起飞喽，正式开始我们的动规冒险吧

## 斐波那契数

先来一道简单的题目练练手

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEa8316a4bcccff27e8461b244e2793270.png)

那么我们就按顺序来解决这题，首先我们要确定dp数组以及其下标的含义，那么在这一题里，dp数组其实就是斐波那契数列的值，而其对应下标就是对应的第几个斐波那契数列的值

然后我们来确定我们的递推公式，这里的递推公式已经给出来了其实，我们可以很显然地看到递归公式是F(n)=F(n-1)+F(n-2)，没错其实递推公式就是我们数学里的那种比较形象的公式，而后面就要根据这个递推公式来构造我们的代码

接着我们来确定dp数组应该如何初始化，显然，这里递归公式最起码会用到前两位的值，因此我们最初的两位值是一定要初始化的，不然我们都没有起点的值，如果传入的值就是最初的两位数，那么我们直接返回已知的结果即可

然后我们来确定我们的遍历顺序，我们是要从前往后遍历还是从后往前遍历？这里显然，我们要求第几项的值，我们就从最开始的两位往上推导即可，因此我们肯定是要从前往后遍历的

最后我们来举例推到我们的dp数组，假设我们要找第5位的值，那么我们的数组应该是这样的0 1 1 2 3，这也符合我们的最开始的递推公式，也是我们最终要求的答案

那么进行了上面的步骤之后，确定没问题了，我们就开始构造我们的代码

```
class Solution {
    public int fib(int n) {
        if(n<2){
            return n;
        }
        int ans = 0;
        int[] next = new int[n+1];
        next[0]=0;next[1]=1;
        for (int i = 2; i <= n; i++) {
            ans=next[i-1]+next[i-2];
            next[i]=ans;
        }
        return ans;
    }
}
```

我们这里首先特殊处理n为初始值的情况，然后我们构建了dp数组，其长度是n+1，因为我们最终是要遍历到n的位置的，因此我们需要给其值+1，接着我们利用公式不断往前递推，到达对应的值时停止递推公式，然后返回我们的记录值即可

当然，我们容易知道本题实际上只需要维护前两个值就可以得到答案，所以我们的代码可以不用构建一个dp数组，只需要维护递推公式中前两位的值，那么我们可以修改我们的代码如下

```
class Solution {
    public int fib(int n) {
        if (n < 2) return n;
        int a = 0, b = 1, c = 0;
        for (int i = 1; i < n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```

不过实际做题的时候我们不推荐使用这种代码，因为我们不差空间，而且这种代码除了装逼之外不知道有什么用，后续我们就不展示这种方式构造的代码了

## 爬楼梯

初入门径之后，我们再来一题小试牛刀

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE7c92b8bccc2de0985cf3c0c76a78298d.png)

首先我们来确定dp数组，我们这里的dp数组表示的是爬到对应阶数所拥有的方法数，而对应下标表示的是爬到对应下标所能有的方法数

然后我们来确定我们的递推公式，这里我们的递推公式就没有上一题这么简单了，上一题是直接给出了，我们这里就需要自己推，那么我们就来推导一下

我们假想一下，假设我们要求出第n阶的方法数，那么第n阶可以由第n-1阶跳一步过来，也可以由第n-2阶跳跃两步过来，那么我们容易猜测其递推公式应该是F(n)=F(n-1)+F(n-2),但是我们不保证正确，为此，我们可以自己举例，首先，自己推可以推出来，其对应阶数的数组应该为1 2 3 5 8，认真观察，我们会发现的确符合我们的公式，那么我们就可以认真这个递推公式是正确的

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE3a485a3fed06b67c860d08cc279f7bfd.png)

接着我们要确定dp数组如何初始化，我们可以跟我们的上一题一样，先初始化前两位，然后再构造后面的值

遍历顺序显然是从左往右，举例的数组我们已经做过了。

那么到此为止，我们就可以写出我们的代码如下

```
class Solution {
    public int climbStairs(int n) {
        int[] next = new int[n+1];
        next[0]=1;next[1]=2;
        for (int i = 2; i < n; i++) {
            next[i]=next[i-1]+next[i-2];
        }
        return next[n-1];
    }
}
```

我们这里首先让我们的数组最开始的长度就是固定长度的更大一位，由于题目中的数值最低都是一，这样就可以避免发生传入1时发生的数组下标越界异常

然后我们可以每次都返回答案的倒数第二位，这样虽然我们每次创建数组时最后一组都是没有意义的，但是我们可以通过这种方式来避免最开始的特殊处理，不失为一种好方法

## 使用最小花费爬楼梯

做了前两题之后，我们对动规已经有一个大致印象了，接着我们来做一道提高题

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEd848372ba8a55d06940a03b9fa6b8c90.png)

我们同样进行我们的动规五部曲，我们这里dp数组代表的是到达指定台阶时我们的最低花费

接着就是确定递推公式，同样的，前进到n阶只有两种方法，就是n-1阶前进一步或者是n-2阶跳跃两步，那么我们就取这两步的最小值，同时无论是那一步跳跃过来，我们都需要让我们的花费的代价加上当前的下标对应的代价，那么我们可以将我们的递归公式确定为F(n)=min(F(n-1)+F(n-2))+f(n)，这里小f代表的是我们的花费数组

初始化当然是初始化前两个，由于我们刚落地时就需要进行当前位置上的花费，因此我们初始化时的值要是对应的解题的花费值

遍历顺序没有疑问，显然是从左往右，从右往左压根用不到我们初始化的值

至于推导dp数组，我们可以拿我们题目中的dp数组来举例，就拿示例二举例，我们推导的dp数组应该是下面的形式

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEb877e7958d82689590caf4a194ffa90a.png)

最终我们也可以获得我们的目标值，这就说明我们的逻辑没有问题，不过这里要注意的是，由于我们在倒数第一位和第二位就可以下一步直接到达目标阶梯了，因此这两个阶梯都可以作为终点，所以我们要返回的是这两位的值的最小值，这才是我们的目标答案

那么最后我们可以写入我们的代码如下

```
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] next = new int[cost.length];
        next[0]=cost[0];
        next[1]=cost[1];
        for (int i = 2; i < cost.length; i++) {
            next[i]=Math.min(next[i-1],next[i-2])+cost[i];
        }
        return Math.min(next[next.length-1],next[next.length-2]);
    }
}
```

我们这里由于最小的输入就是2，都可以保证最初的初始化是有值的，因此不用特别创建一个数组位置了，直接创建对应大小的即可，也可以保证能够处理所有情况