在学习二叉树之前，我们先来回顾下我们之前学习的线性表结构，在那个章节我们学习了数组与链表，这两种是数据结构

数组数据结构查询快，然而增删慢，链表则与之相反

而如果配合我们的二叉树结构的话，比方说我们用链表构建二叉树结构，那么我们的二叉树天生就具有增删快的特点，再结合二叉树结构，我们还能进一步提升其查询效率，这对于数组来说也是一样的，使用数组构建二叉树，能够在查询快的同时进一步提高其增删效率

那么接下来我们正式来学习下二叉树数据结构，首先我们来看看二叉树的定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15bb19caa2775201c724a01252867ce7.png)

首先我们的二叉树数据结构可以想象成一个倒挂的树这样的结构，其特点有四，一是每个结点都有至少0个子节点，二是没有父节点的结点为根结点，如上图中的结点A，三是每一个非根结点都有父节点，最后是每个结点及其后代整体都可以看成是一个树，称之为当前结点的父节点的一个子树，比如对于A而言，F是其一个子树，而对于F而言，K,L,M都是其子树



树的相关术语

在学习二叉树数据结构之前，我们要先学习树的相关术语，便于我们后续的对数据结构的学习

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2fcdb7c39fa9198512bb4aae4d85a1cb.png)

首先是结点的度，比方说对于之前的图而言，A结点的度为6，J结点的度为2，P结点的度为0

其次是叶结点，度为0的结点被称为叶结点或终端节点，比方说P，Q两结点都是叶结点

然后是结点的层次，从根结点开始，层次往下依次递增，比方说A的层次为1，那么B,C,D,E,F,G的层次就为2，H,I,J,K,L,M,N的层次就为3，P,Q的层次为4

接着是结点的层次编号，从树中结点按照上下层从左到右排成一个线性序列，编成连续的自然数。比方说A的层序编号为1，那么B,C,D,E,F,G的层序编号为2,3,4,5,6,7依次类推

再来是树的度，就是树中所有结点的度的最大值，比方说对于之前的图而言，结点的度的最大值为6，那么树的度就为6

最后是树的高度，就是树中结点的最大层次，比方说对于之前的图，最大层次是4，那么树的高度就是4

接着我们来学习森林的定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe5c21ac7d918d36f7379d4a624552bf8.png)

将一棵树的根结点去除之后，树就变成了森林，反之加上统一的根节点之后，森林就成了树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2d0033d39576b8272833f2947d056a69.png)

孩子结点指的是一个结点的直接后继结点，比如对于上图的E而言，I，J就是其孩子结点

双亲结点就是父节点，一般我们就叫父节点，指的是一个结点的直接前驱，比方说对于B,C,D,E而言，其父节点是A结点

兄弟结点指的是同一双亲的孩子结点间相互成为兄弟结点，比方说K是M的兄弟结点，L也是K的兄弟结点



二叉树的基本定义

二叉树，顾名思义，它应该跟二很有关系，结果也是这样的，二叉树其实就是度不超过2的树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0b08e58b9900ff5b33e3437361a67edd.png)

接着我们来讲两个特殊的树，这两个树分别是满二叉树和完全二叉树

先来看看满二叉树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEee8f6816d6f0aa95e204c6718db7b2de.png)

一个二叉树如果每一个层的结点树到达到最大值，那么就是满二叉树。由于二叉树度数最多为2，因此满二叉树每一层的结点数量为2^(k-1)，其中k为树的层次

接着来看看完全二叉树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0fd9ec89a3e34c4025a501c6f7d4c2a3.png)

一个二叉树其叶结点只出现在最下层和次下层，并且最下面异常的结点都集中在该层最左边的的若干位置，那么该树就是完全二叉树

比方说对于上图而言，如果L,F,G都去除了，那么就不是完全二叉树了。因此C作为叶结点出现在了非次外层和非最外层



二叉查找树的创建

同样的，之所以叫二叉查找树，这是因为我们的所创建的二叉树是要查找对应元素的，先来看看其二叉树所使用的结点的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeca101ab731a76fe53cf493339ebb8cc.png)

根据API设计我们可以构造其结点类如下

```javascript
//二叉树的结点类
private class Node {
    //存储键
    public Key key;
    //存储值
    private Value value;
    //记录左子节点
    public Node left;
    //记录右子节点
    public Node right;

    //提供创建结点的构造方法
    public Node(Key key,Value value,Node left,Node right){
        this.key=key;
        this.value=value;
        this.left=left;
        this.right=right;
    }
```

二叉树的结点与符号表的类似，都是键值对的方式存储数据，且其有两个指针域，分别用于指向左子树和右子树

接着我们来看看二叉查找树的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2addafc912e66499435020d39ef4cd93.png)

由于要实现查找，所以当然我们的泛型Key要继承Comparable接口并再次限定存储的元素类型为我们之前所定义的泛型Key

我们先来看看我们实现put方法的思路

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7370582a178a8d82a800b754e3e09c20.png)

接下来看看其图示演示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf7e2682ab8924fe80f397fcb87dfced1.png)

再来看看我们实现get方法的思路

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE83d4a67317785d4c2e72083703930286.png)

其实跟上面的方法就突出一个大同小异，不多谈

然后我们来看看实现delete方法的思路

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb359a870a0e70d7df86de286bdfc6382.png)

然后我们来看看其图示演示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE73461b4ea649060239bb8f6ae6d45515.png)

其原理是先找到被删除元素，然后再找到被删除元素的右子树的最小元素，其最小元素就是被删除结点的右子树的最左子树的结点，让该最小元素代替被删除元素的位置就完了

那么根据API设计以及刚刚原理的演示，我们可以实现其方法如下

```javascript
package algorithm.sort;

//令key继承Comparable接口，给Key所代表的元素提供比较方式，便于实现排序
public class BinaryTree<Key extends Comparable<Key>,Value> {
    //记录根节点
    private Node root;
    //记录树中元素的个数
    private int N;

    //二叉树的结点类
    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子节点
        public Node left;
        //记录右子节点
        public Node right;

        //提供创建结点的构造方法
        public Node(Key key,Value value,Node left,Node right){
            this.key=key;
            this.value=value;
            this.left=left;
            this.right=right;
        }
    }

    //获取树中元素的个数
    public int size() {
        return N;
    }

    /*
     * 调用该方法只需要用户传入key和value就可以完成向树中添加元素，
     * 该方法内部会调用重载的put方法并传入树的根节点，要添加的key和
     * value，并最终将这个值返回给原先的树的根结点root，最后达成修
     * 改树的效果。树的根结点是最能够代表整个树的结点
     */
    //向树中添加元素key-value
    public void put(Key key,Value value) {
        root = put(root,key,value);
    }

    /*
     * 调用该方法需要传入树，要添加的key和value，我们在这个方法里先进行
     * 传入的树是否为null的判断，若是就直接产生一个新结点并返回就可以了。
     * 若不是则需要比较传入的值与树中各结点的key值的大小，若传入元素大于
     * 结点元素则往右子树上前进，反之则往左子树上前进，若相等则覆盖结点。
     * 这里我们往左右子树上前进的方式是采用了递归的方式的，比方说我们的键
     * 大于结点，那么我们就传入该右子树和key以及value递归调用put方法，并
     * 将该右子树的修改结果返回赋给原先的结点的右子树
     */
    //向指定的树x添加key-value并返回添加元素后的新的树
    private Node put(Node x,Key key,Value value) {
        //如果x子树为空
        if(x==null){
            N++;//元素个数+1
            //返回一个新结点，该结点没有任何子树，因此左右子树都没有指向
            return new Node(key,value,null,null);
        }
        //代码执行到此说明子树不为空

        //定义比较的结果并赋值给cmp
        int cmp = key.compareTo(x.key);
        //比较x结点的键与传入的key的大小
        if(cmp>0){
            /*
             * 如果key大于x结点的key，则往x结点的右子树上前进
             * 递归调用本方法，并且传入右子树的结点进入，且返回该结点的结果给原先结点的右子树
             * 之所以要把结果返回给x.right，是因为返回这个动作本身就带有赋值，指向的意义
             * 通过这个代码可以将新创建的结点正确地被其父节点指向。如果把不添加返回代码，那么
             * 到时候就会出现创建了对应的结点然而没有正确指向的情况。如果把x.right改为return
             * 那么最后的情况就是会正确创建对应结点并返回该结点，但是该结点却没有被正确指向
             */
            x.right = put(x.right,key,value);
        }else if(cmp<0){
            //如果key小于x结点的key，则往x结点的左子树上前进
            x.left = put(x.left,key,value);
        }else {
            //如果相等则覆盖value的值
            x.value=value;
        }
        //返回添加成功添加元素后的树
        return x;
    }

    /*
     * 该方法用于查找树中对于的key值的结点的value元素
     * 调用该方法只要传入一个key，会自动查找并返回value
     * 实际上该方法会调用重载的get方法，传入树和需要查找的key
     */
    //查询树中指定key对应的value
    public Value get(Key key){
        return get(root,key);
    }

    /*
     * 调用该方法需要传入树和key，先判断树是否为空，若为空则返回null
     * 代表在树中找不到对应元素的意义。若不为空同样判断key与结点中key
     * 的值，若传入key大于结点key则往右子树前进，反之则往左子树前进，
     * 若相等说明找到了，直接返回对应结点的value值就行了
     */
    //从指定的数x中，查找key对应的值
    public Value get(Node x,Key key) {
        //x所代表的树的结点为null
        if(x==null){
            return null;
        }

        //代码执行到此说明不为null，进行大小比较
        //定义比较的结果并赋值给cmp
        int cmp = key.compareTo(x.key);
        if(cmp>0){
            /*
             * 如果key大于x结点的key，则往x结点的右子树上前进，这里用return的原因
             * 是在于我们需要返回对应结点的值，因此我们需要使用return，因为我们不需
             * 指向，所以没必要跟上一个方法一样构造指向代码
             */
            return get(x.right,key);
        }else if(cmp<0){
            //如果key小于x结点的key，则往x结点的左子树上前进
            return get(x.left,key);
        }else {
            //如果相等说明找到了，直接返回x结点的值
            return x.value;
        }
    }

    //删除树中对应的value
    public void delete(Key key) {
        delete(root,key);
    }

    //删除指定树中的key对应的value，并返回删除后的新树
    public Node delete(Node x,Key key) {
        //如果其定位结点为null，说明找不到要删除的目标结点，那就直接返回null
        if(x==null){
            return null;
        }

        //代码执行到此说明结点不为空
        //定义比较的结果并赋值给cmp
        int cmp = key.compareTo(x.key);
        if(cmp>0){
            /*
             * 如果key大于x结点的key，则往x结点的右子树上前进，这里之所以构建了指向
             * 代码，是因为当我们将被删除元素的位置用另外一个次小的元素替换时，需要令
             * 其被父节点指向，为了实现这个动作，因此这里设置了指向代码
             */
            x.right = delete(x.right,key);
        }else if(cmp<0){
            //如果key小于x结点的key，则往x结点的左子树上前进
            x.left = delete(x.left,key);
        }else {
            //令元素个数-1，放置于此能让所有情况都实现N--
            N--;

            //如果相等说明找到了需要删除的结点，进行删除的操作
            //先判断目标结点的右子树是否为空
            if(x.right==null){
                /*
                若为空则直接返回左节点，这里面的原理是对于一个被删除元素而言
                若其右子树为空，则其次小元素必然在左子树的第一个结点中，说实话
                这为啥知道他就行我也不是很懂，但是经过分析发现无论左子树中还有没有
                子树，最后都是成立的，因此这个方法没有问题。
                 */
                return x.left;
            }

            if(x.left==null){
                return x.right;
            }

            //先将目标结点的右子树记录于minNode中，因为次小的元素必然在右子树的
            //左子树中，所以我们直接将minNode定位在被删除结点的右子树中
            Node minNode = x.right;
            //Node deleteNode = null;
            //通过while循环将minNode定位到最左子树的结点中
            while (minNode.left!=null){
                //if(minNode.left.left==null){
                //    deleteNode=minNode;
                //}
                minNode = minNode.left;
            }

            //deleteNode.left=null;
            
            //接下来要删除右子树中最小的结点
            Node n = x.right;
            //构建循环定位目标结点
            while (n.left!=null){
                //判断当前结点的后后结点是否为null，若是则说明下一个结点就是要删除的结点
                if(n.left.left==null){
                    //当前结点指向最小数值结点的指针删除
                    n.left=null;
                }else {
                    //若不到目标结点则让结点前进一位
                    n = n.left;
                }
            }
            /*
            个人觉得这里再构建一个循环用来专门定位次小结点的父节点未免有些多此一举
            实际上大可以在第一个循环里就去把次小结点的父节点给记录下来，这样就可以
            省略一个循环了，有益于提高我们的效率,实际操作之后发现真的可以
            这里上面的被注释的代码是我写的代码
             */

            //让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            //让x结点的父节点指向minNode，直接让x变为minNode，然后返回x
            //这样通过递归可以让x自动被其父节点指向
            x = minNode;

        }
        return x;
    }
}
```

各种方法的解释都直接写在代码上了，自己去查看就行了