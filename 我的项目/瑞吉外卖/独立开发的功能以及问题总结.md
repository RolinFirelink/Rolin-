我们的这个程序还有许许多多的内容是课程中没有提到的，那些内容就要靠我们自己去完善了，我们这里主要记录我们是如何完成这些内容并遇上了什么问题，又是怎么解决的

- 订单信息分页查询

虽然我们已经实现了下单功能了，但是我们还没有开发我们的订单功能分页查询的功能，我们首先到前端中来查看下其请求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE94371e87fc97138b40d8116e83989524.png)

然后前端所需求的东西，很容易就能构造对应的分页查询的代码，返回的是Order对象，但是这样的代码出现的问题就是我们的前端页面不会显示我们商品的数量，经过分析前端代码，我们发现其会调用我们返回的对象的sunNum属性来展示数量，因此我们的解决方式是创建一个新的OrdersDto继承原来的Orders对象，加入sumNum属性，那么我们可以构造其实体类如下

```
@Data
public class OrdersDto extends Orders {

    //记录订单的数量
    private Integer sumNum;

}
```

然后我们的控制层的处理逻辑就是首先获取用户的id，构造两个分页构造器，查出第一个Orders的分页对象的所有内容并进行对应的排序，然后我们进行对象拷贝，除了原来的数据本体内容之外，其他内容全部拷贝到我们的另一个分页对象中

然后我们取出数据本体，用stream流将集合中的每一个单独的order的内容拷贝到ordersDto中，而菜品的具体数量则是我们的订单详细表中的菜品数据量，我们直接利用对应的菜品id查询出来结果并赋予就可以了，最后我们将该集合设置到dto的分页对象中，将分页对象传回即可

```
/**
 * 订单信息分页查询
 * @param page
 * @param pageSize
 * @return
 */
@GetMapping("/userPage")
public R<Page> page(int page,int pageSize){
    log.info("page = {},pageSize = {}",page,pageSize);

    //获取用户id
    Long currentId = BaseContext.getCurrentId();

    //构造分页构造器
    Page<Orders> pageInfo = new Page(page,pageSize);
    Page<OrdersDto> dtoPage = new Page<>();

    //构造条件构造器
    LambdaQueryWrapper<Orders> queryWrapper = new LambdaQueryWrapper<>();

    //添加查询条件，根据用户id进行查询
    queryWrapper.eq(Orders::getUserId,currentId);

    //添加排序条件，根据更新时间进行排序
    queryWrapper.orderByAsc(Orders::getCheckoutTime);

    ordersService.page(pageInfo,queryWrapper);

    //对象拷贝
    BeanUtils.copyProperties(pageInfo,dtoPage,"records");
    List<Orders> orders = pageInfo.getRecords();

    List<OrdersDto> list = orders.stream().map((item) -> {
        OrdersDto ordersDto = new OrdersDto();
        //对象拷贝
        BeanUtils.copyProperties(item,ordersDto);
        //构造条件构造器
        LambdaQueryWrapper<OrderDetail> wrapper = new LambdaQueryWrapper<>();
        //订单id
        Long id = item.getId();
        wrapper.eq(OrderDetail::getOrderId,id);
        //根据id查询订单详细表中的数据数量
        int count = orderDetailService.count(wrapper);
        ordersDto.setSumNum(count);
        return ordersDto;
    }).collect(Collectors.toList());

    dtoPage.setRecords(list);

    return R.success(dtoPage);
}
```

这样构造代码在实际情况中是可行的，是没有问题的

然而不幸的是我后面去看别人做的前端页面的显示，发现其实我们这里还需要返回对应的菜品数据，这样在我们的订单页面里还会具体显示我们下单的具体菜品。说实话吧，我又看不太懂前端代码，捏麻麻的又不给我看最后的效果，我他妈怎么知道你要啥啊

总之我们可以将我们的代码改造如下，首先我要往我们的Dto对象中添加一个记录具体菜品数据的属性

```
package com.itheima.reggie.dto;

import com.itheima.reggie.entity.OrderDetail;
import com.itheima.reggie.entity.Orders;
import lombok.Data;

import java.util.List;

@Data
public class OrdersDto extends Orders {

    //记录订单的数量
    private Integer sumNum;

    //记录下单用户的名字
    private String consignee;

    //记录订单中具体的菜品
    private List<OrderDetail> orderDetails;
}

```

然后我们这里的基本逻辑基本跟前面一样，不同的是我们这里再每一个具体的订单对象中都查找一下具体的订单详细信息的集合，然后将该集合数据设置到我们的对象中即可，最后返回该集合对象

```
/**
 * 订单信息分页查询
 * @param page
 * @param pageSize
 * @return
 */
@GetMapping("/userPage")
public R<Page> page(int page,int pageSize){
    log.info("page = {},pageSize = {}",page,pageSize);

    //获取用户id
    Long currentId = BaseContext.getCurrentId();

    //构造分页构造器
    Page<Orders> pageInfo = new Page(page,pageSize);
    Page<OrdersDto> dtoPage = new Page<>();

    //构造条件构造器
    LambdaQueryWrapper<Orders> queryWrapper = new LambdaQueryWrapper<>();

    //添加查询条件，根据用户id进行查询
    queryWrapper.eq(Orders::getUserId,currentId);

    //添加排序条件，根据更新时间进行排序
    queryWrapper.orderByAsc(Orders::getCheckoutTime);

    ordersService.page(pageInfo,queryWrapper);

    //对象拷贝
    BeanUtils.copyProperties(pageInfo,dtoPage,"records");
    List<Orders> orders = pageInfo.getRecords();

    List<OrdersDto> list = orders.stream().map((item) -> {
        OrdersDto ordersDto = new OrdersDto();
        //对象拷贝
        BeanUtils.copyProperties(item,ordersDto);
        //构造条件构造器
        LambdaQueryWrapper<OrderDetail> wrapper = new LambdaQueryWrapper<>();
        //订单id
        Long id = item.getId();
        wrapper.eq(OrderDetail::getOrderId,id);
        //根据id查询订单详细表中的数据数量
        List<OrderDetail> orderDetailList = orderDetailService.list(wrapper);
        ordersDto.setSumNum(orderDetailList.size());
        ordersDto.setOrderDetails(orderDetailList);
        return ordersDto;
    }).collect(Collectors.toList());

    dtoPage.setRecords(list);

    return R.success(dtoPage);
}
```

- 再来一单功能开发

首先我们来分析下前端的再来一单的发送的请求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4e5e4feafd7c2a7b51db7753ad67c8ac.png)

其发送的请求中一并发送一个json格式的数据，数据中只有id这个属性，我们可以用RequestBody注解+Orders对象来承接，用其他方式都是不行的，记住我们承接JSON格式的数据用RequestBody注解，并且我们要加入含有对应属性的对象

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE33aa713567595c089b645443562babe8.png)

由于实现再来一单的逻辑比较复杂，因此我们先在对应的服务层接口中创建新的方法

```
    /**
     * 用户再来一单
     * @param orders
     */
    public void again(Orders orders);
}
```

然后我们具体实现这个方法，我们的基本逻辑就是模拟一次再次下单的过程，所以我们首先获得里面传入的最重要的订单id，然后我们利用该id获得原先的订单信息，然后我们查找原先的订单里的具体菜品，然后我们用steam流的形式将每一个菜品都加入到我们的购物车中

我们这里加入到购物车的逻辑是首先创建一个购物车对象，然后设置上对应的当前用户的id，接着我们往对应的菜品数据中取出菜品id，判断其是否为空，若不为空则说明其取出的菜品对象，此时我们就从数据库中取出对应的菜品对象，然后将各项数据都设置对应的购物车对象中。

这里有两点需要注意，第一点是我们菜品的口味数据，口味数据是保存到订单表中的，所以我们往购物车设置具体口味数据时要从订单中取出并设置，第二点是我们的金额设置由于在前端会给我们扩大100倍，因此我们这里加入时也需要将我们的金额给缩小一百倍

反之若为空则说明是套餐，此时我们取出订单中的套餐id并在数据库中查出对应的套餐数据，要注意的事情也是一样的，这里就不重复提了

最后我们统一给我们的购物车对象设置上新的时间，然后将原先订单中的数量也设置上去（注意这里的数量是设置上去的，这样才能动态形成用户下单的数量），然后我们再将购物车对象保存到购物车中即可

这一切搞定之后，调用服务层中的下单方法即可（当然由于我们这里涉及到了多表操作，所以别忘了要加入事务处理的注解）

```
/**
 * 用户再次下单
 * @param order
 */
@Override
@Transactional
public void again(Orders order) {
    Long id = order.getId();

    log.info("订单数据:{}",id);

    LambdaQueryWrapper<Orders> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(Orders::getId,id);

    //得到原先的订单信息
    order = ordersService.getOne(queryWrapper);

    //获取订单明细表中的具体菜品
    LambdaQueryWrapper<OrderDetail> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(OrderDetail::getOrderId,order.getId());

    List<OrderDetail> list = orderDetailService.list(wrapper);

    list.stream().map((item) -> {
        Long dishId = item.getDishId();
        ShoppingCart shoppingCart = new ShoppingCart();

        //先设置用户id于购物车对象中
        Long currentId = BaseContext.getCurrentId();
        shoppingCart.setUserId(currentId);

        if(dishId != null){
            //从数据库中取出对应的菜品对象,设置到对应的购物车对象中并保存
            DishDto dishDto = dishService.getByIdWithFlavor(dishId);
            String dishFlavor = item.getDishFlavor();
            shoppingCart.setImage(dishDto.getImage());
            shoppingCart.setName(dishDto.getName());
            shoppingCart.setDishId(dishDto.getId());
            shoppingCart.setDishFlavor(dishFlavor);
            BigDecimal price = dishDto.getPrice();
            shoppingCart.setAmount(price.divide(new BigDecimal(100)));
        }else {
            //没有菜品id则说明是套餐
            Long setMealId = item.getSetmealId();

            SetmealDto setmealDto = setmealService.getByIdWithDish(setMealId);
            BigDecimal price = setmealDto.getPrice();
            shoppingCart.setAmount(price.divide(new BigDecimal(100)));
            shoppingCart.setName(setmealDto.getName());
            shoppingCart.setSetmealId(setmealDto.getId());
            shoppingCart.setImage(setmealDto.getImage());
        }
        shoppingCart.setCreateTime(LocalDateTime.now());
        shoppingCart.setNumber(item.getNumber());
        shoppingCartService.save(shoppingCart);
        return item;
    }).collect(Collectors.toList());

    ordersService.submit(order);
}
```

最后我们在控制层中调用我们新创建的服务层的方法即可

```
/**
 * 再来一单
 * @param order
 * @return
 */
@PostMapping("/again")
public R<String> again(@RequestBody Orders order){

    ordersService.again(order);

    return R.success("下单成功");
}
```

- 移动端用户登出功能

首先我们来看看该功能请求的地址和方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa70511c7cc9834c0161d56c897706614.png)

然后我们登出的方法本质上很简单，直接从共享域中移除信息即可，所以我们容易写入其代码如下

```
/**
 * 移动端用户退出
 * @param request
 * @return
 */
@PostMapping("/loginout")
public R<String> logout(HttpServletRequest request){
    //清理Session保存的当前用户登录的id
    request.getSession().removeAttribute("user");
    return R.success("退出成功");
}
```

- 员工端用户登录则无法正常拦截移动端用户直接访问页面的问题解决

这个问题注意到了，但是我不知道该怎么解决他，准确来说是有些思路，但是试着去实现了下却总是出问题，看了别人的代码发现别人也没有去解决这个问题，我也就这样放着得了

- 订单明细分页查询

我们通过分析前端代码易知其发送请求的方式跟我们之前的分页请求差不多，但是这里值得一提的是我们这里可以选择使用订单号查询或者是用日期来查询，所以我们这里要构造对应的利用这些条件查询的方法

本质代码也不难，自己看吧

```
/**
 * 订单明细分页查询
 * @param page
 * @param pageSize
 * @param number
 * @param beginTime
 * @param endTime
 * @return
 */
@GetMapping("/page")
public R<Page> page(int page,int pageSize,Long number,String beginTime,String endTime){
    log.info("page = {},pageSize = {},number = {},beginTime = {},endTime = {}",page,pageSize,number,beginTime,endTime);

    //构造分页构造器
    Page<Orders> pageInfo = new Page(page,pageSize);

    //构造条件构造器
    LambdaQueryWrapper<Orders> queryWrapper = new LambdaQueryWrapper<>();

    //添加过滤条件
    queryWrapper.like(number!=null,Orders::getNumber,number);
    queryWrapper.gt(!StringUtils.isEmpty(beginTime),Orders::getOrderTime,beginTime);
    queryWrapper.lt(!StringUtils.isEmpty(endTime),Orders::getOrderTime,endTime);

    //添加排序条件
    queryWrapper.orderByDesc(Orders::getOrderTime);

    //执行查询
    ordersService.page(pageInfo,queryWrapper);

    return R.success(pageInfo);
}
```

不过这里要提一下的是，虽然我们页面上需要的数据我们这里全都有了，但是不知道为啥收货人那一个信息一直不显示，就很傻逼，不过无所谓，就先这样吧，反正我们的数据都在里面的，没展示出来是前端的问题，不关我们的事

现在我们发现的确是前端的问题，稍微修改一下前端的代码就可以正确展示我们的数据了

- 修改订单状态

最后是修改订单状态的方法，这个也不难，我也懒得说，直接看代码吧

```
/**
 * 修改订单状态
 * @param orders
 * @return
 */
@PutMapping
public R<String> modifyStatus(@RequestBody Orders orders){
    log.info("orders:{}",orders);
    Orders order = ordersService.getById(orders.getId());
    order.setStatus(orders.getStatus());
    ordersService.updateById(order);
    return R.success("状态修改成功");
}
```

- 点击套餐图片回显信息

之前我们没有实现这个功能是因为我们不知道前端需要我们返回什么数据，所以我们根本无从下手，那玩毛啊是吧，但是看了别人的代码之后我们可算整明白我们需要返回什么数据了，我们需要返回的是一个承载着套餐内具体菜品的集合对象，每一个菜品对象里都应该要有我们订单所下的菜品的所有数据，因此我们的逻辑很简单，首先查出对应的套餐，然后用该套餐查出其下所有的套餐关联的菜品对象，接着用stream流的形式取出其中的每一个套餐关联菜品对象，查出其具体的菜品对象，然后将数据拷贝到我们的创建的DishDto中，这里我们拷贝两个内容，一个是我们原先的套餐菜品对象的数据，第二个是我们查出的具体的套餐对象的数据，前者是提供数据令其回显，后者也是同样的，不过提供的是一些描述和图片的数据，当然，也可以手动设置，就是比较麻烦，我们这里就直接用工具类拷贝了

```
/**
 * 页面回显套餐数据的方法
 * @param id
 * @return
 */
@GetMapping("/dish/{id}")
public R<List<DishDto>> echo(@PathVariable Long id){

    LambdaQueryWrapper<SetmealDish> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.eq(SetmealDish::getSetmealId,id);

    List<SetmealDish> list = setmealDishService.list(lambdaQueryWrapper);

    List<DishDto> dishDtoList = list.stream().map((item) ->{
        DishDto dishDto = new DishDto();
        BeanUtils.copyProperties(item,dishDto);
        Dish byId = dishService.getById(item.getDishId());
        BeanUtils.copyProperties(byId,dishDto);
        return dishDto;
    }).collect(Collectors.toList());

    return R.success(dishDtoList);
}
```

- 用户地址的删除的修改功能

不是去看了别人的代码我都不知道还有这玩意.......总之代码本身也不难，我们迅速过一过吧

首先是删除的代码，直接根据id删除即可

```
/**
 * 删除地址的方法
 * @param ids
 * @return
 */
@DeleteMapping
public R<String> delete(Long ids){
    log.info("ids = {}",ids);
    LambdaQueryWrapper<AddressBook> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.eq(AddressBook::getId,ids);
    addressBookService.remove(lambdaQueryWrapper);
    return R.success("地址删除成功");
}
```

然后是修改的代码，修改的基本逻辑就是先删除再新增

```
/**
 * 修改地址的方法
 * @param addressBook
 * @return
 */
@PutMapping
public R<String> update(@RequestBody AddressBook addressBook){
    log.info("addressBook={}",addressBook);
    LambdaQueryWrapper<AddressBook> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.eq(AddressBook::getId,addressBook.getId());
    addressBookService.remove(lambdaQueryWrapper);
    addressBookService.save(addressBook);
    return R.success("地址修改成功");
}
```

- 菜品以及套餐的勾选框点击移动问题

菜品以及套餐的勾选框点击之后就会移动且不可恢复，除非刷新，解决方式是将对应前端代码的25px改为50px