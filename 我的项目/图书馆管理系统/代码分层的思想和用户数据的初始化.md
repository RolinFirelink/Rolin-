接着我们要介绍的思想就是代码分层的思想，这有些类似于现实生活中的分工合作。如果我们是自己一个人写代码的话，那么我们可以随便写，无所谓其实，但如果我们要建立一个项目，那么我们的代码复杂性就上来了，要构造的代码也会相应的变得很多，这时候我们就要用到代码分层了

将代码分层有利于提高我们代码的可拓展性，同时也便于人类的阅读和理解

代码分层主要分以下三层，分别是

controller（请求处理层）：负责与界面数据进行交互处理

service（业务逻辑层）：负责业务逻辑相关处理

DAO（数据持久层）：负责持久化操作，DAO的全称是Data Access Object

我们这里先来讲controller层，controller的意思是控制器，该层叫请求处理层或者是控制层，其作用是负责与界面进行交互处理，简而言之是我们会在创建时创建处这样的一个包，包下存放与界面数据信息进行交互处理的类，而在我们的项目里，我们已经有了controller层了，在module层下的book层或者是其他文件夹里的对应的类其实就是controller，只是我们这里没有用controller来命名而已，但作用是一样的。

比方说我们在界面里要进行增加，删除等操作，我们按下对应的键位，其实其内部的代码调用的就是这些包下的类里的代码，当然，我们要注意我们说的controller指的是类，是字节码文件，不是fxml啊，这点不要搞错了

service是第二层，但这里我们先把它放一边，我们先来讲讲Dao层，Dao层又要数据持久层，光看名字我们都能够猜到他是干嘛的，它其实就是用来将数据持久化的，我们之前学习javaSe的时候也说过我们是使用IO流将内存里的东西存放到硬盘中来达到持久化的效果的，我们目前是使用这种方法，但是后期我们还会学习数据库的形式来实现持久化，实际上数据库的方法可比IO流好多了，因此后面我们都是使用数据库的来实现持久化的，只是这里由于知识还没学到那个程度所以要先用IO流来实现。

那既然我们将数据存放到了硬盘中，那我们必然要设计类来和硬盘中的数据打交道，获得我们所需要的数据并传回来，这些类就是Dao层，其作用就是专门和数据打交道的

最后我们来说说service层，service层是业务逻辑层，简单来说就是调用DAO层的，其具体存在的意义三言两语讲不明白，反正简单来说就是调用DAO层的层

那么我们的代码分层就主要是controller层，service层和DAO层，这三次就是三个不同的包，我们会在这三个包下创建各种不同的类，然后将他们联系在一起，这三层的关系简而言之就是controller层调用service层，service层调用DAO层，但是不可以反过来，不可能出现DAO层调用service层的情况，controller层发出命令，传递给service层，然后通过service层传递给DAO层，DAO层在文件中寻找对应数据，找到了之后就返回这个数据给service层，service层返回给controller层，这样的关系

分层代码的好处可以提高程序的可拓展性，降低代码的耦合度，比如说我们后期学习了数据库之后我们肯定就不会再使用什么IO流了，那么我们这时候就只要更换DAO层的代码就可以了，如果我们不用代码分层的话，那代码随便一改可能就不能用了，这肯定是不行的，这时候，代码分层的好处就体现出来了



用户数据的初始化

那么到此为止我们就要正式进入到编码阶段的学习了，我们先从简单的开始，现在我们每次创建用户都会在用户管理里生成一些固定的用户，但是这些都只是保存在用户里的，我们需要利用IO流把它改成持久化的，让我们的数据即使在我们结束程序之后也不会丢失

我们先进入到module里的user类里查看，可以看到对应的用户类

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc6b7589e728d173268d064004798398f.png)

那个哪个类才是我们所需要的对应的用户管理的图书界面的controller层呢？其实是UserViewCtrl，从名字上也看得出来了其实，而像其他的类则是对应其他的界面，比如说像是充值，修改，删除，一类的界面，当然他们都是用户管理的界面就是了，因为整个user包下的字节码文件和controller层是构成整个用户管理的界面的，只是对应的地方不同的分别罢了

我们点进UserViewCtrl中去可以看到这个类里实现了Initializable接口，重写了其Initializa方法如下

```javascript
@Override
public void initialize(URL location, ResourceBundle resources) {

    users.add(new User(1, "张三", "正常", new BigDecimal(("100"))));
    users.add(new User(2, "李四", "正常", new BigDecimal(("100"))));
    users.add(new User(3, "王五", "正常", new BigDecimal(("100"))));
    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    c2.setCellValueFactory(new PropertyValueFactory<>("name"));
    c3.setCellValueFactory(new PropertyValueFactory<>("money"));
    c4.setCellValueFactory(new PropertyValueFactory<>("status"));
    userTableView.setItems(users);
}
```

可以看到我们在这个方法里先创建了三个用户对象，这个用户对象其实就是默认的用户对象，一旦我们创建用户就会有的，显示在用户管理里的三个对象，并将这三个对象就传入了users的集合中

注意这三个对象是我们在代码里自己new出来的，是存储到内存中的，一旦我们的程序终止了，那么这三个对象就会一起消失（不过我们程序启动的时候又会再创建回来就是）

而users集合的产生是源于这个代码

```javascript
ObservableList<User> users = FXCollections.observableArrayList();
```

可以看到user类不知道调用了什么方法然后返回了一个ObservableList类型的集合对象，并且我们限定该集合中只能存放user对象，为了加深理解，我们不妨来看看ObservableList的集合对象的继承结构图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6e25630e5a61e5954b497fa8993465f1.png)

可以看到该类其实继承了List类的，所以该类其实是和List接口类是十分相像的，实际上，里面也的确有add方法那些，其实直接把这个user对象当List对象来用就完了，这样好理解多了

那么这个ObservableList集合有什么用呢？我们注意看英文，发现其有Observable，其意思是可观察的，也就是说，像在放到这个集合中的对象，是能够在对应的界面中展示出来的，如果我们修改了张三为其他名字，那么对于界面上的张三也会发生变化，这一切都是这个ObservableList的对象的功劳

那么接下来我们来讲讲第7行到第10行的代码，我们可以看到这些代码调用了c1，c2，c3对象里的方法，那这些对象是什么？其实这些对象是该类的成员变量，其数据类型为TableColumn<User, String>

```javascript
@FXML
private TableView<User> userTableView;
@FXML
private TableColumn<User, String> c1;
@FXML
private TableColumn<User, String> c2;
@FXML
private TableColumn<User, String> c3;
@FXML
private TableColumn<User, String> c4;
```

那这些类型有什么用呢？其实这些类型代表的意义是列，每一个对象就代表我们图书管理中的一列，而类似于下面这样的代码

```javascript
    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    c2.setCellValueFactory(new PropertyValueFactory<>("name"));
    c3.setCellValueFactory(new PropertyValueFactory<>("money"));
    c4.setCellValueFactory(new PropertyValueFactory<>("status"));
```

其本质的意义是我们是先在集合里寻找对应的属性的数据，然后传入给c1等对象，然后这些对象会将传入的数据展示出来

为了进一步加深理解，我们可以到对应的fxml对决中看看，我们可以看到如下内容

```javascript
<TableView fx:id="userTableView" prefHeight="600">
    <columns>
        <TableColumn fx:id="c1" text="编号">
        </TableColumn>
        <TableColumn fx:id="c2" text="姓名">
        </TableColumn>
        <TableColumn fx:id="c3" text="余额">
        </TableColumn>
        <TableColumn fx:id="c4" text="状态">
        </TableColumn>
    </columns>
    <columnResizePolicy>
        <TableView fx:constant="CONSTRAINED_RESIZE_POLICY"/>
    </columnResizePolicy>
</TableView>
```

这里的c1，c2，其实就是对应字节码文件的上的那些内容，我们在fxml文件中添加了这些代码，相当于在界面上可以就获取文件中的数据内容并展示，同时我们在字节码文件中加入了对应的注释将字节码文件与fxml文件关联起来

这里的编号余额状态其实是我们的界面中最上方的类型内容

最后我们来看看最后一行代码

```javascript
    userTableView.setItems(users);
```

这行代码的意思是将user集合对象传入给对应的界面，因为我们的用户数据都是存放到这个集合里的，我们要展示其中的内容自然要得到这个集合，因此我们要将这个集合传入，这样我们的jvm虚拟机才能正确在界面中展示我们所需要的内容



用户数据的持久化

那么接着我们的目标就是将这些数据存到一个文件中去，这样就可以达到数据持久化的效果。那么我们写一个工具类，这个工具类会创造文件，并且将我们存放于内存中的数据内容都写入到文件中去

我们先在com.bjpowernode包下创造一个util包，在包下创造一个InitDataUtil的工具类，那么我们可以构造代码如下

```javascript
/**
 * 初始化用户参数
 */
//此处加入传入参数是为了后续的一些操作做准备，这里暂时先这样构造代码
public static void initUser(List<User> userList){
    ObjectOutputStream oos = null;
    //创建相关文件夹和文件
    try {
        File directory = new File("user/");
        File file = new File("user/user.txt");
        //若文件夹不存在则创建文件夹
        if(!directory.exists()){
            directory.mkdir();
        }
        //若文件不存在则创建文件
        if(!file.exists()){
            file.createNewFile();
            List<User> list = new ArrayList<>();
            //如果传入的集合中没有数据，则手动添加一项指定的用户数据
            //若已有数据则令传入的集合被我们的创建的集合所记录
            if(userList == null){
                list.add(new User(1001,"张大虎","正常", BigDecimal.TEN));
            }else {
                list = userList;
            }
            //利用对象输出流将list集合内的数据序列化
            oos = new ObjectOutputStream(new FileOutputStream("user/user.txt"));
            oos.writeObject(list);//序列化集合
            oos.flush();
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //关闭流
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

值得一提的是这里是对User对象进行了序列化，因此要令bean包下的User对象实现可序列化接口，否则会报错

但是上面的代码仍然有问题，最明显的一点就是我们的路径是在很多地方都会用到的，而如果我们每次都要自己传入的话，那就太复杂了，而且这样将来如果我们文件的路径改变了，那么我们的代码也要跟着改变很多，这样就太麻烦了！因此我们最好把路径固定为一个常量，同理我们的用户状态也是一样的道理（不过这里还有其他的原因是用户状态一般不常变而且变化的状态也不多，因此统一形式比较好），我们这里写"正常"代表用户的状态似乎没有问题，但如果换其他人来可能就写成"OK"，这样的话就不统一了，因此我们也要用常量表示，不过用户状态的常量已经在我们原来的项目中定义过了，因此不用我们定义了

那么我们首先在bean包下创造新的路径常量类如下

```javascript
package com.bjpowernode.bean;
/*
    路径常量类
 */
public class PathConstant {
    public static final String USER_PATH = "user/user.txt";
}
```

接着我们的代码就可以改成这样

```javascript
/**
 * 初始化用户参数
 */
//此处加入传入参数是为了后续的一些操作做准备，这里暂时先这样构造代码
public static void initUser(List<User> userList){
    ObjectOutputStream oos = null;
    //创建相关文件夹和文件
    try {
        File directory = new File("user/");
        File file = new File(PathConstant.USER_PATH);
        //若文件夹不存在则创建文件夹
        if(!directory.exists()){
            directory.mkdir();
        }
        //若文件不存在则创建文件
        if(!file.exists()){
            file.createNewFile();
            List<User> list = new ArrayList<>();
            //如果传入的集合中没有数据，则手动添加一项指定的用户数据
            //若已有数据则令传入的集合被我们的创建的集合所记录
            if(userList == null){
                list.add(new User(1001,"张大虎", Constant.USER_OK, BigDecimal.TEN));
            }else {
                list = userList;
            }
            //利用对象输出流将list集合内的数据序列化
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.USER_PATH));
            oos.writeObject(list);//序列化集合
            oos.flush();
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        //关闭流
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

