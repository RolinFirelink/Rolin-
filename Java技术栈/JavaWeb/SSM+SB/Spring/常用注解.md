我们学习完了spring整合mybatis，利用配置文件实现之后，接着就到了我们的传统艺能，使用注解来实现了，本章我们的主要内容就是来学习相应的注解

- 注解开发的作用与弊端

我们为什么要使用注解开发呢？第一点来说就是注解开发能够让我们的代码变得更加简洁，程序员写起来也更加舒服，因为我们的注解在我们要使用的时候直接往方法上面加对应的注解就完了。而配置文件开发，我们开发的时候肯定是要从java类和配置文件中切来切去的，就突出一个麻烦，所以我们推荐使用注解开发

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2df63c76335d997ea653af2d75c1f673.png)

在上图中就演示了对应的注解对应映射中的属性，@Component注解对应bean标签，要写入id属性就直接往里面填括号

而@Scope对于scope属性，写入属性同理

@PostConstruct和@PreDestroy两个注解分别对应bean中的初始化和摧毁方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4e5872c03f231317bf276ba6e96da87c.png)

但是虽然话是这么说，但是用注解开发并不总是更好的，比如使用注解驱动无法在第三方开发的资源中进行编辑，最简单的例子就是我们注册驱动的代码，如果我们用注解的形式来写的话，那么我们就不得不手动进行一个获取对应的连接，虽然我们也很想通过注解直接完成这个动作的，但是注解是应用在java代码中的，而druid一类的连接池是第三方提供给我们的，因此我们无法去给里面的代码加上注解，因为其不允许我们修改

在现实的项目开发中，XML适用于配置第三方的资源，而注解适用于在第三方资源的基础上进行的开发。由于实际做项目我们肯定是开发的内容远远多于配置的，因此使用注解开发导致的这些问题是可以接受的

- bean定义常用注解（定义、作用范围、生命周期）

首先要启动注解功能我们首先要启动注解扫描，注解扫描的代码就如下图所示的一行，包名我就填写要扫描的包，这个包可以任意大，但是为了效率我们要尽量将这个包精确

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEafc311cc70fd5547fbf6eeb4b6e6d140.png)

无论是注解格式还是XML配置格式，最终都是将资源加载IoC容器中，其差别在于数据读取方式不同，但是从加载效率而言注解优于XML配置文件

首先我们写入我们的applicationContext.xml的配置代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!--启动注解驱动，指定对应扫描的路径，也就是资源所在的包-->
    <context:component-scan base-package="com.itheima"/>

    <!--<bean id="userService" class="com.itheima.service.impl.UserServiceImpl" />-->

    <!--<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" />-->

    <!--<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl" />-->

</beans>
```

为了实验我们还准备了三个对应的配置的类，这里我们先注释掉了

在讲解注解类之前，我们先来对我们的项目整体进行一个说明，我们定义了BookDao和UserDao的实现类，实现类里就只是写了非常简单的打印语句而已，在UserService里也是同理，但是在这个类里我们还额外提供了初始化方法和摧毁方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE70522ea87dfb1753bd1cef514b3ccb0a.png)

如果我们想要注解来达到配置文件中bean标签的效果，那么我们要使用注解@Component，其实还有另外三个，其效果也是一样的，不过没什么用，我们还是用最开始的那个。其下有value属性，可以定义bean的访问id，当然我们不定义也可以

那么使用定义，我们可以将我们对应的我们的对应的类修改如下，首先是BookDao的实现类

```
@Component("bookDao")
public class BookDaoImpl implements BookDao {
    @Override
    public void save() {
        System.out.println("book dao running...");
    }
}
```

然后是UserDao的实现类

```
@Component("userDao")
public class UserDaoImpl implements UserDao {
    @Override
    public void save() {
        System.out.println("user dao running...");
    }
}
```

最后是UserService的实现类

```
//定义bean，后面添加bean的id
@Component("userService")
//设定bean的作用域
@Scope("singleton")
public class UserServiceImpl implements UserService {

    public void save() {
        System.out.println("user service running...");
    }

    //设定bean的生命周期
    @PostConstruct
    public void init(){
        System.out.println("user servier init...");
    }

    //设定bean的生命周期
    @PreDestroy
    public void destroy(){
        System.out.println("user servier destroy...");
    }
}
```

然后我们写入我们的测试类代码如下

```
import com.itheima.dao.BookDao;
import com.itheima.dao.UserDao;
import com.itheima.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        //UserService userService = (UserService) ctx.getBean("userService");
        UserService userService = (UserService) ctx.getBean("userService");
        userService.save();

        UserDao userDao = (UserDao) ctx.getBean("userDao");
        userDao.save();

        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();

    }
}

```

实际运行之后我们发现我们能够得到我们想要的结果

这里我们值得一提的是@Socpe是设定bean的作用域的注解，简单来说就是设定我们创建的对象是不是单例的，后面的更多注解我们直接看下图中的说明就好了

首先是Scope

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEab89592afe64929b555bc0ea9d38cc4e.png)

然后是生命周期相关的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE056539c29db091acce13fe22f7b1d498.png)

- 注解配置第三方资源（工厂加载bean的形式）

接着我们来学习如何使用注解来配置第三方的资源，这里我们要使用到注解@Bean，使用注解Bean可以让我们的某个方法返回的对象被Spring管理，通过这个方式来替换配置文件中获取连接池对象的代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE59b86bc560d196e714f2eba7372e402c.png)

值得一提的是，由于我们的Bean所在的类必须在Spring扫描加载才能生效，因此我们还要在类上加入注解@Component，这个方法以后是要替换掉的，暂时我们先使用这种方式让我们的类能够被spring扫描到，那么我们可以写入代码如下

```
package com.itheima.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component
public class JDBCConfig {
    @Bean("dataSource")
    public DruidDataSource getDataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://175.178.114.158:3306/spring_db");
        ds.setPassword("itheima");
        return ds;
    }
}

```

在测试类中获取连接池对象并打印，能够得到对应的内容，这说明我们的注解开发是没有问题的

- 属性注入常用注解

我们先来讲讲关于非引用类型的使用注解进行属性注入的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE710100132d34bddb65b54dd23f8559b6.png)

我们首先创建对应的int num属性和String version属性，接着提供对应的set方法，如果我们想要通过注解对其进行赋值的话，我们只需要在其上直接直接写入@Value注解并在括号中写入我们要赋予的值就可以了，同时这个注解也可以放在我们的属性对应的set方法上来完成属性的注入，当然，实际上我们可以将set方法省略，直接在对应属性上写入对应的注解并赋予值就可以了

```
@Value("3")
private int num;
@Value("itheima")
private String version;
```

有的同学会觉得这么做不脱裤子放屁吗？你直接用=的形式给他值不好吗？其实这里我们主要还是训练一个这一类注解的使用规范，后期我们这一类的注解还可以连接properties文件来进行数据的引入，而这种方式则是普通的赋值方式所难以代替的

那么非引用类型的属性注入学习完之后，接下来我们学习引用类型的属性注入

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc84f16b8b67a04af9c85c24346516a86.png)

首先我们在我们的UserServiceImpl中添加对应的引用变量UserDao和BookDao，如果我们希望注入我们所指定的实现类，那么只要直接在对应的属性上加上@Autowired注解就可以了，当然，这个前提是在我们对应的包里，只有一个对应的实现类，如果有两个及以上的话，那么其会根据其实现类中的@Component注解中括号里起的名字来定位，如果有括号内的取名和我们实现类中的取名是一样的，那么其就会自动加载该实现类。如果都不一样就报错

同时如果我们使用@Component但是不往括号内添加内容的话，也就是不取名的话，其会默认使用该实现类的类名来给自己取名，同时注意该注解不可以取两个一样的名字，否则会报异常

那我们如何来避免这个报错呢？我们有两种方式，一种是在我们对应的要使用的实现类中再加入@Primary注解，使用该注解会让我们的程序运行时优先使用这个实现类，但是这个只能定义一次，一旦使用该注解定义了两个及以上的相同实现类，那就报错。另外一种方式是使用@Qualifier注解，使用该注解往括号内添加指定的名字，那么当我们的程序搜索到两个及以上相同类时，就会使用该注解进行搜索，找到对应的名字的类并加载，同时该注解的优先级高于@Primary

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1b14fe0052a915cadc443642b90bdf21.png)

最后来看一些了解的内容

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8c53db17ed6652159f127cd01bf24b9d.png)

- 加载properties文件中的属性

首先我们加载properties文件要使用的注解是@PropertySource，内部要写入我们要加载的properties文件的路径，我们可以写入多个配置文件令其加载，如果想要实现这个的话，就需要用大括号括住内部写入的路径，并用,分隔开，同时我们写入不存在的路径是会报错的，如果想要解决这个报错，可以用ignoreResourceNotFound属性，设置其为true，可以令其无视我们未找到的资源，但仍然会报出警告

当我们想要在内部进行赋值时，就要使用@Value注解进行注入

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe3d61a353117dfc046fac1acc91df22a.png)

那么我们可以写入其代码如下

```
package com.itheima.dao.impl;

import com.itheima.dao.BookDao;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@Primary
@PropertySource(value = {"classpath:jdbc.properties","classpath:abc.properties"},ignoreResourceNotFound = true)
public class BookDaoImpl implements BookDao {
    @Value("${jdbc.userName}")
    private String userName;
    @Value("${jdbc.password}")
    private String password;

    @Override
    public void save() {
        System.out.println("book dao running...1"+userName+" "+password);
    }
}

```

jdbc文件的代码如下

```
jdbc.userName=root6564
jdbc.password=itheima
```

- 纯注解驱动制作

那么到现在为止，我们常用的注解类基本就学习完了，现在我们还缺最后一个，就是用注解来加载我们配置文件中的固定开头格式以及我们定义的要扫描的注解代码的类的位置的代码，将这两个代码都用注解来表示，我们就实现了纯注解开发了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd3af8b875a088afbb35b07e342307340.png)

那么我们要做的是就是用核心配合类来替换spring中的核心配置文件，此类是可以设置为空的，不设置任何变量和属性。因此我们创建一个新的config类，我们在其上先添加@Configuration注解，该注解就是代替核心配置文件中的固定开头，然后我们要设定properties的扫描路径，这里我们就使用ComponentScan注解，往括号内写入我要扫描的路径的包

```
package com.itheima.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.itheima")
public class SpringConfig {
    
}

```

最后我们将我们的测试类修改如下

```
import com.itheima.config.SpringConfig;
import com.itheima.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext-back.xml");

        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);

        //UserService userService = (UserService) ctx.getBean("userService");
        UserService userService = (UserService) ctx.getBean("userService");
        userService.save();

/*        UserDao userDao = (UserDao) ctx.getBean("userDao");
        userDao.save();

        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();

        DruidDataSource dataSource = (DruidDataSource) ctx.getBean("dataSource");
        System.out.println(dataSource);*/
    }
}

```

可以看到我们注解类里唯一的变动就是获得ApplicationContext对象时，不是采用配置文件获得，而是给其传入了我们对应的注解类的class对象的代码。而且使用的也是AnnotationConfigApplicationContext的对应构造方法。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf54368573073ae77b2bf16bd7f64db66.png)

- 导入第三方资源对应的配置类

我们之前做过使用注解来创建我们生成连接池的内容，那时我们为了让我们的文件能够被Spring编译到往上加了一个@Conponent注解，但那是不标准的，我们又更好的方法，就是使用@Import注解，将其写在我们的Config注解文件上去，括号内传入我们要被spring控制的资源的class对象，其就可以将其正确加载了，以后如果我们要导入第三方的bean，也是采用这种方式的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE979d66e7c2aa96c3e8ee79737b7b2b5d.png)

那么我们可以写入我们的代码如下

```
package com.itheima.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@ComponentScan("com.itheima")
@Import(JDBCConfig.class)
public class SpringConfig {

}

```

注意我们如果要导入多个第三方的包，我们直接往注解里加就可以了，用逗号分隔开，我们是不允许使用两个Import注解的

- bean加载控制

关于依赖加载，我们可以通过@DependsOn来控制我们的依赖加载的顺序，比如说，我们已知在我们的程序中，我们是Service调用Dao，而我们的Dao是比Service要先加载的，这是自然的，因为我们的Service要调用Dao，那你肯定是从里边开始生成的是吧。但实际上我们可以通过@DependsOn注解来让我们的Service先于我们的Dao加载，然后再执行我们的程序，如果要实现这个目的，我们就要往我们的Dao中添加这么一行代码

```
@DependsOn("userService")
```

这行代码可以写到我们的方法上或者是类上，其代表的意义是，该类或者是该方法的运行依赖于userService类，当我们的程序检测到这个注解的时候，其就知道该类依赖于另一个类，那么其就会查找到对应的类并先加载这个类。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0e942259ef87776d15177adb726089af.png)

然后是其实我们的配置类也可以通过对应的注解来定义我们的加载顺序，这里的情况是我们定义了多个核心注解配置文件的话，我们只要在对应的配置文件上加入@Order注解就可以了，其括号内填入数字，数字越高代表优先级越高，优先级高的配置文件会先加载

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8fb378b36cd464595d0b9fda64659e05.png)

最后是一个延迟加载的了解内容，具体看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE501085a24befc426f5fca4a723778ecb.png)

接着我们来了解下具体的依赖加载的应用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4329d5d6ba505ea45b2f5fb8dfbaf6d6.png)

首先似乎关于DependsOn，其应用场景的经典例子就是就是微信订阅，我们总是希望发布消息是慢于订阅消息的bean的加载的，这样才能保证接受的消息不会缺失，此时就需要我们的本注解，本注解的使用场景在于我们明确某一些类一定要先于另一些类加载时，我们就使用此注解

而@Lazy注解，也就是延迟加载的经典例子就是用于灾难处理，我们可以设置一个方案用于应急处理，但是如果我们一直将其创建出来放着就浪费内存，所以我们可以延迟加载该类，只有当我们的某些部分崩溃之后该类才会加载并执行

最后是@Order类，该类可以用于多个种类的配置文件，比如说我们可以将我们的注解配置文件进行分类，分为系统级和业务及的，我们总是令其先加载系统级的后加载业务及的，这样能避免细粒度的加载控制