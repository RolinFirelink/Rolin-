- 用最少数量的箭引爆气球

现在我们就拿上一个学习的知识点拿来用用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE69fd72bad3a646fc826a997b192e24b6.png)

首先我们分析题目，可以知道其需要的使用最小的箭来射中最多的气球，气球只能确定其直径，只要我们的最初的下标在其直径中即可射破

那么首先我们就要对我们的数组进行排序，我们让直径对应的下标小的数组排前面，大的排后面，如果最开始的下标都一样，那么我们就直径的结束下标从小到大排序，这样就能够保证我们的数组的最小排在起点，最大的排在后面按顺序排列，便于我们后面的处理

为了让气球尽可能的重叠，需要对数组进行排序

如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过，只要记录一下箭的数量就可以了。

然后我们遍历我们的数组，最开始我们取出第一个下标代表的直径，然后在不断的遍历中我们缩小第一个半径，直到我们判断出一个数组的起点就比其终点要高或者是终点比起点还低时我们就射出箭，然后重置当前保存的数组对象，继续执行该过程

最后由于我们肯定最起码要射出一个箭的，所以我们这里最开始设置的箭的数量就是为1

```
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0]==o2[0]){
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        int ans = 1;
        int[] arr = points[0];
        for (int i = 0; i < points.length; i++) {
            if(points[i][0]>arr[1] || points[i][0]<arr[0]){
                ans++;
                arr=points[i];
            }else {
                arr[0]=Math.max(arr[0],points[i][0]);
                arr[1]=Math.min(arr[1],points[i][1]);
            }
        }
        return ans;
    }
}
```

我们这里的贪心思路就是，找到半径重合最多的气球，然后射出箭，这是局部最优，通过这个局部最优可以获得全局最优

最后我们来看看官方题解的过程，其贪心过程也跟我们差不多，不过这里多了一个注意点，那就是如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4099423bcafd1b37dd571b4069a2b290.png)

那么最终我们可以写入我们的代码如下

```
/**
 时间复杂度 : O(NlogN)  排序需要 O(NlogN) 的复杂度

 空间复杂度 : O(logN) java所使用的内置函数用的是快速排序需要 logN 的空间
 */
class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) return 0;
        //用x[0] - y[0] 会大于2147483647 造成整型溢出
        Arrays.sort(points, (x, y) -> Integer.compare(x[0], y[0]));
        //count = 1 因为最少需要一个箭来射击第一个气球
        int count = 1;
        //重叠气球的最小右边界
        int leftmostRightBound  = points[0][1];
        //如果下一个气球的左边界大于最小右边界
        for(int i = 1; i < points.length; i++){
            if (points[i][0] > leftmostRightBound ) {
                //增加一次射击
                count++;
                leftmostRightBound  = points[i][1];
                //不然就更新最小右边界
            } else {
                leftmostRightBound  = Math.min(leftmostRightBound , points[i][1]);
            }
        }
        return count;
    }
}
```

我们这里首先进行排序，然后我们首先确定第一个气球的最小右边界，每次循环判断当前半径的起点是否大于最小边界，若大于，则进行射击然后更新最小边界为被设计气球的直径尾部。反之则更新最小边界，从当前值和当前对应气球的直径的尾部中进行更新，看看谁更小（其实吧，我觉得这代码还不如我的代码好理解呢）

- 无重叠区间

学习完了上面的题目看，我们再来一题加深我们的印象

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0276119248338be3378d71009af9f93d.png)

那么我们这里的思路其实很简单，既然其要我们移除所有的重叠区间，且使用的数目最小，那么我们就尽量移除掉所有重叠的区间即可，遇上重叠区间就直接移除掉，但是为了让我们的移除的数目最小，因此我们希望我们的区间分配尽可能按顺序覆盖到我们的所有位置，所以我们需要对我们的数组按照一定的规则进行排序

我们排序的思路就按照小区间在前的思路来排，那么我们首先判断其结束区间是否一致，若一致我们就让开始区间小的排在前面，若不一致我们就让结束区间大的排在后面，最终我们的得到的数组就是尽可能按区间由小到大顺序重叠好的数组

然后我们同样是取出第一个数组用于遍历，如果当前的区间的开始半径比不严格大于我们的当前的半径的结束半径或者是当前区间的结束区间不严格小于我们当前区间的起始半径，我们就直接移除这个，移除不需要真的移除，直接让我们的计数+1即可，反之我们就更新我们的区间到下一个区间，继续进行对应的遍历

```
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[1]==o2[1]){
                    return o1[0]-o2[0];
                }
                return o1[1]-o2[1];
            }
        });
        int[] arr = intervals[0];
        int ans = 0;
        for (int i = 1; i < intervals.length; i++) {
            if(intervals[i][0]>=arr[1] || intervals[i][1]<=arr[0]){
                arr=intervals[i];
            }else {
                ans++;
            }
        }
        return ans;
    }
}
```

其实实际上我们哪怕是按照左边界排序也可以，只不过我们遍历的时候就要从右往左遍历了，这样只会更加麻烦，我们这里就不演示了，没什么必要属于是

- 合并区间

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcf1d533f0d2d7b067952c5deca04140d.png)

这题我们的做法也是跟之前的一样的，我们首先要将我们的区间进行排序，令其尽可能按顺序重叠，然后我们遍历整个区间，如果说当前区间终点小于之前记录的区间的起始值或者是其起点大于之前记录的区间的最大值，我们都可以判定没有可以合并的区间了，此时加入到我们的集合中，反之则继续扩大我们的区间范围

最后返回集合转换过来的二维数组即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1df3506ee02c3a4e6b5271d661b7e270.png)

那么我们可以写入我们的代码如下

```
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0]==o2[0]){
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        List<int[]> list = new LinkedList<>();
        int[] arr = intervals[0];
        list.add(arr);
        for (int i = 0; i < intervals.length; i++) {
            if(intervals[i][0]>arr[1] || intervals[i][1]<arr[0]){
                arr=intervals[i];
                list.add(arr);
            }else {
                arr[0]=Math.min(intervals[i][0],arr[0]);
                arr[1]=Math.max(intervals[i][1],arr[1]);
            }
        }
        return list.toArray(new int[list.size()][]);
    }
}
```

- 划分字母区间

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE63947a3290fbe6760dc7fb902207c719.png)

这题我们可以结合Set集合来完成，首先既然我们希望每个最多的字母出现在同一个片段中，那么我们的贪心思路就是尽可能将相同的字母加到同一个集合中，第一次直接加入下标代表的一个，然后每次要加入新的字母前我们判断后面还有没有当前片段中存在的字母，若存在就继续加入，不存在则说明该片段就是局部上的最优的全部字母都存在的区间

那么根据上面的思路，我们容易写出我们的代码如下

```
class Solution {
    List<Integer> list = new ArrayList<>();
    public List<Integer> partitionLabels(String s) {
        Set<Character> set = new HashSet<>();
        int index = 0;
        for (int i = 0; i < s.length(); i++) {
            set.add(s.charAt(i));
            boolean judge = true;
            for (int j = i+1; j < s.length(); j++) {
                if(set.contains(s.charAt(j))){
                    judge=false;
                    break;
                }
            }
            if(judge){
                list.add(i-index+1);
                index=i+1;
                set.clear();
            }
        }
        return list;
    }
}
```

这份代码虽然是可行的，但是由于构建了双重循环，因此其效率并不算高，我们接下来来学习下效率更高的方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb3a655e48e8e92c3aea430ee29cc1fdc.png)

这个思路简单来说就是先通过一次遍历得到所以字母最后出现的下标，最终我们得到的结果数组必然存放着所有字母的最远下标

接着我们再遍历一次，每次取出之前的对应的字母的最大下标，当我们当前的下标与出现的最大下标相等时，则说明此时我们到达了目标位置，此时只要将对应的结果加入到集合中即可

```
class Solution {
    public List<Integer> partitionLabels(String S) {
        List<Integer> list = new LinkedList<>();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }
        int idx = 0;
        int last = -1;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i] - 'a']);
            if (i == idx) {
                list.add(i - last);
                last = i;
            }
        }
        return list;
    }
}
```

这个思路虽然说确实效率高，代码也比较简洁，但说实话，这个思路不太好想，而且说实话，这个正确性的证明我说实话我是不太搞得懂，所以，我觉得看看就得了，不是很具有参考价值说实话

