- 模块聚合

我们之前将我们的项目进行了分模块的开发设计，其中我们构建了一个由上往下的线性的依赖关系，那么此时就会产生一个问题，如果我们的模块其中一个进行了更新怎么办？这时其他的依赖是不知道其进行了更新的，因此也没有进行对应的更新，那么此时就可能会产生依赖之间不匹配的情况

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE461944bbfe06923e3d2283fc484e0dfe.png)

为了解决这个问题，于是我们有了聚合这个功能，所谓的聚合，其作用就是创建一个空模块，该模块的作用就是用于维护我们的多个模块之间的关系

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8653ca92eace57b4d67c4afcc7edd3cf.png)

那么如果要创建这个一个聚合模块，那么我们首先要创建一个maven模块，然后在其下的pom文件中指定其打包类型为pom，接着写入代码如下

```
<!--管理的工程列表-->
<modules>
    <!--具体的工程名称-->
    <module>../ssm_pojo</module>
    <module>../ssm_dao</module>
    <module>../ssm_service</module>
    <module>../ssm_controller</module>
</modules>
```

我们这里写入了我们的管理的工程标签，然后其下加入了对应的工程名称，接着我们对这个模块进行编译，其就会更新我所管理的所有工程了

这里要注意一点的是我们的顺序问题，我们编译时会发现无论我们的配置顺序如何改变，我们的工程编译总是先是pojo、然后是dao、service、controler这样编译的。这是因为我们的依赖顺序是pojo被dao所依赖，所以我们总是要先编译pojo，其他的也是一样的道理。简而言之，即是参与聚合操作的模块最终执行顺序与模块间的而依赖关系有关，与配置顺序无关。

- 模块继承

接着我们来讲模块的继承，上一节我们实现了多模块的统一维护，但其仍然存在一个问题，那就是版本兼容问题。比方说其下的不同模块之间可能都依赖同一个资源，而有一天另一个模块更新了其使用的对应的资源，那么此时就可能会出现资源不兼容的情况

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5bda5edbecce02410af31cf516f06a65.png)

此时我们就期待有这么一个文件，其不但可以维护各个模块，而且还可以为其统一的资源做调配，如果他们都是使用一个资源，那么就按照其父类的资源来用，如果有一个需要更新版本，那么父类就会对其进行处理，看看能不能统一更换版本，这个其实就是我们本节要讲解的继承

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe4e829eae8c711f4dae776ed9190faee.png)

首先我们要使用继承，当然要先定义一个用于维护整个工程的父类模块，然后我们在其下利用dependencyManagement标签来声明此处进行父类的依赖管理，接着其下正常写入要进行管理的依赖，注意我们此处需要写入版本，而且其下的依赖资源应该最好都是以一个直接的形式存在，而不是我们的依赖依赖会默认引入另外一个依赖的隐式存在，前者的直接存在可以让子类更好的获得所需要的资源，我们维护起来也更快。

我们一般的依赖管理是在其下添加我们的工程中所有用得上的工程模块依赖的版本，然后我们再使用这个模块对我们的项目里的小模块进行统一的管理的维护，这里所有的资源不但可以写入别人的资源，甚至可以添加自己的工程模块的依赖。

而对于插件，我们也有对应的pluginManagement标签来进行对应的插件管理，使用方法和前面是一样的

然后我们对于子类的模块，如果其要使用父类的资源，那么其就要先定义该工程的父工程，其实就是填入父工程的坐标而已，最后还要写入父工程的pom文件的路径，注意，这里要填入的是寻找对应的pom文件的全虚拟路径，而不是直接整一个pom文件的名字下去

```
<!--定义该工程的父工程-->
<parent>
    <groupId>com.itheima</groupId>
    <artifactId>ssm</artifactId>
    <version>1.0-SNAPSHOT</version>
    <!--填写父工程的pom文件-->
    <relativePath>../ssm/pom.xml</relativePath>
</parent>
```

接着我们的子类只要引入了上面的内容，我们如果要进行统一管理，就可以不用标注自己要使用什么版本了，直接使用父类规定好的版本就可以了，如果的确有什么版本是父类无法提供的，或者是有什么坐标父类里没有规定的，那么到时候就手动引入依赖或者是规定版本就可以了

最后我们还看看我们可以在父类里提前设定的资源的管理的东西有哪些

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE674401f5715790ce4ab92f3bdf270c21.png)

然后我们来说说继承和聚合的异同，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd9515a368eabae98891de872fa12f99a.png)

- 属性定义与使用

接着我们还有一个问题，那就是我们的在的父类中，有许多的版本可能都是一样的名称，其版本分布还是一样的，如果以后一个更新了，我们就得一个个配置慢慢改，那该多麻烦啊，有没有什么方法可以让我们的一下子一次修改就可以将下面的修改都修改完呢？当然有，此时我们就要讲我们的属性了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb7684025161bb96e00c783b5c3148e9.png)

要使用属性，当然我们要先定义出属性，所以我们应该写入其代码如下

```
<properties>
    <spring.version>5.1.9.RELEASE</spring.version>
</properties>
```

然后我们可以在下面用${}的形式来使用我们上面自己定义的属性，这里我们的属性都要在properties标签下自己定义，我们的往里面可以自定义标签名，这就相当于是属性名，我们可以在下面引用我们的属性名

```
<!--添加自己的工程模块依赖-->
<dependency>
    <groupId>com.itheima</groupId>
    <artifactId>ssm_pojo</artifactId>
    <version>${version}</version>
</dependency>
```

而且在${}里面还有许多的内容我们可以自己引用，这些都是其事先提供好给我们的内容，我们了解下就差不多得了，这里我们就不特别提一下了

- 版本管理

接着我们来讲解我们的版本管理，这一节主要是理论上的内容，先来看看的两个版本的不同区别，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE352c665aa9ddd954c104c2caf4ec3cfa.png)

在具体到我们本项目，我们如果想要更新我的子模块的版本，那么我们就要具体给其version标签下的内容进行更改，这里我们值得一提的是，如果我们想要更改我们的子模块的版本号，那么我们就应该要先将我们的version标签写入再更改，因为我们之前的子模块的版本号是直接沿用父模块的，所以我们要更改的话自然也需要自定义标签，这个很好理解其实。还有一点要提一下的是，工程版本各个企业里是不同的，因此不用记忆，了解下就行了其实

最后来看看我们企业级开发里的工程版本号约定

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE69f977ac7e1de40ac098105df0ddbac2.png)

- 资源加载属性值

我们上一节里，我们们多文件的情况统一到一个变量中去管理，这样便于我们的维护，但实际上，不止pom配置文件可以这么做，我们的properties文件也可以进行这样的管理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4987085b3f87c375a560b3df792b8c52.png)

我们首先在对应的用于维护的模块下的pom文件上写入其代码如下

```
<properties>
    <spring.version>5.1.9.RELEASE</spring.version>
    <jdbc.url>jdbc:mysql://localhost:3306/ssm_db</jdbc.url>
</properties>
```

可以看到我们这里定义了jdbc.url的变量，并且赋予了对应的值，然后我们可以将我们的jdbc.properties的文件代码修改如下

```
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=${jdbc.url}
jdbc.username=root
jdbc.password=itheima
```

可以看到我们上面就是利用${}来获得对应的属性的值而已，但是只是这样还不行，我们还需要到我们的主维护文件中去配置资源文件的信息，其实就是开启解析

```
<!--配置资源文件对应的信息-->
<resources>
    <resource>
        <directory>../ssm_dao/src/main/resources</directory>
        <filtering>true</filtering>
    </resource>
</resources>
```

我们这里的代码都是在build的标签下写入的，这点要先明确，我们先创建一个resources大标签，然后创建对应的子标签，接着我们往里面先指定目录，注意我们这里的目录是先从我们当前的工程的文件下去寻找的，因此我们要先令其回退一级，接着我们再写入对应我们要进行加载的资源的文件路径，然后再设定其filtering属性为true，此时我们的解析就已经开启成功了，此时其能够正确寻找到我们的要开启注解的文件

接着存在的问题是，我们可能会其他模块也想要进行对应的修改，但是如果我们一个个配置的话，那就太麻烦了，此时我们可以将对应的directory标签的内容更改如下

```
<directory>${project.basedir}/src/main/resources</directory>
```

这里我们的project.basedir是其先提供好给我们的一个属性，其代表所有模块的根目录，将代码改为上面的格式，那么其就会自动寻找所有符合该结构的目录的内容并进行相应的修改，又因为我们都知道我们的模块有一些结构是一样的，所以后面的结构可以不做改动，从而实现我们的需求

最后如果我们需要我们的test里面的对应的配置文件也能同样管理的话，只需要再写入代码如下

```
<testResources>
    <testResource>
        <directory>${project.basedir}/ssm_dao/src/test/resources</directory>
        <filtering>true</filtering>
    </testResource>
</testResources>
```

这里我们使用testReources标签并且我们将目录改为test，然后我们的test文件夹里的配置文件就也能够使用我们规定的属性了

- 多环境配置

我们实际在企业开发的时候，我们的环境可能是很多遍的，在生成环境、开发环境以及测试环境中，都需要更改配置，那我们不能每次更换环境我们都手动更换一次环境吧？那就太麻烦了，为了解决这个问题，maven提供了多环境兼容的解决方案

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6aa06a7bb23b6b3bdc7e0a7610d85879.png)

要使用多环境的解决方案，首先我们要创建多环境，多环境的标签是profiles，其下可以使用子标签profile来创建我们的环境，我们的环境需要唯一标识，因此我们需要给予其对应的id，然后我们再其下定义需要换用的属性值就好了

```
<!--创建多环境-->
<profiles>
    <!--定义具体的环境：生产环境-->
    <profile>
        <!--定义环境对应的唯一名称-->
        <id>pro_env</id>
        <!--定义环境中换用的属性值-->
        <properties>
            <jdbc.url>jdbc:mysql://localhost:3306/ssm_db</jdbc.url>
        </properties>
        <!--设置默认启动-->
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
    </profile>

    <!--定义具体的环境：开发环境-->
    <profile>
        <id>pro_env</id>
        <properties>
            <jdbc.url>jdbc:mysql://localhost:3308/ssm_db</jdbc.url>
        </properties>
    </profile>
</profiles>
```

需要不同的环境，我们就自己去创建多个相同的标签然后指定我们所需要的内容。然后我们还需要指定其加载的环境，指定的方法很简单，我们点击右上方的启动标签，然后自己定义其方法，假如我们想让我们的install加载我们的环境的话，那么我们就要在其后面写入-p 环境定义id，然后我们执行该方法的时候就会通过我们指定的环境配置进行加载了

同时如果我们每次都要去自己指定的话，未免有些麻烦，其实我们还可以指定最开始默认的配置，那就是我们上面11-14行的代码，这里我们设置我们的命令默认启动时会加载的环境，这样我们就每次都去指定了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8cb3631de32cc3fcf7910715cb6e98c4.png)

- 跳过测试

这是一个了解性的内容，我们实际开发的时候对于可能有很多的测试要做，而可能有些测试我们又已经能确定他们已经好了，我们不需要再测试了，此时我们就需要跳过这些测试，但是注意，跳过测试可能会造成一大堆有的没的问题，所以平时没事就不要跳过测试

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf2216f5c4f53d55289028e5a7d276e43.png)

跳过测试有三种方式，我们这里都进行逐一的讲解，第一种是进入对应的maven窗口里直接选择对应的要跳过的命令，然后点击上面的闪电标就可以了，这样该方法就会被跳过了，我们执行编译的时候也不会执行这个命令，重新点击则可以恢复

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEabc69a44236ad25b130913fe7870b6b6.png)

第二种方式是选择对应的pom文件，右键选择Run maven选项，然后在弹出的窗口里选择Create new goal，我们输入对应的命令就可以了，比如我们输入如下命令就可以执行安装并跳过测试

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfbf0e509bbab8b7260011671dadaa31f.png)

第三种方式是最重要的方式，我们都知道我们的maven的生命周期的执行过程本质靠的还是插件，那么我们要配置的话，就从插件中来配就可以了，我们去其仓库中寻找，我们测试的插件都是依赖于一个maven-surefire-plugin的插件，那么我们直接在配置标签下写入该代码，这里值得一提的是，我们的群组id是可以不写的，因为我们这里使用的插件是maven自己的，当然你非要写也可以

```
<!--配置跳过测试-->
<plugin>
    <!--配置资源的群组id可以不写也可以写-->
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.12.4</version>
    <configuration>
        <!--设置跳过测试-->
        <!--<skipTests>true</skipTests>-->


        <includes>
            <!--包含指定的用例-->
            <include>**/User*Test.java</include>
        </includes>

        <excludes>
            <!--包含排除的用例-->
            <exclude></exclude>
        </excludes>
    </configuration>
</plugin>
```

然后我们在其下可以配置configuration标签，其下可以设置skipTests属性，设置为true则跳过所有测试，我们也可以使用includes或者是excludes标签进行包含性排除或者是排除性排除，里面的设定是可以使用通配符来进行对应的设置的