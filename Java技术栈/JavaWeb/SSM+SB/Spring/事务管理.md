那么接着我们学习Spring的内容，数据管理，首先我们对事务这一概念进行一个复习

- 事务基础概念的回顾

首先是关于事务本身的定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE446d28e9761e8e3e5f53f9fdd83a4f88.png)

然后是事务的作用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE36d3d22446b29ca32c8087b1dc5d4f7f.png)

接着我们来了解下事务的特征

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe9d962226f16372f2fc655f6cd8a5574.png)

最后是事务的隔离级别，以及不同隔离级别下所会产生的问题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE91a6624e06d2c03e5355aca4a2275809.png)

- spring核心事务对象介绍

接着我们来介绍下spring中事务核心对象的分层，对于简单的业务层转调数据层的单一操作，我们放在数据层还是放在业务层都是可以的，但是一旦我们的业务中包含多个对数据层的调用，那么我们就要将事务放在业务层中，这样才能实现一起执行成功，一起执行失败的效果。为了实现这个效果spring给业务层提供了整套了事务解决方案

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3e41e3d82f571066e56040ccc5c42ace.png)

我们首先来讲下平台事务管理器的实现类，spring给我们提供了一个接口，该接口是PlatformTransactionManager接口，该接口的作用就是用于管理平台事务，我们要使用该接口需要使用其具体的实现类，这里我们一般使用DataSourceTransactionManager实现类，其他的实现类以了解为主，具体的区别和作用自己看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4f5537af425a29a385b656aef342b613.png)

我们的接口的实现类内部自然是定义了事务的基本操作，譬如获取事务，提交事务和回滚事务那些。但是这里的获取事务需要我们传入一个事务定义对象，传入之后其会返回一个事务状态对象给我们，然后我们要通过事务状态对象来进行事务的提交和回滚，这是怎么回事呢？其实这里也很好理解，我们要进行提交事务，肯定得保证事务的状态是可以提交的是吧，什么修改都没做提交个几把，回滚也是一个道理，而且这些判断就是要通过事务的状态对象来进行的，通过传入事务的定义对象，就可以获得当时事务的状态对象

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE20e8bab47e103d7cf993c795bcddae03.png)

然后我们来看看事务的定义对象，内部有许多最基本的方法，比如获取事务的定义名称，获取事务的读写属性和隔离级别等。这里值得一提的是，一般我们调用这些方法都是用于获取的，而不是修改的，这点要记住。最后像事务的隔离级别，其内部是有各种状态码来表示其不同的隔离级别的，事务传播行为特征这个先按下不表

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE01caf24edb8836cfd676a098ce64c191.png)

然后我们来看看事务的状态对象，内部有是否处于开启新事物的状态的方法，获取事务是否处于已完成的方法，反正都是很基础又很实用的方法，后续我们会在案例中演示他们，现在具体就直接看下图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE73c6a53cc99a6e01ffad76be7a370807.png)

- 案例环境介绍

接着我们就来正式制作一个案例来加深我们的理解，首先我们先对我们的案例环境进行一个绍的介。首先我们的事务控制方式有三种方式，分别是编程式、XML声明式以及注解声明式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE07cf9ec7f37147740021942693f440e7.png)

接着我们来看看我们的案例要实现的功能，我们案例要实现的功能就是简单的资金转移，就是A从B转账，非常简单

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3fa89e21e4907f15b86cb5e2674d8ed0.png)

接着我们就来正式实现这个案例，这需要连接我们的数据库，因此我们首先要在数据中建立对应的数据，这里我们假设已经建立了。首先我们创建对应的domain包，往内部放入我们要将数据封装为对应对象的类，写入代码如下

```
package com.itheima.domain;

import java.io.Serializable;

public class Account implements Serializable {

    private Integer id;
    private String name;
    private Double money;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Double getMoney() {
        return money;
    }

    public void setMoney(Double money) {
        this.money = money;
    }

    @Override
    public String toString() {
        return "Account{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", money=" + money +
                '}';
    }
}

```

然后创建对应的dao层数据层的包，注意，dao包其实就相当于是mapper包，知道这个知识的主要作用就是可以去看别人的讲解的时候知道他说的mapper包是个什么玩意，我们dao包内写入对应的入账和出账方法，并利用注解传入对应的数据

```
package com.itheima.dao;

import com.itheima.domain.Account;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Update;

import java.util.List;

public interface AccountDao {
    /**
     * 入账操作
     * @param name      入账用户名
     * @param money     入账金额
     */
    void inMoney(@Param("name") String name, @Param("money") Double money);

    /**
     * 出账操作
     * @param name      出账用户名
     * @param money     出账金额
     */
    void outMoney(@Param("name") String name, @Param("money") Double money);

}
```

接着我们定义service层的接口，并写入转账的方法

```
package com.itheima.service;

public interface AccountService {

    /**
     * 转账操作
     * @param outName   出账用户名
     * @param inName    入账用户名
     * @param money     转账金额
     */
    public void transfer(String outName,String inName,Double money);
}
```

然后我们写入对应的实现类，该实现类内有accountDao对象，并提供了对应的setAccountDao方法，内部的转账方法的作用的同时调用一个人的出账的另一个人的入账来实现我们的目标

```
public class AccountServiceImpl implements AccountService {

    private AccountDao accountDao;
    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }
    
    public void transfer(String outName, String inName, Double money) {
        accountDao.inMoney(outName,money);
        //int i = 1/0;
        accountDao.outMoney(inName,money);
    }
}
```

然后我们写入对应的配置文件如下，我们这里首先引入了对应的命名空间，然后我们引入了对应的加载文件的驱动，接着对对应的连接类进行了一个注入

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <context:property-placeholder location="classpath:*.properties"/>

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <!--<property name="dataSource" ref="dataSource"/>-->
    </bean>

    <bean class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="typeAliasesPackage" value="com.itheima.domain"/>
    </bean>

    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.itheima.dao"/>
    </bean>

</beans>
```

然后利用配置给我们的数据类配置对应的标签令其加载到容器中并给予其唯一标识便于后面使用，后面两个bean标签是连接和映射所需要的内容，这里就不多提了，这个懂的都懂

然后是我们jdbc的代码

```
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://175.178.114.158:3306/spring_db
jdbc.username=root
jdbc.password=itheima
```

最后是我们的具体用于查询的语句的代码，这里我们要注意的是，我们的配置文件的名字一定要是对应的dao包下的类的全名加.xml，而且创建的包的文件夹数量和关系也要和mian中的dao包一致，我们想要命名的话，在resources文件夹中可以用目录/目录/wenjian.xml的形式来创建，其会自动创建对应的目录并生成我们想要的文件，且/还会自动变成.，注意我们这里不能直接用.的形式来代表文件夹的命名，否则的话，其只是生成一个文件夹，只是其名字多了.而已。想必最开始我就是因为这个问题导致我总是出现绑定问题

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.AccountDao">

    <update id="inMoney">
        update account set money = money + #{money} where name = #{name}
    </update>

    <update id="outMoney">
        update account set money = money - #{money} where name = #{name}
    </update>

</mapper>
```

最后我们可以构造一个App类，写入其测试代码如下

```
package com.itheima;

import com.itheima.domain.Account;
import com.itheima.service.AccountService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.transaction.PlatformTransactionManager;

public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        AccountService accountService = (AccountService) ctx.getBean("accountService");
        accountService.transfer("Jock1","Jock2",100D);
    }
}

```

我们运行这个测试代码，我们可以发现这个测试代码是可以运行的，是没有问题的，实际我们的数据也确实发生了改变。但是我们这个程序现在存在的最大的一个问题就是我们这里没有开启事务，如果我们的转账过程中出现了异常，那么我们的数据仍然会发生改变

- 编程式事务

那么接着我们就要实现我们的事务，首先我们要开启事务，开启事务我们需要使用事务管理器PlatformTransactionManager，其具体的实现类取决于我们要正在使用什么框架进行事务管理，我们这里使用的是Mybatis框架，因此我们要使用DataSourceTransactionManager的实现类，该实现类就是专门用于实现Mybatis的。这里开启事务需要将我们的数据源传给我们的实现类，我们传入数据源有两种方式，第一种方式是通过构造方法传入数据源，第二种是通过其实现类的set方法传入数据源，由于我们这里定义的对象是父类对象，其没有设置方法，因此我们这里只能使用构造方法传入数据源。

```
private DataSource dataSource;
public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
}

public void transfer(String outName, String inName, Double money) {
    //开启事务
    PlatformTransactionManager ptm = new DataSourceTransactionManager(dataSource);
    //事务定义
    TransactionDefinition td = new DefaultTransactionDefinition();
    //事务状态
    TransactionStatus ts = ptm.getTransaction(td);

    accountDao.inMoney(outName,money);
    //int i = 1/0;
    accountDao.outMoney(inName,money);

    //提交事务
    ptm.commit(ts);
}
```

传入数据源之后我们要进行事务的定义，事务的定义可以自己定义，也可以使用默认值，所谓事务定义就是指的是事务最开始的隔离级别，超时时间一类的表示规则的设置。得到了事务定义之后，我们通过事务管理器对象ptm中的getTransaction方法，将td传入，然后我们可以返回一个事务状态的对象，该事务状态里各种状态的表示就是按照我们最开始的事务定义的表示来的，同时其具体的状态内容取决于我们数据库中的实际情况。然后我们再执行对应的修改操作，执行完成之后再进行提交事务的操作，提交事务需要调用ptm的commit方法，传入ts事务状态对象就可以成功提交了

当然，不要忘记传入了数据源之后，要在对应的配置文件中给对应标签下表示的类中的数据源对象也就是dataSource进行一个注入的动作，否则会报错

然后我们只要将15行的异常打开，再执行修改动作，我们就会发现我们的数据没有发生改动，此时我们的事务操作就成功了

- AOP改造编程式事务

现在我们的事务还有一个问题，那就是如果我们要以后还有写入新的事务操作，那我们又要复制黏贴，突出一个麻烦低效率，所以我们要使用我们的AOP来改造我们的编程式事务。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEba6e3e8674a351c217fdc0d62d9fe525.png)

首先我们分析我们的原来的程序，我们容易知道，我们无论是执行什么修改事务，开头总是要开启事务，定义事务和获取事务状态的，最后我们总是要进行提交事务，因此我们可以将这一部分的代码都抽取出来做成一个通知，通知的类型当然是采取round环绕通知比较好

然后我们可以创建一个新的通知类，写入其代码如下

```
package com.itheima.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import javax.sql.DataSource;

public class TxAdvice {

    private DataSource dataSource;
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    //开启事务
    public Object transactionManager(ProceedingJoinPoint pjp) throws Throwable {
        //开启事务
        PlatformTransactionManager ptm = new DataSourceTransactionManager(dataSource);
        //事务定义
        TransactionDefinition td = new DefaultTransactionDefinition();
        //事务状态
        TransactionStatus ts = ptm.getTransaction(td);

        Object ret = pjp.proceed(pjp.getArgs());

        //提交事务
        ptm.commit(ts);

        return ret;
    }
}

```

这份代码值得一提的是第28行，我们这里调用pjp.proceed()的同时还往里传入了pjp.getArgs()的参数，实际上这个参数即使不传入也可以，我们最后得到的对象仍然是可以拿到我们原来传入对象的所有参数的，只是这里我们主动传入是一种比较标准的做法，因此我们这么做。还有就是因为我们开启事务还需要数据源对象，因此这里同样将数据源部分的的代码也抽取出来

创建了对应的类之后，不要忘了还要进行对应的配置

```
<bean id="txAdvice" class="com.itheima.aop.TxAdvice">
    <property name="dataSource" ref="dataSource"/>
</bean>

<aop:config>
    <aop:pointcut id="pt" expression="execution(* *..transfer(..))"/>
    <aop:aspect ref="txAdvice">
        <aop:around method="transactionManager" pointcut-ref="pt"/>
    </aop:aspect>
</aop:config>

```

我们的配置里首先对新创建类中的数据源进行了注入，然后我们进行我们的通知类的配置，首先我们配置我们的切点，我们给其唯一标识为pt，然后其所有的切点是任意路径下的具有transfer关键字的方法，接着我们开始配置切面，切面内我们首先引入我们的通知，即是前面配置好的txAdvice，然后我们正式配置配置我们的通知的注入位置，我们这里采取的是环绕通知，要添加的方法就是通知类中的transactionManager方法，要添加通知的位置就是我们之前配置过的pt切点位置

最后我们经过测试会发现我们的事务是成功了的，那么这时我们的AOP重写案例就做好了，此时我们无论写入几个事务，都可以正确运行，当然，这里的前提是，我们的命名是符合规范的，具有transfer关键字的，当然随着业务需求的变动，我们的定位切点的查询语句也可以做相应的改动

- 声明式事务（XML格式）（TX命名空间管理事务）

接着我们要思考一件事情，那就是我们构造的AOP通知是否具有普适性？我们其他构造新的事务的时候，还需要对我们原来的代码做修改吗？我们首先来分析我们原来的通知代码，容易知道每一个事务肯定都需要这些代码的，因此其具有普适性，而在对应的位置上的配置怎么解决呢？我们可以做一个jar包，这样以后我们需要使用就直接导入对应的jar包就完了，因此我们的代码是具有普适性的0

而spring早就知道这一点了，因此其提供了更加便利的实现，该实现就是我们本节要学习的内容。spring提供的这个实现可以让我们的通知代码给省略掉，就是TX命名空间，本节我们要实现的内容就是通过TX命名空间来将我们的通知代码进行一个实现。

首先我们要在对应的配置文件上先引入TX命名空间，然后我们创建定义事务管理的通知类，这里我们使用tx命名空间来创建，其会需要我们传入一个具体的事务管理器的实现对象，因此我们要创建对应的事务管理器的实现对象，我们用一个bean标签来进行创建，我们创建的对象的路径是什么完全取决是我们创建的实现类的是什么，也就是我们当前框架下需要使用什么实现类，接着往该对象内部进行一个数据源对象的注入，然后我们的事务管理对象就创建完了，我们取名为txManager，然后将其传入。

```
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!--定义事务管理的通知类-->
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="transfer" read-only="false"/>
    </tx:attributes>
</tx:advice>

<aop:config>
    <aop:pointcut id="pt" expression="execution(* *..transfer(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/>
</aop:config>
```

然后我们要在下面再调用tx:attributes标签，往内部指定我们要往内部植入通知的切点方法，这个标签下还有许多属性可以调用，这里我们先按下不表。有的同学可能会问我们下面的切点配置里不是已经指定了对应的要植入通知的方法了吗？为何这里又要多此一举呢？第一点来说这是tx的设计规则，另一点来说之所以这样做是有理由的，现在先按下不表。反正先记住要多指定一次就完了，因此我们这里指定我们要植入通知的方法为transfer

同时相信有细心的同学注意到我们这里的配置对应的通知的aop标签中并没有指定切点类的方法，这是因为spring早就知道你们事务都只是创建，获取，提交，就这一回事，什么事务都一样，因此其内部只有这一个方法可以用，所以也不需要去指定什么方法

接着经过测试我们会发现我们的这个方法是可行的，可用的。那么此时我们就将最开始的通知类的代码也给省略了，我们由TX命名空间帮我们配置好了我们的构造通知的代码

但是实际上我们这样构造我们的TX命名空间的代码是不规范的，实际规范的命名方式应该如下所示

```
<!--定义事务管理的通知类-->
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="*" read-only="false"/>
        <tx:method name="get*" read-only="true"/>
        <tx:method name="find*" read-only="true"/>
        <!--<tx:method name="transfer" read-only="false"/>-->
    </tx:attributes>
</tx:advice>

<aop:config>
    <aop:pointcut id="pt" expression="execution(* com.itheima.service.*Service.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/>
</aop:config>
```

我们可以看到我们这里先对命名空间指定了对应的要植入通知的方法，首先是所有不是只读的方法要添加事务，其次是所有只读的方法但是是以get或者是以find开头的方法进行事务管理。然后我们要对我们的要搜索对应的接口的位置进行一个修改，因为如果我们还是跟之前一样的简单粗暴地搜索所有的话，那么其会将所有符合的方法都添加事务，这样就太拖慢我们的效率了，因此我们这里对我们的位置进行一个指定，可以看到我们这里指定了的是返回值任意的，在com.itheima.service包下的所有以Service的接口类，其下的任意方法都需要扫描。这样才是一个符合企业开发的一种命名规范，这样也能够解释我们为什么需要一个新的位置来指定我们的切点，因为此时我们的扫描路径的方法只会限定范围，而不会自动指定好我们的切点。

接着我们来讲下aop:advice与aop:advisor的区别

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe5f07adc1f1a845b59352eefc4166013.png)

这两者最简单的区别就是后者必须要指定接口或者其接口的实现类，而前者不用。了解下就好了

然后我们来看看tx:advice的标签的总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1e8fe7bf35983fe73a3d006985a05b13.png)

然后是tx:attributes标签

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe477dcaf77e43a7be05e1f639e950ac0.png)

最后是tx:method标签

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE207c5358f68c1f48ab3df0e313461cbe.png)

- tx:method属性详解

之前我们说过该标签下的属性很多，那么本节我们就要来对其进行一个逐一的讲解。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE965da70dc52c74fc6ed384eabdb3cbcf.png)

其实也没什么特别好讲的，具体的内容自己看上面的图吧，事务传播行为我们下一节会具体讲

- 事务传播行为

本节我们来讲述事务传播行为，讲述事务传播行为之前我们要先讲两个内容，分别是事务管理员和事务协调员，当在一个存在事务的方法内调用另外一个存在事务的方法里时，调用另一个存在事务的方法的事务叫做事务管理员，而被调用的方法的事务称为事务协调员。

所谓事务传播行为描述的是事务协调员对事务管理员所携带的事务的处理态度

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE41218ff327dd03295b3f192827ac67ad.png)

那么什么是事务协调员对事务管理员的态度有什么呢？分别有REQUIRED、REQUIRES_NEW、SUPPORTS、NOT_SUPPORTED等。具体有什么不同，就直接看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE71fd08de41048ae3c2c269f2bb6c0ff9.png)

这里我们就不演示了，我们接下来看看我们这些的事务传播对象的具体应用场景吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE81505f6bbb58123cd1785a3c862b3396.png)

- 声明式事务（注解）

接着我们要使用注解来实现我们的案例，首先我们要使用@Transactional注解来实现我们的指定类的范围的查询，以及将其对应的接口或者是实现类传给事务管理器的动作。其实一般来说，这个注解下可以给其指定的属性，比如是否只读，超时时间，隔离级别等，同时我们的名字就不再需要了，这是因为我们启用了注解之后其会自动将其下的方法进行绑定，不需要通过名字来特别绑定。这里值得一提的是，我们一般是不会将该注解直接绑定到对应的实现类中的，因为这样绑定的范围太小，以后方法一换又要绑定一次，突出一个麻烦。一般是绑定到接口的抽象方法中，这样实现该接口的所有方法都是会被绑定到。我们也可以将其绑定到接口中，这样该接口下的所有方法都会进行绑定，我们可以再其下具体再进行绑定，设置不同的属性，这样新设置的属性就会覆盖之前设置的属性，这个有点类似于全局变量和局部变量的区别，非常好理解，这里就不多提了。

来看看对应的注解类的配置的写法，如果并不想进行具体的设置，那么是需要在指定的接口上加入@Transactional就可以实现绑定了

```
@Transactional(
        readOnly = false,
        timeout = -1,
        isolation = Isolation.DEFAULT,
        rollbackFor = {}, //java.lang.ArithmeticException.class, IOException.class
        noRollbackFor = {},
        propagation = Propagation.REQUIRED
)
```

最后不要忘了在配置文件定义出我们的事务管理器，同样要求自己创建并传入一个具体的实现类对象，然后才能创建出我们所需要的事务管理器。这里要注意的是，该标签同时还兼具开启事务注解驱动的作用。

```
<tx:annotation-driven transaction-manager="txManager"/>
```

最后我们来看看本节的总结，首先是@Transactional注解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE46d677f8d53425ea03c96b24df5e2c26.png)

然后是tx:annotation-driven

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9761fc3b83f7f8b1b5e81868ec2f570b.png)

- 声明式事务（注解驱动）

接着我们来学习我们的最后一个内容，也就是经典的纯注解开发。首先我们要对我们的dao层的代码进行改变，将我们原来用xml来完成的查询的语句采用注解的形式来进行实现，那么我们可以写入其代码如下

```
package com.itheima.dao;

import com.itheima.domain.Account;
import org.apache.ibatis.annotations.*;
import org.mybatis.spring.SqlSessionFactoryBean;

import java.util.List;

public interface AccountDao {

    @Update("update account set money = money + #{money} where name = #{name}")
    void inMoney(@Param("name") String name, @Param("money") Double money);

    @Update("update account set money = money - #{money} where name = #{name}")
    void outMoney(@Param("name") String name, @Param("money") Double money);

}
```

然后我们对MyBatis进行相应的注释的代码配置，第一个注释用于指定我们得到的数据要封装的对象以及获取数据连接，需要传入数据源对象。第二个注释用于获得映射对象，指定对应的包我们的程序就能执行对应的语句并获得结果。这两个内容都是在之前讲过的，忘了的可以去复习

```
package com.itheima.config;

import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.mapper.MapperScannerConfigurer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;

import javax.sql.DataSource;

public class MyBatisConfig {

    @Bean
    public SqlSessionFactoryBean getSqlSessionFactoryBean(@Autowired DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage("com.itheima.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer getMapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.itheima.dao");
        return msc;
    }
}
```

然后我们配置我们的主注解配置文件，主配置文件中引入了配置文件的固定开头，以及我们的扫描路径，然后是我们的配置文件，最后传入了另外两个副注解配置文件到主注解配置文件中

```
package com.itheima.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.PropertySource;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@ComponentScan("com.itheima")
@PropertySource("classpath:jdbc.properties")
@Import({JDBCConfig.class,MyBatisConfig.class})
@EnableTransactionManagement
public class SpringConfig {
}

```

最后我们的@EnableTransactionManagement，该注解其实就相当于我们在配置文件中设置的开启注解驱动的代码，但是在开启注解驱动的代码里还要传入一个数据源对象，那我们应该怎么办呢？我们这里直接将我们的数据源对象注入到我们的spring容器中就可以了，我们可以将这个注入动作放到我们的jdbc的配置文件中

```
package com.itheima.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

public class JDBCConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String userName;
    @Value("${jdbc.password}")
    private String password;

    @Bean("dataSource")
    public DataSource getDataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }

    @Bean
    public PlatformTransactionManager getTransactionManager(DataSource dataSource){
        return new DataSourceTransactionManager(dataSource);
    }


}

```

然后我们在数据层中加入对应的注解令其能够加入到spring容器中，以及令其对应的属性可以自动匹配到放到spring容器中的对象。不过这里奇怪的一点是，我们明明没有在AccountDao接口中加入任何的注入相关的注解，但是却没有报错，就很怪，实际加入了也是能够正确运行的，说明可能其自动加入了。这个问题先按下不表，以后可以回来再想想这个问题。这个问题的答案就是这个对应的类是会被动态生成的，其已经先进行了配置了，即使不使用加入到容器中的注解也能够正确运行的原因是因为他一开始就会被用于动态生成新的类然后把那个类放到容器那了。其都使用了映射配置的代码，在注解驱动中是下面这行代码起的作用，而在配置文件开发中则是利用对应的配置标签启动的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2798b1f0ff01228fec3f7d54ba7ae1b3.png)

```
package com.itheima.service.impl;


import com.itheima.dao.AccountDao;
import com.itheima.service.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;

    public void transfer(String outName, String inName, Double money) {
        accountDao.inMoney(outName,money);
        //int i = 1/0;
        accountDao.outMoney(inName,money);
    }
}
```

然后我们在对应的接口中加入@Transactional，加入该注解可以让我们的实现该接口的方法都开启默认配置的事务

```
package com.itheima.service;

import com.itheima.domain.Account;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
public interface AccountService {
    @Transactional
    public void transfer(String outName, String inName, Double money);

}

```

最后我们在对应的测试类中设置专用的类加载器，然后设定spring对应上下文的配置

```
package com.itheima.service;

import com.itheima.config.SpringConfig;
import com.itheima.domain.Account;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

//设定spring专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
//设定加载的spring上下文对应的配置
@ContextConfiguration(classes = SpringConfig.class)
public class UserServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testTransfer(){
        accountService.transfer("Jock1","Jock2",100D);
    }
}
```

然后我们经过测试会发现这个的确是可行，此时说明我们的案例就已经完成了。