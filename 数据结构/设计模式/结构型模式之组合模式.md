现在我们来学习组合模式，先来看看概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc2ad0e45bbf881510b300706967c3b0e.png)

对于这种结构的叙述，我们就不赘述了，自己看图吧，这种结构我们属于是见得太多了，我们需要知道的是，如果要让客户在使用这种结构时可以不用区分容器对象和叶子对象，此时就需要使用到我们的组合模式

现在我们来看看组合模式的定义和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd88e0ed8a61f0170b62a4a54bb408f46.png)

抽象根结点要抽象出各个层次的共有方法和属性，比如说我们的容器对象和叶子对象，其都有共有的行为，我们可以将其抽象出来

接着我们来通过讲解一个案例来加深我们对组合模式的理解，先来看看我们的案例目标

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6fa6df156ced90259f9da42c3f5c8de3.png)

然后我们来看看其类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0fbb6c72edc8d8f53e65265d41b7b074.png)

那么根据类图，我们首先创建抽象根结点的菜单组件类，这里我们的方法都抛出异常的原因是菜单组件只是一个抽象的类，其内部抽象的容器结点和叶子结点的共同特征，实际并不存在啥子菜单的玩意，只有名称和层级作为标识而已，因此内部的方法我们全部令其抛出异常，最后我们再定义一个打印菜单名称的抽象方法让子类实现

之所以最后一个打印方法是抽象方法而其他的不是，是因为我们的共同类中的子类其添加和移除的方法是可有可无的，不实现的类说明其本身就不支持做这个功能，此时我们抛出异常是没有问题的，最后我们设置打印方法为抽象方法，这就意味着所有继承该类的子类都必须独立实现打印方法，这个方法是我们的所有的子类都必须提供的操作，是我们自己所规定的，事实上，这个操作的提供也是必要的，因为我们的目标就是打印菜单中的所有层级

```
//菜单组件：抽象根结点
public abstract class MenuComponent {
    //菜单组件的名称
    protected String name;
    //菜单组件的层级
    protected int level;

    //添加子菜单
    public void add(MenuComponent menuComponent){
        throw new UnsupportedOperationException();
    }

    //移除子菜单
    public void remove(MenuComponent menuComponent){
        throw new UnsupportedOperationException();
    }

    //获取指定的子菜单
    public MenuComponent getChild(int index){
        throw new UnsupportedOperationException();
    }

    //获取菜单或者菜单项的名称
    public String getName() {
        return name;
    }

    //打印菜单名称(包含子菜单和子菜单项)
    public abstract void print();
}

```

然后我们定义具体的菜单类，菜单类当然要继承共同抽象类，提供对应的构造方法，菜单类之所以聚合抽象菜单类集合，是因为一个菜单总是可以保存多个菜单的，这里之所以使用抽象菜单类而非具体的菜单类，是为了让我们的菜单类的存放变得更加灵活

然后我们重写其对应的添加和移除的方法，直接调用集合中对应的方法即可，重点在于我们的打印方法，我们的打印方法是打印当前的名字，并且循环打印子菜单的名字，打印直接调用子菜单的打印方法即可，参考递归

```
//菜单类：树枝结点
public class Menu extends MenuComponent{

    //菜单可以有多个子菜单或者子菜单项
    private List<MenuComponent> menuComponentList = new ArrayList<>();

    public Menu(String name,int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void add(MenuComponent menuComponent) {
        menuComponentList.add(menuComponent);
    }

    @Override
    public void remove(MenuComponent menuComponent) {
        menuComponentList.remove(menuComponent);
    }

    @Override
    public MenuComponent getChild(int index) {
        return menuComponentList.get(index);
    }

    @Override
    public void print() {
        //打印菜单名称
        for (int i = 0; i < level; i++) {
            System.out.print("--");
        }
        System.out.println(name);

        //打印子菜单或者子菜单项名称
        for (MenuComponent menuComponent : menuComponentList) {
            menuComponent.print();
        }
    }
}
```

最后我们要定义的叶子结点的类，同样要继承共同的抽象类，这里就不用注入菜单属性了，因为叶子结点对象显然不能再拥有子菜单了，我们这里只需要提供该对象的名字和层级的构造方法以及实现其必须实现的打印方法即可

```
//叶子结点
public class MenuItem extends MenuComponent{

    public MenuItem(String name,int level){
        this.name = name;
        this.level = level;
    }

    @Override
    public void print() {
        for (int i = 0; i < level; i++) {
            System.out.print("--");
        }
        //打印菜单项的名称
        System.out.println(name);
    }
}

```

最后我们在测试类中写入如下代码即可得到我们想要的结果，前面一大段代码都是在设置对应的结构，最后一行打印代码执行了我们的目标操作

```
public class Client {
    public static void main(String[] args) {
        //创建菜单树
        MenuComponent menu1 = new Menu("菜单管理",2);
        menu1.add(new MenuItem("页面访问",3));
        menu1.add(new MenuItem("展开菜单",3));
        menu1.add(new MenuItem("编辑菜单",3));
        menu1.add(new MenuItem("删除菜单",3));
        menu1.add(new MenuItem("新增菜单",3));
        MenuComponent menu2 = new Menu("权限管理",2);
        menu2.add(new MenuItem("页面访问",3));
        menu2.add(new MenuItem("提交保存",3));
        MenuComponent menu3 = new Menu("角色管理",2);
        menu3.add(new MenuItem("页面访问",3));
        menu3.add(new MenuItem("新增角色",3));
        menu3.add(new MenuItem("修改角色",3));

        //创建一级菜单
        MenuComponent component = new Menu("系统管理",1);
        //将二级菜单添加到一级菜单中
        component.add(menu1);
        component.add(menu2);
        component.add(menu3);

        //打印菜单名称
        component.print();
    }
}

```

- 组合模式的分类

接着我们来看看组合模式的分类，我们上面使用的组合模式是透明组合模式，实际上还有安全组合模式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE94538d3f29980082ded33a12af175593.png)

最后我们来看看其优点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE25f953fd1940324fb8d732f949dff8b2.png)

