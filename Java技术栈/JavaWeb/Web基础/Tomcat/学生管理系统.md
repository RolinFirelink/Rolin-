那么学习了上面这么多内容之后，我们现在先来一个小试牛刀，先做一个学生管理系统的一小部分，后续我们会将我们的系统的内容不断进行补充，这里面当然也会不断地学习新知识，当我们的学生管理系统做完了，我们的知识也就学完了

那么先来看看我们的案例效果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE36128d86d6030eaddeae16f923495120.png)

可以看到我们要实现的功能很简单，首先是一个简单的数据输入页面，用户可以在页面里输入对应的数据，然后将数据传到java服务器，并通过IO流的形式传到硬盘中保存起来，并且，当我们的请求成功被响应的时候，会在我们的页面上返回一个成功保存的页面信息

那么现在我们来正式实现我们的案例效果，我们先来看看我们的实现步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbf82c5902e2e381aa98c21ba87534e6d.png)

首先我们要创造保存学生信息的html文件，那么我们可以创造其代码如下

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>保存学生信息</title>
</head>
<body>
    <!--提前通过Run Edit设置其虚拟目录为stu，此处先写入虚拟目录，然后写入构造的类，就可以将数据传入到指定的类-->
    <form action="/stu/studentServlet" method="get" autocomplete="off">
        学生姓名：<input type="text" name="username"> <br/>
        学生年龄：<input type="number" name="age"> <br/>
        学生成绩：<input type="number" name="score"> <br/>
        <button type="submit">保存</button>
    </form>
</body>
</html>
```

接着我们配置web.xml下配置对应的信息

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--修改默认主页-->
    <welcome-file-list>
        <welcome-file>/addStudent.html</welcome-file>
    </welcome-file-list>

    <!--配置Servlet-->
    <servlet>
        <servlet-name>studentServlet</servlet-name>
        <servlet-class>com.itheima.servlet.StudentServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>studentServlet</servlet-name>
        <url-pattern>/studentServlet</url-pattern>
    </servlet-mapping>
</web-app>
```

最后我们在对应的类中写入代码，令其能够将数据写入到硬盘中并返回给我们的页面一个响应 ，我们可以构造代码如下

```
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

/*
    基于注解方式开发Servlet
 */
public class StudentServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取表单数据并保存到文件中，由于传入的数据其实就是一个请求，因此数据都保存在请求中，也就是req的对象中，我们只要调用其对应的方法就可以获得我们的所需要的数据了
        String username = req.getParameter("username");
        String age = req.getParameter("age");
        String score = req.getParameter("score");

        //采用字符输出流的方式将数据写入到文件中
        BufferedWriter bw = new BufferedWriter(new FileWriter("/d:\\stu.txt",true));
        bw.write(username+","+age+","+score);
        bw.newLine();
        bw.close();

        //响应客户端浏览器，如果我们采用自己创造一个字符输入流的的方式的话又需要额外创建一个新的文件，比较麻烦。这里直接通过响应方法获得一个打印流，直接在页面上打印我们想要打印的字符
        PrintWriter pw = resp.getWriter();
        pw.println("Save Success~");
        pw.close();
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

```

具体实现的代码的解释，我们直接以注释的方式添加到代码里了。最后我们通过测试会发现，这个程序没有任何问题。那么我们学生管理系统的第一部分就算是实现完了

----------------------------------------------------------------------------------------------------------------------------------------

到了这里，说明我们已经学习完了请求和响应了，那么接着我们继续来实现我们的学生管理系统

我们先来看看案例效果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE96b9ca195bb71afd96d12fc970ce83dd.png)

我们的案例效果是上面这样的，首先我们的首页就是两个简单的超链接，然后当我们点击添加学生时，会进入到添加学生的界面，当我们添加完毕后会显示添加成功并返回首页，我们可以点击查看学生，其会显示对应的数据到界面上。由于我们目前还没有学习过将数据直接添加到Html中显示，因此我们这里的数据显示的方法是直接读取数据内容然后显示出来的

那么确定了上面的内容之后，我们接下来来分步实现我们的学生管理系统，请看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbbf6ca7019a9b17b99b8465a709fc06e.png)

我们首先要创建一个首页的HTML文件，我们可以将其创建如下

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>学生管理系统首页</title>
</head>
<body>
    <a href="/stu/addStudent.html">添加学生</a>
    <a href="/stu/listStudentServlet.html">查看学生</a>
</body>
</html>
```

然后我们创建添加学生的页面，其代码如下

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>添加学生</title>
</head>
<body>
    <!--提前通过Run Edit设置其虚拟目录为stu，此处先写入虚拟目录，然后写入构造的类，就可以将数据传入到指定的类-->
    <form action="/stu/addStudentServlet" method="get" autocomplete="off">
        学生姓名：<input type="text" name="username"> <br/>
        学生年龄：<input type="number" name="age"> <br/>
        学生成绩：<input type="number" name="score"><br/>
        <button type="submit">保存</button>
    </form>
</body>
</html>
```

然后我们还要创建我们的学生类，给其提供对应的方法，其代码如下

```
package com.itheima.servlet.bean;

import java.util.Arrays;

public class Student {
    private String username;
    private int age;
    private int score;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public Student() {
    }

    public Student(String username, int age, int score) {
        this.username = username;
        this.age = age;
        this.score = score;
    }
}

```

那么上面我们就实现了最基本的首页的界面，接下来我们来实现添加的功能，先来看我们的实现步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE75ce11f4779fc3b95567798884ab0dc5.png)

那么我们按照步骤，先创建AddStudentServlet类，然后可以写入代码如下

```
/*
    实现添加功能
 */
@WebServlet("/addStudentServlet")
public class AddStudentServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.获取表单中的数据
        Map<String, String[]> map = req.getParameterMap();

        //封装学生对象
        Student stu = new Student();
        try {
            BeanUtils.populate(stu,map);
        } catch (Exception e) {
            e.printStackTrace();
        }

        //3.将学生对象的数据保存到d:\\stu.txt文件中
        BufferedWriter bw = new BufferedWriter(new FileWriter("d:\\stu.txt",true));
        bw.write(stu.getUsername()+","+stu.getAge()+","+stu.getScore());
        bw.newLine();
        bw.close();

        //4.通过定时刷新功能响应给浏览器
        resp.setContentType("text/html;charset=UTF-8");
        resp.getWriter().write("添加成功，2秒后自动跳转到首页");
        resp.setHeader("Refresh","2;URL=/stu/index.html");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

我还就那个调用我牛逼的工具类，直接起飞。

那么最后我们来实现我们的查找功能，由于我们还没有学到如何将文件中的数据以HTML界面的形式展示出来，因此我们这里采取展示数据的方案就是恩读取恩访问，请看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcc87d270bb518b47181aaaedb816796e.png)

那么我们创建ListStudentServlet类，并写入代码如下

```
package com.itheima.servlet.Servlet;

import com.itheima.servlet.bean.Student;
import org.apache.commons.beanutils.BeanUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/*
    实现查看功能
 */
@WebServlet("/listStudentServlet")
public class ListStudentServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.创建字符输入流对象，关联读取的文件
        BufferedReader br = new BufferedReader(new FileReader("d:\\stu.txt"));

        //2.创建集合对象，用于保存Student对象
        ArrayList<Student> list = new ArrayList<>();

        //3.循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中
        String line;
        while ((line = br.readLine()) != null){
            //张三,23,95
            Student stu = new Student();
            String[] arr = line.split(",");
            stu.setUsername(arr[0]);
            stu.setAge(Integer.parseInt(arr[1]));
            stu.setScore(Integer.parseInt(arr[2]));
            list.add(stu);
        }

        //4.遍历集合，将数据响应给浏览器
        resp.setContentType("text/html;charset=UTF-8");
        //获取输出流对象
        PrintWriter pw = resp.getWriter();
        for (Student s: list) {
            pw.write(s.getUsername() + "," + s.getAge() + "," + s.getScore());
            pw.write("<br>");
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

那么到此为止，我们学生管理系统的第二个部分就实现完毕了。

————————————————————————————————————————————————————————————————————

学习到这里，我们就到了第三阶段了，此时我们已经学习完了Cookie、Session以及JSP，接着我们就要利用这些技术来完成第三部分的案例

同样的我们现在看看我们的案例效果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe957ca1ed45cd4c7a957b43f884bf2c8.png)

首先我们的浏览器要能够判断是否有用户登录，如果有的话就显示添加或者查看学生的界面，如果没有就显示请登录的界面。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE093b60044a1fb643484235b770184bfc.png)

之后添加和查看学生的效果和我们第二部分做的差不多，不过这次我们查看学生就要显示出一个HTML的界面了，而不是恩读嗯写入了

那么了解了案例内容之后，我们先来实现我们的登录功能，这也是本篇最有含金量的部分。先来看实现步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaf5fd44d4c48aaa042b90ba412bda815.png)

那么根据步骤我可以先写入我们的首页的JSP代码如下

```
<%--
    1.page指令
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>学生管理系统首页</title>
  </head>
  <body>
        <%--
            获取会话域中的数据
            如果获取到了则显示添加和查看功能的超链接
            反之则显示登录功能的超链接
        --%>
        <% Object username = session.getAttribute("username");
            if(username==null){
        %>
            <a href="/stu/login.jsp">请登录</a>
        <%} else {%>
            <a href="/stu/addStudent.jsp">添加学生</a>
            <a href="/stu/listStudentServlet">查看学生</a>
        <%}%>
  </body>
</html>

```

继续根据步骤我们可以实现登录页面的JSP代码如下

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>学生登录</title>
</head>
<body>
    <form action="/stu/loginStudentServlet" method="get" autocomplete="off">
        用户名：<input type="text" name="username"> <br>
        密码：<input type="password" name="password"> <br>
        <button type="submit">登录</button>
    </form>
</body>
</html>
```

然后我们可以实现学生登录之后服务器中内部执行的功能类的代码如下

```
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/*
    学生登录
 */
@WebServlet("/loginStudentServlet")
public class LoginStudentServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.获取用户名和密码
        String username = req.getParameter("username");
        String password = req.getParameter("password");

        //2.判断用户名
        if(username == null || "".equals(username)){
            //2.1用户名为空 重定向到登录页面
            resp.sendRedirect("/stu/login.jsp");
            return;
        }

        //2.2用户名不为空 将用户名存储会话域中
        req.getSession().setAttribute("username",username);

        //3.重定向到首页index.jsp
        resp.sendRedirect("/stu/index.jsp");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

```

这里我们要搞懂其内部机制，首先我们的index.jsp查看我们的对话域中有无用户名，无则跳转到登录页面，然后我们点击登录，重定向到实现登录功能的JSP，然后里面完成登录功能之后内部服务器进行了处理并将内容上传到了对话域中，然后重新跳转到index.jsp，此时对话域中的用户名不为空，此时跳转到我们的添加和查找页面

接着我们来实现添加功能，来看看步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE99024b93eecaa5ce80be1b9d6a7ee3d6.png)

这里的代码其实和我们第二个案例的一模一样，我就不贴了

最后我们来实现查看功能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE06a381bf6d6933de718f680ca221ff2a.png)

这里我们只放两个代码，因为其他的只要直接拿第二个部分的代码就可以了，首先是实现查看功能的代码

```
package com.itheima.servlet;

import com.itheima.bean.Student;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/*
    实现查看功能
 */
@WebServlet("/listStudentServlet")
public class ListStudentServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.创建字符输入流对象，关联读取的文件
        BufferedReader br = new BufferedReader(new FileReader("d:\\stu.txt"));

        //2.创建集合对象，用于保存Student对象
        ArrayList<Student> list = new ArrayList<>();

        //3.循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中
        String line;
        while ((line = br.readLine()) != null){
            //张三,23,95
            Student stu = new Student();
            String[] arr = line.split(",");
            stu.setUsername(arr[0]);
            stu.setAge(Integer.parseInt(arr[1]));
            stu.setScore(Integer.parseInt(arr[2]));
            list.add(stu);
        }

        //4.将集合对象存入到会话域中
        req.getSession().setAttribute("students",list);

        //5.重定向到学生列表页面
        resp.sendRedirect("/stu/listStudent.jsp");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

这里我们做的改动是将数据存到会话域中，然后将页面重定向到学生列表页面

```
<%@ page import="java.util.ArrayList" %>
<%@ page import="com.itheima.bean.Student" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>查看学生</title>
</head>
<body>
    <table width="600px" border="1px">
        <tr>
            <th>学生姓名</th>
            <th>学生年龄</th>
            <th>学生成绩</th>
        </tr>
        <% ArrayList<Student> students = (ArrayList<Student>) session.getAttribute("students");
            for (Student stu :students) {
        %>
        <tr>
            <td><%=stu.getUsername()%></td>
            <td><%=stu.getAge()%></td>
            <td><%=stu.getScore()%></td>
        </tr>
        <%}%>
    </table>
</body>
</html>

```

然后我们构造学生列表的jsp页面如下，这里我们的原理是获得会话域中的集合对象，然后进行遍历。这里值得注意的是，我们的遍历时，如果我们需要写入我们的代码，而又需要我们的页面显示一些相应的信息，那么在代码块的两个大括号间应该要及时且适合地加上<%%>来框住我们的代码块的大括号，在然后在这个大括号内书写我们所需要的界面代码，如果要用上某些数据，那就加上<%%>继续获取就可以了。之所以这样做是因为在<%%>中无法写上我们的界面代码，所以我们采取这种方式，虽然有点麻烦，但是它的确有效

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

那么现在终于到了我们的最后一个案例了，也就是我们最后一个部分的实现，当我们到达这里的时候，我们已经学习完了EL表达式、JSTL、Filter以及Listener的内容，那么接下来我们就用这些新学习的知识来实现我们的案例。不过我们这一次，我们要做的事情是在我们的原来的案例上进行再优化，我们首先来分析下我们的最开始实现的案例有什么问题

我们最开始实现的案例的问题有三个，第一个是我们手动指定了浏览器的编码格式来解决乱码问题，这个我们应该要改成用过滤器来解决要更好。其次是我们的JSP文件里有一大堆的JSP代码块，非常难看，我们可以使用EL表达式和JSTL来进行相应的优化。最后也是最严重的问题是，我们的项目即使不登录，直接在网址上输入相应的文件名，我们也可以实现查看和添加功能，这是肯定不行的，因为按理说不登录那么就不能使用这些功能，因此我们要解决这个问题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7439b1562b4008bc0697e043e17f9ab0.png)

那么现在我们先来用过滤器解决我们的乱码问题，我们创建一个filter类并写入代码如下

```
/*
    解决全局乱码问题
 */
@WebFilter("/*")
public class EncodingFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        try {
            //1.将请求和响应对象转换为HTTP协议相关的对象
            HttpServletRequest request = (HttpServletRequest) servletRequest;
            HttpServletResponse response = (HttpServletResponse) servletResponse;

            //2.设置编码格式
            request.setCharacterEncoding("UTF-8");
            response.setContentType("text/html;charset=UTF-8");

            //3.放行
            filterChain.doFilter(request,response);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    @Override
    public void destroy() {

    }
}
```

那么解决了乱码问题之后，接下来我们来实现我们的检查登录的功能，我们同样可以用过滤器来实现，我们可以新创造一个过滤器类并写入其代码如下

```
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/*
    检查登录
 */
@WebFilter(value = {"/addStudent.jsp","/listStudentServlet"})
public class LoginFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        try {
            //1.将请求和响应对象转换为HTTP协议相关的对象
            HttpServletRequest request = (HttpServletRequest) servletRequest;
            HttpServletResponse response = (HttpServletResponse) servletResponse;

            //2.获取会话域对象中数据
            Object username = request.getSession().getAttribute("username");

            //3.判断用户名
            if(username == null || "".equals(username)){
                //重定向到登录页面
                response.sendRedirect(request.getContextPath()+"/login.jsp");
                return;
            }

            //4.放行
            filterChain.doFilter(request,response);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    @Override
    public void destroy() {

    }
}

```

这里我们是通过使用过滤器查看会话域中是否有数据的方式来决定要不要令页面跳转到登录页面的形式的，这里我们希望过滤器只过滤两个关键的功能类，因此我们这里的注解配置采用了value数组的形式，并且只写入了两个功能类的地址

那么最后我们来解决最后一个问题，用EL表达式来改进我们的JSP文件，首先是我们的addStudent内的代码

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>添加学生</title>
</head>
<body>
<!--提前通过Run Edit设置其虚拟目录为stu，此处先写入虚拟目录，然后写入构造的类，就可以将数据传入到指定的类-->
    <form action="${pageContext.request.contextPath}/addStudentServlet" method="get" autocomplete="off">
        学生姓名：<input type="text" name="username"> <br/>
        学生年龄：<input type="number" name="age"> <br/>
        学生成绩：<input type="number" name="score"><br/>
        <button type="submit">保存</button>
    </form>
</body>
</html>

```

这里我们用EL表达式动态获取我们的虚拟目录，这样即使我们的虚拟目录改变了我们的代码仍然可以正确运行

接着是我们首页的jsp

```
<%--
    1.page指令
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<html>
  <head>
    <title>学生管理系统首页</title>
  </head>
  <body>
        <%--
            获取会话域中的数据
            如果获取到了则显示添加和查看功能的超链接
            反之则显示登录功能的超链接
        --%>
            <c:if test="${sessionScope.username eq null}">
                <a href="${pageContext.request.contextPath}/login.jsp">请登录</a>
            </c:if>

            <c:if test="${sessionScope.username ne null}">
                <a href="${pageContext.request.contextPath}/addStudent.jsp">添加学生</a>
                <a href="${pageContext.request.contextPath}/listStudentServlet">查看学生</a>
            </c:if>
  </body>
</html>

```

这里我们结合了JSTL和EL表达式共同构建我们的代码，最终的效果就让我们的代码看起来清爽很多

然后是查看学生的JSP

```
<%@ page import="java.util.ArrayList" %>
<%@ page import="com.itheima.bean.Student" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<html>
<head>
    <title>查看学生</title>
</head>
<body>
    <table width="600px" border="1px">
        <tr>
            <th>学生姓名</th>
            <th>学生年龄</th>
            <th>学生成绩</th>
        </tr>
        <c:forEach items="${students}" var="s">
            <tr align="center">
                <td>${s.username}</td>
                <td>${s.age}</td>
                <td>${s.score}</td>
            </tr>
        </c:forEach>
    </table>
</body>
</html>

```

我们这里使用打了forEach循环来帮助我们改造我们的代码

最后我们来改造我们登录页面的JSP

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>学生登录</title>
</head>
<body>
    <form action="${pageContext.request.contextPath}/loginStudentServlet" method="get" autocomplete="off">
        用户名：<input type="text" name="username"> <br>
        密码：<input type="password" name="password"> <br>
        <button type="submit">登录</button>
    </form>
</body>
</html>

```

其实就只是修改了一个路径获取方式，无了。

最后由于我们采用工具类添加学生的方式有问题，所以我们换回手动方式来，下面是手动封装的代码

```
package com.itheima.servlet;

import com.itheima.bean.Student;
import org.apache.commons.beanutils.BeanUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Map;

/*
    实现添加功能
 */
@WebServlet("/addStudentServlet")
public class AddStudentServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException, IOException {
        //1.获取表单中的数据
        String username = req.getParameter("username");
        String age = req.getParameter("age");
        String score = req.getParameter("score");

        //创建学生对象并赋值
        Student stu = new Student();
        stu.setUsername(username);
        stu.setAge(Integer.parseInt(age));
        stu.setScore(Integer.parseInt(score));

        //3.将学生对象的数据保存到d:\\stu.txt文件中
        BufferedWriter bw = new BufferedWriter(new FileWriter("d:\\stu.txt",true));
        bw.write(stu.getUsername()+","+stu.getAge()+","+stu.getScore());
        bw.newLine();
        bw.close();

        //4.通过定时刷新功能响应给浏览器
        //resp.setContentType("text/html;charset=UTF-8");
        resp.getWriter().write("添加成功，2秒后自动跳转到首页");
        resp.setHeader("Refresh","2;URL=/stu/index.jsp");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

```

虽然最后测试的时候有问题，检查了几遍，感觉代码上没什么问题，那就不管了，反正学到了知识就够了。那么最后，我们这一章，就算是完毕了。