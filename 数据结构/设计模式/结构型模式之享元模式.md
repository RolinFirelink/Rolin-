现在我们来学习享元模式，我们先来看看享元模式的定义和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4bb684aa91bef1725d5a86bb526cd208.png)

光说肯定是云里雾里的，咱们还是来做个案例吧，先来看看案例内容

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEee1a0421386106382391a347f7b8aede.png)

然后是案例的类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE03c641ae271953677a12b6c6d41db35d.png)

那么现在我们就来实现这个案例，首先我们创建对应的抽象享元角色，其下我们设计抽象方法为获取图形的方法，我们再设置一个显示图形和颜色的display方法

```
//抽象享元角色
public abstract class AbstractBox {

    //获取图形的方法
    public abstract String getShape();

    //显示图形及颜色
    public void display(String color){
        System.out.println("方块形状"+getShape()+", 颜色： "+color);
    }
}
```

然后我们定义具体的享元角色，当然要继承我们的抽象享元角色，内部要实现抽象方法即可，这里我们定义了三个，代码上大差不差，就只展示一个了

```
//I图形类（具体享元角色）
public class IBox extends AbstractBox{
    @Override
    public String getShape() {
        return "I";
    }
}
```

然后我们要设计我们的工厂类，工厂类的作用就是用于管理享元角色，我们这里我们维护享元角色的方式使用Map集合，构造方法中创建集合并预先创建可能需要使用到的所有对象，然后工厂类本身采取饿汉式的单例模式来结合构建，再提供一个根据名字获取对应的对象的方法

```
//工厂类，将该类设计为单例
public class BoxFactory {

    private HashMap<String,AbstractBox> map;

    //在构造方法中进行初始化操作
    private BoxFactory() {
        map = new HashMap<>();
        map.put("I",new IBox());
        map.put("L",new LBox());
        map.put("O",new OBox());
    }

    //提供一个方法获取该工厂类对象
    public static BoxFactory getInstance() {
        return factory;
    }

    private static final BoxFactory factory = new BoxFactory();

    //根据名称获取图形对象
    public AbstractBox getShape(String name) {
        return map.get(name);
    }
}

```

最后我们可以在我们的测试类中写入如下代码，最终可以得到我们预期的结果，box3和box4是同一个对象

```
public class Client {
    public static void main(String[] args) {
        //获取I图形对象
        AbstractBox box1 = BoxFactory.getInstance().getShape("I");
        box1.display("灰色");

        //获取I图形对象
        AbstractBox box2 = BoxFactory.getInstance().getShape("L");
        box2.display("绿色");

        //获取I图形对象
        AbstractBox box3 = BoxFactory.getInstance().getShape("O");
        box3.display("灰色");

        //获取I图形对象
        AbstractBox box4 = BoxFactory.getInstance().getShape("O");
        box4.display("红色");

        System.out.println("两次获取到的O图形对象是否是同一个对象："+(box3==box4));
    }
}
```

最后我们来看看享元模式的优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1686c2eed261239aa916dd548449896e.png)

- JDK源码解析

JDK中的Integer类中使用了享元模式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb54f362cc790e9a92aa36f23b4c4b2f5.png)

这里我们就不具体展开说了，因为自己看也看得懂，结论总之是 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf8e25990cf86315f3577d2773c6620fe.png)

