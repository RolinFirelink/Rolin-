那么现在我们的项目还存在什么问题呢？我们的项目存在的一个重点问题在于

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc55b30b8bd3ece064b2cbc52e263cdaa.png)

那么我们要如何解决这个问题么？我们可以对我们的项目进行读写分离，也就是说，我们可以整两个数据库来，一个是主库，一个是从库，读的操作全部给从库做，而写的操作全部给主库

同时我们的主库和从库的数据要保持一致，为达成这个目的我们可以使用mysql提供的主从复制功能，让我们的主库与从库的数据总是会同步保持一致

同时由于从库复制着主库的数据，相当于是给主库数据做了备份，这样也能增加我们数据的安全性

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb535402ee0dae83c02e8865f713bf20f.png)

我们首先来实现我们的主从复制，主从复制是mysql提供的功能，我们不需要借助第三方工具，其实现的原理是我们的对mysql执行的任何操作都会存在记录日志，而其令主从数据同步的方式是将主库的日志传给从库，然后从库执行完全相同的语句，然后就能实现主从库的数据完全一样了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3edf35fade5a85c479f16e2598a63aec.png)

这里我们值得一提的是，虽然我们这里只有一个从库，但实际上我们的从库可以不止只有一个，别因为我们这里只整了一个从库就产生从库只有一个的误解了

接着我们就可以正式来实现我们的主从复制了，先准备两天服务器并分别安装mysql服务并启动成功

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE21ba32b9bb8e05238ed27deea6a52c5d.png)

但是很不幸的是，我们没有两个服务器，因为买不起，而且我也觉得没啥必要，所以这一章节的内容我们就以了解为主，实际的项目中我们就不实现了

首先我们先来配置我们的主库，我们需要进入到我们的当前数据库的配置文件中添加如下两个代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb23e63d4bd85c66b5e34195faed901c6.png)

第二步是重启我们的mysql服务，其命令是systemctl restart mysqld

然后我们要登录我的Mysql数据库执行下图中的sql，这个sql的意义在于创建一个用户，名字是xiaoming，当然，这个名字我们可以自己换。然后给xiaoming这个用户授予建立复制时所需要用到的用户权限，并且给其设置密码，当然，这个密码我们也可以根据自己的喜好随便换

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb145ddb4b9d632bf2db01b470ed3b216.png)

最后我们来配置我们的主库，执行show master status命令，这里的文件名就是我们的日志文件名，Position则是我们的命令的条数，如果我们此时再执行其他命令的话，命令条数的内容就会被修改了，而我们后面是需要用到精确的命令数的，所以我们到此为止就不能再执行任何操作了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc58fe22269b0355a6e7fdeeb7441b6cf.png)

接着我们来配置从库，从库也是首先要修改其对应的配置文件

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeb064c76cd106f28b6c230676e781963.png)

然后要重启其服务

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3282af3827bd69180d6ca74d705197b3.png)

接着我们登录器数据库，往令其执行下面的命令，这里是设置的主库，先填入主库的ip地址，然后填入要绑定主库的用户名和密码，然后在输入主库的日志文件名和具体条数，这样我们就可以正确执行主从复制了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEccf6c5bfeb0fe0010a6fa189a4e9423c.png)

最后异步是要登录Mysql的数据库，执行show slave status来查看从库的状态，直接在Linux上看太乱了，我们可以将其复制到文本上看，我直接看Slave_IO_Running和Slave_SQL_Running这两个状态即可，若都为yes，那一般也就没什么问题了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaa9818625f1ca1b2179a5e3141366cc4.png)

那么到此为止，我们的主从复制就搞定了，此时我们用navicat连接两个数据库，往主库里添加数据之后，我们往从库里一刷新也能够看到从库也更新的主库的数据

- 读写分离

接着我们来实现读写分离，先来看看为什么我们要实现读写分离

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2781154dc842ee7350579fa88de652d8.png)

那么要实现读写分析，我们面临的一个重大问题就是，我们怎么判断我们的请求是读还是写然后将让他们去请求对应的数据库？这里就要使用到我们的Sharding-JDBC框架了，先来看看其介绍

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE053d4daaed8ebb28f4515a91991780dc.png)

我们来看看其实现读写分离的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3b2efc161dd26e6cdeac0f3d4316b641.png)

首先我们要导入其对应的maven坐标

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEadb350d463b2325bd916f3b5bd00ec3f.png)

然后我们来配置我们的Sharding-JDBC，我们整这个框架要搞的事情只有配置而已，配置搞好了剩下的工作他会自动帮我们完成。另外值得一提的是我们下面的配置并不是我们实际上的配置，这是我们课程中的配置，由于实际上我们并没有使用这项技术，因此下面的格式只是做一个参考而已

```
server:
  port: 8080
spring:
  application:
    #应用的名称，可选
    name: reggie_take_out
  shardingsphere:
    datasource:
      names:
        master,slave
      # 主数据源
      master:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://192.168.138.100:3306/reggie?characterEncoding=utf-8
        username: root
        password: root
      # 从数据源
      slave:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://192.168.138.101:3306/reggie?characterEncoding=utf-8
        username: root
        password: root
    masterslave:
      # 读写分离配置
      load-balance-algorithm-type: round_robin #轮询
      # 最终的数据源名称
      name: dataSource
      # 主库数据源名称
      master-data-source-name: master
      # 从库数据源名称列表，多个逗号分隔
      slave-data-source-names: slave
    props:
      sql:
        show: true #开启SQL显示，默认false
  main:
    allow-bean-definition-overriding: true
  redis:
    host: 172.17.2.94
    port: 6379
    password: root@123456
    database: 0
  cache:
    redis:
      time-to-live: 1800000 #设置缓存数据的过期时间
mybatis-plus:
  configuration:
    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: ASSIGN_ID
reggie:
  path: D:\img\
```

首先我们在spring下配置我们的shardingsphere，我们这里首先要配置我们的数据源的名字，这里的名字可以随意指定，指定的不同的名字就代表不同的数据库，但是要注意的是，我们下面的具体配置的数据源的名字必须要和我们上面的设置的名字一样

首先我们要配置的是主数据源，其标签是master，其下的内容就是我们配置数据源的内容罢了，这个不多提

然后我们要配置的就是从数据源，也大差不差，同样不多提

接着我们利用masterslave标签来配置我们的全局配置，首先配置的是我们的负载均衡，我们这里设置的是轮询。所谓负载均衡其实指的就是当我们的请求发送过来时，我们选择由哪个数据库来执行查询的请求，由于往往我们的从库都不只是一个的，我们这里设置的轮询，其实就是按照顺序一个个发，没了

接着我们要设置的我们的最终的数据源的名称，因为我们的这个框架的数据源其实是将两个数据源封装成一个数据源对象，而这个对象当然需要名字，我们这里设置其名字就为dataSource。然后我们要我们要设置我们的主数据源的名称和从库数据源的名称，我们就将对应的主库从库的名字放上去就完了

最后我们还要设置的一个是mian标签下的allow-bean-definition-overriding为true，这个意为开启bean的自动覆盖，因为在们的这个项目中，Spring自己还会创建一个数据源对象，而我们这里我们又会创建一个数据源对象，如果我们不开启自动覆盖，那么就会导致出现两个同名的数据源对象，而这是Spring项目所不允许的，此时我们的Spring会直接报错停止

那么设置完毕之后，我们的东西就搞定了，没啥特别的问题，此时我们发送请求时可以在控制台上看到其会自动定位到我们的具体数据库并发送对应的请求

