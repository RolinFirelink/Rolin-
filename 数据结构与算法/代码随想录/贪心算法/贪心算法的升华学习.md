到这一段的题目就颇具难度了，这一节的题目说实话还是以理解为主，没必要强求一看就懂，毕竟说实话，很多思路我看了下我觉得真的是想不出来的，只能先记着，以后能用就用上

- 单调递增的数字

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbee085998218d32d951f2a43d4f5684f.png)

这题恶心就恶心在，你虽然能感觉到这里是要用贪心，但是你不知道具体怎么贪，也不知道咋整好

那么我们这题究竟应该要怎么贪呢？其实我们可以在遇见前一位大于后一位的情况时，只要令前一位-1，然后令后一位赋值为9即可，具体可以看下面的例子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15a8532896d2c657262ca3eaf815c5ff.png)

局部最优：遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。

全局最优：得到小于等于N的最大单调递增的整数。

但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9

那么根据上面的逻辑，我们很容易就可以写出我们的代码如下

```
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        int start = s.length();
        for (int i = s.length() - 2; i >= 0; i--) {
            if (chars[i] > chars[i + 1]) {
                chars[i]--;
                start = i+1;
            }
        }
        for (int i = start; i < s.length(); i++) {
            chars[i] = '9';
        }
        return Integer.parseInt(String.valueOf(chars));
    }
}
```

- 买卖股票的最佳时机含手续费

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE78bbe02e743457f3c831a1609f7f83e3.png)

这题，我们尝试使用贪心算法做，我们的贪心思路是只要利润大于我们的手续费和成本之和我们就卖出，但结果是错的，因为有时候我们是要尽量少买，这样可以避免产生重复的手续费

那么我们这题应该要怎么做呢？其实我也不知道，我看了答案之后我发现答案我也看不太懂到底是在讲些什么几把，所以我们这里也是稍微过一过就好了吧，因为这题本来就是应该用动态规划来做才是正解的，直接看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdaf14d6b6653b9e7a780f7cf58b4a418.png)

那么根据上图的逻辑，我们可以写入我们的代码如下

```
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int ans = 0;
        int minPrice = prices[0];
        for (int i = 1; i < prices.length; i++) {
            //情况二相当于买入
            if(prices[i]<minPrice){
                minPrice=prices[i];
            }

            //情况三：保持原有状态（因为此时买不便宜，卖则亏本）
            if(prices[i]>=minPrice && prices[i]<=minPrice+fee){
                continue;
            }

            //计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出
            if(prices[i]>minPrice+fee){
                ans+=prices[i]-minPrice-fee;
                minPrice = prices[i]-fee;
            }
        }
        return ans;
    }
}
```

- 监控二叉树

最后我们来看一道真正意义上的重量级题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0039330b17903783ba7ee37414188abc.png)

对于这题，我们的思路是先构造一个全新的二叉树节点，该节点存在一个对父引用的指向，然后我们通过这个结构进行递归的求解，但是问题在于中间到底要怎么处理才能获得最好的一个贪心情况，这里我们卡住了，尝试了很多种办法都得不到理想中的最优解，最终还是放弃了，因为这里的逻辑处理这一段我就直接卡住了

最终我们的没能通过的代码如下所示

```
class Solution {
    int ans = 0;
    public int minCameraCover(TreeNode root) {
        MyTreeNode myTreeNode = create(root);
        link(myTreeNode);
        dfs(myTreeNode);
        return ans;
    }

    private void dfs(MyTreeNode myTreeNode) {
        if(myTreeNode==null){
            return;
        }
        MyTreeNode prev = myTreeNode.prev;
        MyTreeNode left = myTreeNode.left;
        MyTreeNode right = myTreeNode.right;

        //三个结点都不存在
        if(prev==null && left==null && right==null){
            ans++;
            myTreeNode.val=1;
            return;
        }

        //情况三，子结点中有不存在的结点
        if(judge(prev) && judge(left) || judge(prev) && judge(right)){
            ans++;
            myTreeNode.val=1;
        }

        dfs(myTreeNode.left);
        dfs(myTreeNode.right);
    }

    private boolean judge(MyTreeNode node) {
        if(node==null){
            return false;
        }
        return node.val==0;
    }

    //将所有节点连接其父节点的方法
    private void link(MyTreeNode myTreeNode) {
        if(myTreeNode==null){
            return;
        }

        MyTreeNode left = myTreeNode.left;
        if(left!=null){
            left.prev=myTreeNode;
        }
        MyTreeNode right = myTreeNode.right;
        if(right!=null){
            right.prev=myTreeNode;
        }

        link(myTreeNode.left);
        link(myTreeNode.right);
    }

    //构造同结构的MyTreeNode节点的递归方法
    private MyTreeNode create(TreeNode root) {
        if(root==null){
            return null;
        }
        MyTreeNode node = new MyTreeNode(root.val);
        node.left = create(root.left);
        node.right = create(root.right);
        return node;
    }
}

class MyTreeNode {
    public MyTreeNode left;
    public MyTreeNode right;
    public MyTreeNode prev;
    public int val;

    public MyTreeNode(MyTreeNode left, MyTreeNode right, MyTreeNode prev, int val) {
        this.left = left;
        this.right = right;
        this.prev = prev;
        this.val = val;
    }

    public MyTreeNode(MyTreeNode left, MyTreeNode right, int val) {
        this.left = left;
        this.right = right;
        this.val = val;
    }

    public MyTreeNode(int val) {
        this.val = val;
    }

    public MyTreeNode() {
    }
}

```

那么这题我们的贪心算法到底应该怎么做呢？我们的局部最优又是什么呢？其实我们可以从示例中得到答案

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf6d75f61e47944b23a41706a07723aa0.png)

所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！

当然我知道可能有人会说这尼玛不扯淡呢，谁寄吧想得到啊，那我只能说，想不到就想不到，记着，下次往这个方向想就行了好吧

接着我们这里还有两个难点，分别是

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdd2caf1db0d2a05af34dc3252acb2c26.png)

首先我们要确定的是如何遍历，我们需要的是从下到上推导，那就当然需要用到回溯，而回溯的一个最基本的要求就是先获取对应的结点后处理，所以我们可以先获得两边节点，最后再进行处理，这样就可以实现我们的回溯了，这个思路其实也类似于后序遍历

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE62206831c92d7e225cb431ee8555ae5f.png)

接着我们来解决第二个问题，我们要如何隔两个结点就放置一个摄像头，这里我们需要记住最重要的一点，那就是节点一共有三种状态，而我们可以用数字来表示这三种状态

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE76c5c87e7ee4cca591884cbe58e47b65.png)

这时候有些聪明的同学可能会觉得还有第四种状态，那就是本节点无摄像头的状态，但其实该结点的状态定然是无覆盖或者是有覆盖的状态的，因此我们还是可以用三种状态表示完，那就没必要特别分出第四种状态，这样只会让问题复杂化

还有一个问题是在遍历树的过程中，我们会遇上空节点，那么空节点到底是属于哪一种状态呢？要解决这个问题，我们需要回归到问题的本质，我们的题目需求是希望我们让我们的摄像头数量最少，我们的贪心思路是尽量往叶结点的父节点放置摄像头，而空节点一般是存在于叶结点处的，因此我们可以让我们的空节点处于覆盖状态

那么如果我们遇到的结点为空，我们就创建一个新的结点，赋值为2传回，这样才能正确表示空节点的状态，也可以避免出现空指针异常

接着我们就要对我们的递归进行分情况讨论，一共可以分出四种情况，先来看看情况一

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2eb64f267186ce4cf9ffe3be01d02e5b.png)

那么遇上这种情况，我们要做的事就是将该结点的值修改为2，然后直接传回该结点，再来看看情况二

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3514bf76b38ad7d1edd032ea953f2cad.png)

情况二其实很好理解，因为无论是哪种情况，都一定会有一个孩子是没有覆盖到的，为了让其覆盖到，我们当然要将该结点赋予摄像头，再来看看情况三

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf1d4072261983f0d6fd41f72c73e17c5.png)

一旦左右孩子已经有一个摄像头了，那么父节点就是被覆盖的状态，这很好理解，就不多提了

最后一种情况是在递归处理之后，头结点没有覆盖的情况

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfe188f1346c7d055adf5a9e0d081890a.png)

这种情况我们只需要单独再对头结点做一个判断即可，若头结点是未覆盖的状态，我们则手动将其覆盖

那么最终我们可以写入我们的代码如下

```
class Solution {
    int res=0;
    public int minCameraCover(TreeNode root) {
        // 对根节点的状态做检验,防止根节点是无覆盖状态 .
        if(minCame(root).val==0){
            root.val=1;
            res++;
        }
        return res;
    }
    /**
     节点的状态值：
     0 表示无覆盖
     1 表示 有摄像头
     2 表示有覆盖
     后序遍历，根据左右节点的情况,来判读 自己的状态
     */
    public TreeNode minCame(TreeNode root){
        if(root==null){
            // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头
            return new TreeNode(2);
        }

        TreeNode left=minCame(root.left);
        TreeNode right=minCame(root.right);


        // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头
        if(left.val==2&&right.val==2){
            //(2,2)
            root.val=0;
            return root;
        }else if(left.val==0||right.val==0){
            // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头
            // (0,0) (0,1) (0,2) (1,0) (2,0)
            // 状态值为 1 摄像头数 ++;
            res++;
            root.val=1;
            return root;
        }else{
            // 左右节点的 状态为 (1,1) (1,2) (2,1) 也就是左右节点至少存在 1个摄像头，
            // 那么本节点就是处于被覆盖状态
            root.val=2;
            return root;
        }
    }
}
```

这里值得一提的是，其实我们可以不必修改结点，因为我们实际进行判断的也只是结点中的值，那我们何必专门返回结点，我们直接把代表这个结点的值给返回就行了，连修改都省了，岂不美哉？

因此我们可以将我们的代码简化如下

```
class Solution {
    int  res=0;
    public int minCameraCover(TreeNode root) {
        // 对根节点的状态做检验,防止根节点是无覆盖状态 .
        if(minCame(root)==0){
            res++;
        }
        return res;
    }
    /**
     节点的状态值：
     0 表示无覆盖 
     1 表示 有摄像头
     2 表示有覆盖 
     后序遍历，根据左右节点的情况,来判读 自己的状态
     */
    public int minCame(TreeNode root){
        if(root==null){
            // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 
            return 2;
        }
        int  right=minCame(root.right);
        int left=minCame(root.left);


        // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头
        if(left==2&&right==2){
            //(2,2) 
            return 0;
        }else if(left==0||right==0){
            // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头
            // (0,0) (0,1) (0,2) (1,0) (2,0) 
            // 状态值为 1 摄像头数 ++;
            res++;
            return 1;
        }else{
            // 左右节点的 状态为 (1,1) (1,2) (2,1) 也就是左右节点至少存在 1个摄像头，
            // 那么本节点就是处于被覆盖状态 
            return 2;
        }
    }
}
```

我承认这题的难度有点大，尤其是最后的分四种情况，难得要死，但是我们起码可以先记住是吧，记住了，以后遇上类似题目起码就会做了不是