本章节我们来学习二叉树的回溯解法相关的内容，那么什么是回溯呢？其实回溯就是递归的一种。不过回溯是递归的过程中，我们后面的递归过程用用到前面的递归过程的结果，一般来说，回溯要求我们进入新的递归例程时要将参数变化，而从中退出时要将该变化复原

- 完全二叉树的节点个数

先看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbb6e39c75529e6a43b2dec2125b5d251.png)

我们这题的重点在于要相处一个时间复杂度比线性阶更快的算法，这肯定要利用到其一定是完全二叉树的性质。当然，在做这题之前我们当然要先知道到底什么是完全二叉树，我们先来复习下完全二叉树的定义，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE61c6b0dfe94907a901608b3c6b6359fe.png)

首先完全二叉树是除地城结点可能没填满外，其他每次结点都达到最大值。而且最下面一层的结点全部都集中在左边位置，不会集中到右边，也不会出现左边有一部分右边也有一部分的情况。然后我们来看看完全二叉树在本题中的一些性质

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。我们先来看看情况一的图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE96194498fd4fafc69d2802c6e5c2eb22.png)

然后来看看情况二的图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0a42b8720381ef5715e4d684143bc9e6.png)

那么我们的基本思路就是不断去判断每个结点的的左右子树，看看其是不是满二叉树，若是我们就将对应的满二叉树的结点数量直接用公式计算出来，若不是我们就继续去寻找满二叉树。根据这个思路，我们可以写出我们的递归代码如下

```
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null){
            return 0;
        }
        int leftDepth = deep(root.left);
        int rightDepth = deep(root.right);
        if(leftDepth==rightDepth){
            return (int) (Math.pow(2,leftDepth)+countNodes(root.right));
        }else {
            return (int) (Math.pow(2,rightDepth)+countNodes(root.left));
        }
    }

    private int deep(TreeNode root) {
        int deep = 0;
        while (root!=null){
            deep++;
            root=root.left;
        }
        return deep;
    }
}
```

我们这里采用递归和迭代并用的方式来构造我们的代码，我们这里先获得一个结点左右子树的深度，我们这里获取深度的方式都是不断往左子树中走的，这里由于完全二叉树具有底层结点总是往左靠的性质，所以我们可以通过这种方式可以保证我们总是能到达最大深度。若两者的深度相等，说明该结点的左子树是完全二叉树，此时我们就对应计算左边的二叉树结点数量并进入右子节点继续执行该代码，若不相等则必定是右小于左，此时其右子树必然是完全二叉树，此时我们对应计算右子树的代码并进入左子树中继续执行递归例程。

当然我们也可以用迭代来实现，请看代码

```
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null){
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        int sum = 0;
        while (!deque.isEmpty()){
            TreeNode node = deque.pop();
            if(node==null){
                continue;
            }
            int left = deep(node.left);
            int right = deep(node.right);
            if(left==right){
                sum+= (int) Math.pow(2,left);
                deque.add(node.right);
            }else {
                sum+= (int) Math.pow(2,right);
                deque.add(node.left);
            }
        }
        return sum;
    }

    private int deep(TreeNode root) {
        int deep = 0;
        while (root!=null){
            deep++;
            root=root.left;
        }
        return deep;
    }
}
```

迭代利用的是层序遍历结合我们的之前的判断方式来进行逻辑判断，其内部逻辑和递归的差不多，这里就不重复提及了。

不过我们这里有一点美中不足，那就是我们这里采用的是调用函数来进行的幂运算，稍显复杂，实际上我们可以通过位运算来直接一步达成我们的目的，不但代码美观，效率还会更高，请看代码

```
class Solution {
    /**
     * 针对完全二叉树的解法
     *
     * 满二叉树的结点数为：2^depth - 1
     */
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        if (leftDepth == rightDepth) {// 左子树是满二叉树
            // 2^leftDepth其实是 （2^leftDepth - 1） + 1 ，左子树 + 根结点
            return (1 << leftDepth) + countNodes(root.right);
        } else {// 右子树是满二叉树
            return (1 << rightDepth) + countNodes(root.left);
        }
    }

    private int getDepth(TreeNode root) {
        int depth = 0;
        while (root != null) {
            root = root.left;
            depth++;
        }
        return depth;
    }
}
```

- 平衡二叉树

先来看看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6b0387f609f4e1d8f1d183f447540888.png)

本题我们要接触到回溯，但是在那之前，我们先来复习下高度和深度的定义，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaf013c1a59fa8091c621f7a7a2df3281.png)

有了这些知识之后我们正式来解开这题，首先我们用递归的方式来解开，我们要运用我们的递归三部曲，我们首先确定我们的递归参数和返回值，我们的递归参数毫无疑问的是我们的结点，而我们的返回值则是int类型的值，其代表了我们当前结点到根结点的高度。然后我们要明确我们的终止条件，我们这里的终止条件是当我们的结点为空时，我们返回0，代表最初的高度。最后我们要明确我们的每层递归的逻辑，我们每层递归都去判断其左右子树的高度，如果高度大于1，那么就说明其不符合条件，我们就返回-1代表其不符合条件，如果其符合条件，我们就将这个高度往上传递，同时越往上走越增加高度

根据这么思路，我们可以写出我们的代码如下

```
class Solution {
    public boolean isBalanced(TreeNode root) {
        return dfs(root)!=-1;
    }

    private int dfs(TreeNode root) {
        if(root==null) return 0;
        int left = dfs(root.left);
        if(left==-1) return -1;
        int right = dfs(root.right);
        if(right==-1)  return -1;
        return Math.abs(left-right)<=1 ? 1 + Math.max(left,right) : -1;
    }
}
```

我们这里判断其是否为真只要判断最后返回的值是否为-1就完了，第9行和第11行的-1的判断条件是为了尽早终止不必要的递归，提高效率，同时也是为了防止错判。最后我们进行一个判断，判断左右高度之差是否小于1，若小于1则说明符合条件，我们就令高度+1，同时返回左右子树中的较大者，其能代表最大高度，若不符合则直接返回-1就完了。

注意一点的是我们这里用到了回溯，可以看到我们运用回溯的方式，我们的回溯往往是要求我们的参数传入时要进行改动，传回时要复原这个改动，我们这里就采用直接往返回值里+1的方式隐藏了这个步骤，而其也有同样的效果。我们这里的回溯主要体现在，我们最后进行判断的条件是会往上呈递的，然后上面的条件判断时是会用上。这是回溯的基本思路，不过实际上我们这题就算我们令其复原也是可以的，因为我们是自底向上传递我们的高度的，不断传递直到到了最顶就停止，根本不会回到复原处，所以无所谓。但是，我们的回溯法的规范是要求我们做出复原这一步的，所以平时就别乱搞，好好把复原这一步也整上。

然后我们来看看我们迭代的代码，我们这里迭代的代码比较难，而且说实话效率也比较低，只做一个了解就可以了。

```
class Solution {
    /**
     * 迭代法，效率较低，计算高度时会重复遍历
     * 时间复杂度：O(n^2)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root!= null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 比较左右子树的高度差，输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 层序遍历，求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```

在迭代的代码里我们定义了两个方法，一个方法用于遍历结点，另一个方法是用于求当前结点的高度，这里每次进入一个结点都要进行重复遍历，说实话效率很差，而且内部的方法也不容易理解，有兴趣的自己看看吧。

值得一提的是这个方法其实还可以优化，那就是这个方法其实本质也是在模拟递归的逻辑，其也是自底向上开始计算高度是否正确的，因此我们可以将计算高度的方法稍微修改，不用每次都计算高度，而是每次计算出一个高度就将这个高度的值赋给对应的结点，然后其上一个结点只要去两个结点中的较大者就可以直接获得当前结点的高度了，具体请看代码

```
class Solution {
    /**
     * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历
     * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。
     * 时间复杂度：O(n)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = root.left != null ? root.left.val : 0;
        int rightHeight = root.right != null ? root.right.val : 0;
        int height = Math.max(leftHeight, rightHeight) + 1;
        root.val = height;// 用TreeNode.val来保存当前结点的高度
        return height;
    }
}
```

我们接着来看最后一题

- 二叉树的所有路径

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8b88003af93978a8336f49a42e5183ae.png)

这题很显然要使用回溯法来做，由于他很简单，我们甚至不需要进行过多的分析，请看其回溯代码

```
class Solution {
    List<String> list = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        dfs(root,"");
        return list;
    }

    private void dfs(TreeNode root,String s) {
        if(root==null){
            return;
        }
        if(root.left!=null){
            dfs(root.left,s+root.val+"->");
        }
        if(root.right!=null){
            dfs(root.right,s+root.val+"->");
        }
        if(root.left==null && root.right==null){
            list.add(s+root.val);
        }
    }
}
```

我们这里的递归就要用到复原后的参数了，如果我们这题还搞什么直接对参数本身进行变化，那么就会寄

接着我们来看看迭代的代码

```
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```

迭代代码利用的是前序遍历的方式来进行对每一个叶结点路径的获得，这里新创建一个栈用于获取记录之前的路径。我个人已经很尽力去尝试用统一迭代法来实现这里的迭代的逻辑了，但总是实现不了，实在没法了，所以我们就暂时先记住这个迭代代码吧

- 左叶子之和

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE32c16ef183f803b01400776039c9d910.png)

注意我们这里要的是左叶子之和，而不是左边的最左边的结点，这是两回事，具体请看下面的例子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5603222fe3905b8518cb2fec69c2bd59.png)

所以我们判断结点是不是左叶子，不是通过最左边结点的有无来判断，而是通过判断父节点来判断其左孩子是不是左叶子，具体请看代码

```
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        int leftValue = sumOfLeftLeaves(root.left);    // 左
        int rightValue = sumOfLeftLeaves(root.right);  // 右

        int midValue = 0;
        if (root.left != null && root.left.left == null && root.left.right == null) {
            midValue = root.left.val;
        }
        int sum = midValue + leftValue + rightValue;  // 中
        return sum;
    }
}
```

上面这行代码说实话比较难理解，实际解题的时候应该也不可能会构造这么难理解的代码。但是我们有一个简单版本的，那就是我们既然是要通过获得其左叶子之和，那么我们可以将所有左叶子的值加起来，而右叶子则不加，如果判断其是左叶子还是右叶子可以通过简单的前序遍历来判断，那我们如何确定到底要不要加呢？我们可以通过传入一个布尔变量来确定，如果是左叶子，我们就传入true，如果是右，那么就传入false，其递归逻辑是每层都判断其是否为左叶子，具体请看代码

```
class Solution {
    int sum = 0;
    public int sumOfLeftLeaves(TreeNode root) {
        dfs(root,false);
        return sum;
    }

    private void dfs(TreeNode root,boolean judge) {
        if(root.left==null && root.right==null && judge) sum+=root.val;
        if(root.left!=null) dfs(root.left,true);
        if(root.right!=null) dfs(root.right,false);
    }
}
```

这样我们就能够很简单的获得所有的左叶子之和了，而且也易于理解

最后我们再来补充一个使用迭代的做法，多构建一个栈用于保存true和false就行了

```
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        Deque<Boolean> dequeBool = new LinkedList<>();
        deque.add(root);
        dequeBool.add(false);
        int sum = 0;
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            boolean judge = dequeBool.pollLast();
            if(node.right!=null){
                deque.add(node.right);
                dequeBool.add(false);
            }
            if(node.left!=null) {
                deque.add(node.left);
                dequeBool.add(true);
            }
            if(judge && node.left==null && node.right==null){
                sum+=node.val;
            }
        }
        return sum;
    }
}
```

另外还有一点值得一提的是，采用统一迭代法难以解决这种问题，似乎统一迭代法只适合三种遍历本身，而难以去增加其他变量在其中的运用，总之以后遇上这种题目我反正不用统一迭代的代码去做了

- 寻找数组左下角的值

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9e813768221b0b0ccc67d2203bcd2f83.png)

我们要注意我们这题和之前的题目的区别，我们这题是求左下角的值，而非左节点，因此按照上一题的方法来做是行不通的。我们有一个简单想法就是每次我们都取其层数的第一个结点，而不取其第二个结点，同时我们让我们的递归总是优先往左递归，这样就可以实现我们的目的。而我们可以创建一个足够长的数组，令其索引代表高度，这样只要我们的树的高度不超过这个索引，我们就可以获取到每次的最左边的元素

```
class Solution {
    int[] ans = new int[]{0,0};
    int[] deeps = new int[10000];
    public int findBottomLeftValue(TreeNode root) {
        dfs(root,0);
        return ans[0];
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(deep>=ans[1] && deeps[deep]==0){
            ans[0]=root.val;
            ans[1]=deep;
        }
        deeps[deep]++;
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

虽然这个方法是可行的，但其是不够好的，因为总是要创建一个用于表示的高度的数组，浪费空间，而且还不具有普适性，所以我们要对我们的代码进行改造。实际上，我们大可不必采用这么这么迂回的方式，我们既然每次都要最左边的值，那么我们只要每次让我们的递归优先从左边走，然后判断其是不是第一次进入的，若是则将值更新，若不是则不更新即可，同时为了保证第一个结点也能被更新到，我们可以将最初的深入设置为-1，根结点的深度设置为0，请看代码

```
class Solution {
    int[] ans = new int[]{0,-1};
    public int findBottomLeftValue(TreeNode root) {
        dfs(root,0);
        return ans[0];
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(root.left==null && root.right==null){
            if(deep>ans[1]){
                ans[0]=root.val;
                ans[1]=deep;
            }
        }
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

用迭代法来做也是一样的，无非是多创建一个栈用于保存深度

```
class Solution {
    int[] ans = new int[]{0,-1};
    public int findBottomLeftValue(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        Deque<Integer> dequeDeep = new LinkedList<>();
        deque.add(root);
        dequeDeep.add(0);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            int deep = dequeDeep.pollLast();
            if(node.left==null && node.right==null ){
                if(deep>ans[1]){
                    ans[0]=node.val;
                    ans[1]=deep;
                }
            }
            if(node.right!=null){
                deque.add(node.right);
                dequeDeep.add(deep+1);
            }
            if(node.left!=null){
                deque.add(node.left);
                dequeDeep.add(deep+1);
            }
        }
        return ans[0];
    }
}

```

不过我们也可以不去多建造这么一个栈来保存深度，我们可以通过层序遍历来实现我们的需求，进入一层将最左边的，也就是第一个结点更新，否则就不更新，这个逻辑更加容易实现，效率也更高

```
//迭代法
class Solution {

    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if (i == 0) {
                    res = poll.val;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return res;
    }
}
```

- 路径总和

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2a6accc4d640e7a5abddb36d80028838.png)

这个比较简单了，先来看看递归的代码

```
class Solution {
    boolean ans=false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null) return ans;
        dfs(root,targetSum-root.val);
        return ans;
    }

    private void dfs(TreeNode root, int targetSum) {
        if(root.left==null && root.right==null && targetSum==0){
            ans=true;
            return;
        }
        if(root.left!=null){
            dfs(root.left,targetSum-root.left.val);
        }
        if(root.right!=null){
            dfs(root.right,targetSum-root.right.val);
        }
    }
}
```

这个递归的逻辑非常简单，这个就不多讲了，随便看都看得懂了，接下来看看迭代的代码

```
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null) return false;
        Deque<TreeNode> deque = new LinkedList<>();
        Deque<Integer> dequeSum = new LinkedList<>();
        deque.add(root);
        dequeSum.add(targetSum);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            int target = dequeSum.pollLast();
            if(target-node.val==0 && node.left==null && node.right==null){
                return true;
            }
            if(node.left!=null){
                deque.add(node.left);
                dequeSum.add(target-node.val);
            }
            if(node.right!=null){
                deque.add(node.right);
                dequeSum.add(target-node.val);
            }
        }
        return false;
    }
}
```

同样是多创造一个栈用于计算值是否为零

- 路径总和II

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd642f7debe8ca5cfa921511179491cc9.png)

其实就是前面的plus版本，我们先来看看递归代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null){
            return list;
        }
        List<Integer> list = new LinkedList<>();
        list.add(root.val);
        dfs(root,targetSum-root.val,list);
        return this.list;
    }

    private void dfs(TreeNode root, int targetSum, List<Integer> list) {
        if(root.left==null && root.right==null && targetSum==0){
            List<Integer> list1 = new LinkedList<>(list);
            this.list.add(list1);
            return;
        }
        if(root.left!=null){
            list.add(root.left.val);
            dfs(root.left,targetSum-root.left.val,list);

            list.remove(list.size()-1);
        }
        if(root.right!=null){
            list.add(root.right.val);
            dfs(root.right,targetSum-root.right.val,list);
            list.remove(list.size()-1);
        }
    }
}
```

我们这里的逻辑和上一题的是差不多的，同样是运用的回溯，不过值得一提的是，由于集合添加进去之后我们的原来的集合指向还是指向该集合，这样回溯会造成我们的目标集合发生变动，所以我们只能添加一个同样的新集合上去，没法了属于是

接下来来看看迭代代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        Deque<List<Integer>> dequeList = new LinkedList<>();
        dequeList.add(new LinkedList<>());
        Deque<Integer> dequeSum = new LinkedList<>();
        dequeSum.add(targetSum);
        while (!deque.isEmpty()){
            TreeNode node = deque.pollLast();
            List<Integer> list = dequeList.pollLast();
            int target = dequeSum.pollLast();
            if(target- node.val==0 && node.left==null && node.right==null){
                list.add(node.val);
                this.list.add(new LinkedList<>(list));
                list.remove(list.size()-1);
            }
            if(node.left!=null){
                deque.add(node.left);
                list.add(node.val);
                dequeList.add(new LinkedList<>(list));
                list.remove(list.size()-1);
                dequeSum.add(target-node.val);
            }
            if(node.right!=null){
                deque.add(node.right);
                list.add(node.val);
                dequeList.add(new LinkedList<>(list));
                list.remove(list.size()-1);
                dequeSum.add(target-node.val);
            }
        }
        return list;
    }
}
```

迭代代码的思路好递归的还是差不多，递归里多了什么参数，我们就多创建什么栈来对应模拟就可以了，虽然说效率的确是不咋地就是了



