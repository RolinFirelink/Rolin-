用户删除

我们现在实现用户删除的持久化代码，同样，我们看看删除界面的代码

```javascript
<Button layoutX="571.0" layoutY="10.0" mnemonicParsing="false" prefHeight="54.0"
        onMouseClicked="#deleteUser" prefWidth="100.0" styleClass="btn-warning"
        text="删除"/>
```

点进去看看其对应执行的事件代码，注意，这里点进去的事件代码其即使我们所说的controller层，因为其实我们实际执行代码的位置

```javascript
@FXML
private void deleteUser() {
    try {
        User user = this.userTableView.getSelectionModel().getSelectedItem();
        if (user == null){
            Alerts.warning("未选择","请先选择要删除的数据");
            return;
        }
        this.users.remove(user);
        Alerts.success("成功", "操作成功");
    } catch (Exception e) {
        e.printStackTrace();
        Alerts.error("失败","操作失败");
    }
}
```

上面这个代码跟我们之前将修改的时候差不多了，不多讲了这次，现在我们来实现下删除方法，我们的基本思路是先获得在内存里删除的对象的id，然后拿来跟list集合里的对象进行比对，找到对应id的对象，然后将其删除，接着将新集合写入到我们的文件中

按照这个思路和代码分层的思想，我们先来实现dao层的接口

```javascript
void delete(int id);
```

实现对应类的代码

```javascript
@Override
public void delete(int id) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        List<User> list = (List<User>) ois.readObject();
        User user = list.stream().filter(u -> u.getId()==id).findFirst().get();
        list.remove(user);
        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.USER_PATH));
        oos.writeObject(list);
        oos.flush();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

Service层接口添加的方法

```javascript
void delete(int id);
```

对应实现方法

```javascript
/**
 * 删除
 * @param id
 */
@Override
public void delete(int id) {
    userDao.delete(id);
}
```

最后是controller层

```javascript
@FXML
private void deleteUser() {
    try {
        User user = this.userTableView.getSelectionModel().getSelectedItem();
        if (user == null){
            Alerts.warning("未选择","请先选择要删除的数据");
            return;
        }
        userService.delete(user.getId());//上
        this.users.remove(user);//下
        Alerts.success("成功", "操作成功");
    } catch (Exception e) {
        e.printStackTrace();
        Alerts.error("失败","操作失败");
    }
}
```

那么到此为止我们的删除方法也实现完毕了，这里要着重提一下为什么我们要将删除硬盘内的对象的方法放到上面，而删除内存的放到下面来，因为这样放假如我们删除硬盘中的文件失败了，那么这个代码就会打印异常，删除内存中的用户对象的代码就不会执行，这样其就不会受到影响，但如果是反过来放，那么就会出现内存中的删掉了，而实际上的没有删掉的情况，这是不行的

当然，即使我们这样放，也还是会出现我们文件中的删除掉了，而删除内存中的对象时却出现了异常导致内存中的没有删除成功的情况，但是这种情况就比我们上一种的情况要好一些，因为我们实际的内容还是要从文件中读取的，即使我们展示的内容出了问题，我们只要重启就能恢复正常了，这比前一种情况要好得多

但我们这里还有一些问题，我们的坏情况依赖于我们的异常处理机制，而因为我们在Dao层中已经将异常抓住了，这样我们的controller层就不可能使用异常机制，因为异常都没有抛出来，因此我们在Dao层里应该要手动抛出一个异常，所以我们Dao层里的代码可以修改如下

```javascript
@Override
public void delete(int id) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        List<User> list = (List<User>) ois.readObject();
        User user = list.stream().filter(u -> u.getId()==id).findFirst().get();
        list.remove(user);
        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.USER_PATH));
        oos.writeObject(list);
        oos.flush();
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();//将异常抛给控制器
    }  finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

注意修改位置在14和15行，我们打印异常信息之后还往上级抛出了一个异常，同样的添加和修改方法也要进行相同的处理，这里就不展示对应代码了

这里也是根据我们以前讲过的知识点，最底层的代码不用处理异常，因为自己抓自己的异常没有意义，我们要令其在控制台上打印出来才有意义，因此Dao层里要时刻注意异常处理之后还需要往上一级抛出异常



用户冻结

其实冻结嘛，就跟修改差不多，也就是把用户的状态从正常改为冻结然后持久化就完了

依葫芦画瓢找到冻结的界面代码

```javascript
<Button layoutX="626.0" layoutY="10.0" onMouseClicked="#frozen" mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0" styleClass="btn-danger" text="冻结" />
```

进去其controller层的代码

```javascript
/*
    冻结用户
 */
@FXML
private void frozen() {
    User user = this.userTableView.getSelectionModel().getSelectedItem();
    if (user == null){
        Alerts.warning("未选择","请先选择要修改的数据");
        return;
    }
    user.setStatus(Constant.USER_FROZEN);
    userTableView.refresh();
}
```

接着我们先来实现Dao层，现在接口里添加方法

```javascript
void frozen(int id);
```

实现类

```javascript
/**
 * 冻结操作
 * @param id
 */
@Override
public void frozen(int id) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        List<User> list = (List<User>) ois.readObject();
        User user = list.stream().filter(u -> u.getId()==id).findFirst().get();
        user.setStatus(Constant.USER_FROZEN);
        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.USER_PATH));
        oos.writeObject(list);
        oos.flush();
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    } finally {
        if (ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

service层接口

```javascript
void frozen(int id);
```

实现类

```javascript
/**
 * 冻结
 * @param id
 */
@Override
public void frozen(int id) {
    userDao.frozen(id);
}
```

controller层

```javascript
/*
    冻结用户
 */
@FXML
private void frozen() {
    User user = this.userTableView.getSelectionModel().getSelectedItem();
    if (user == null){
        Alerts.warning("未选择","请先选择要修改的数据");
        return;
    }
    userService.frozen(user.getId());
    user.setStatus(Constant.USER_FROZEN);
    userTableView.refresh();
}
```

添加的代码在第11行，同样遵从上下原则，那我们就把用户冻结的代码也实现完毕了

最后我们也可以看出来，其实，我们这个操作都差不多，都是利用IO流对文件进行存储就完了的，我们现在已经实现完了用户管理的功能了，基本都是使用的IO流的知识，接下来这一类的重复代码我们就不重复写了，之后我们就要提高些难度了，来点不一样的