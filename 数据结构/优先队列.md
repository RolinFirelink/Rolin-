什么是优先队列？我们之前只学习过队列，在队列里的元素都是按照先进出的原则来存储，但如果我们有这么一个需求，我们需要先取出队列中元素的最大值那我们应该怎么实现？我们容易想到先把所有的元素取出来比较再删除最大的元素，但是这样的方式效率太低，那有没有这么一种方式能够实现这个目的而且效率又高呢？这时候我们就要学习优先队列了

![](WEBRESOURCEc8eba8c77d8b2db627b8e2c1e458a8e1)

优先队列按照作用不同可以分为两种队列，分别是最大优先队列和最小优先队列

![](WEBRESOURCE87c24b2057badaebc79ab796331ab707)



最大优先队列

我们首先先来实现最大优先队列，先来看看其API设计

![](WEBRESOURCE107d77e1deff108b10e0453e1e0f44ba)

为什么这里有数组？因为我们说过，队列可以用数组或者链表实现，我们这里用链表实现而已

那么根据API设计我们可以构造其代码如下

```javascript
package algorithm.sort;

//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class MaxPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public MaxPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列中是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i,int j) {
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //删除堆中最大的元素，并返回这个最大元素
    public T delMax() {
        T max = items[1];
        exch(1,N);
        N--;
        //此处和之前我们建立堆代码不同的是这里没有将值赋予null
        //而且直接将N--，其实是都可以的，因为我们没有进行赋予空
        //的值到最终还是会被覆盖的，没什么影响
        sink(1);
        return max;
    }

    //使用上浮算法，是索引k处的元素在堆中处于一个正确的位置
    private void swim(int k){
        while (k>1){
            if(less(k/2,k)){
                exch(k/2,k);
            }
            k = k/2;
        }
    }

    //使用下沉算法，是索引k处的元素在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k<=N){
            int max;
            if(2*k+1<=N){
                if(less(2*k,2*k+1)){
                    max=2*k+1;
                }else {
                    max=2*k;
                }
            }else {
                max=2*k;
            }

            if(!less(k,max)){
                break;
            }

            exch(k,max);

            k=max;
        }
    }
}
```

是不是有点眼熟？这其实不就是堆么？没错，其实最大优先队列的底层结构就是堆，可以简单理解为堆其实就是最大优先队列，又叫最大堆



最小优先队列

还记得当初我们说堆有什么性质吗？堆的性质有二，首先是堆的父节点必然大于等于子节点，其次是对于堆中在位置k的元素而言，2k与2k+1均为其子节点，那样的堆就是最大堆，也是最大优先队列

在最大堆里，我们使用上浮算法时是对我们指定要进行上浮算法的结点令其与父节点比较，若其比父节点大，那么就与父节点交换位置，这样循环往复直到其没有父节点或者比父节点小

而下沉算法则是先比较两个子节点谁大，挑出更大的那个，然后和父节点比较，若父节点比起小，则令其与父节点交换位置，这样不断循环往复

那么对于最小堆而言，它的第一个性质是反过来的，我们是把最小的元素放到最前面，所以父节点一定是小于等于子节点，第二个性质不变

而对于最小堆里的上浮算法，我们是指定结点令其与父节点比较，若其比父节点小，那么就与父节点交换位置，这样不断循环往复直到其没有父节点或者比父节点大

而对于最小堆里的下沉算法，我们是先比较两个子节点谁小，挑出更小的那个，然后和父节点比较，若其比父节点小，则与父节点交换位置，这样不断循环往复

那么我们最小堆的代码就可以构造如下

```javascript
package algorithm.sort;

//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class MinPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public MinPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列中是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i,int j) {
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //删除堆中最大的元素，并返回这个最大元素
    public T delMin() {
        T min = items[1];
        exch(1,N);
        N--;
        //此处和之前我们建立堆代码不同的是这里没有将值赋予null
        //而且直接将N--，其实是都可以的，因为我们没有进行赋予空
        //的值到最终还是会被覆盖的，没什么影响
        sink(1);
        return min;
    }

    //使用上浮算法，是索引k处的元素在堆中处于一个正确的位置
    private void swim(int k){
        while (k>1){
            if(less(k,k/2)){
                exch(k,k/2);
            }
            k = k/2;
        }
    }

    //使用下沉算法，是索引k处的元素在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k<=N){
            int min;
            if(2*k+1<=N){
                if(less(2*k,2*k+1)){
                    min =2*k;
                }else {
                    min =2*k+1;
                }
            }else {
                min =2*k;
            }

            if(less(k, min)){
                break;
            }

            exch(k, min);

            k= min;
        }
    }
}
```

其实，直接把compareTo方法的<改成>就可以了的，但是这样改动的话无法在代码上体现我们的思想，虽然说其实结果是一样的，但是不能不该耍这种小聪明，所以我们不这么构造，而是对一个个方法进行逐一改造



索引优先队列

之前我们讲了最大优先队列和最小优先队列，但是他们都有缺陷，其缺陷就是，我们无法对队列本身的元素进行修改，因为我们提供的方法里面都没有给予用户获取对应位置的元素的方法，所以元素都拿不到，元素都拿不到那修改个der。那为了解决这种缺陷，所以我们要学习索引优先队列

那么我们要怎么实现索引优先队列呢？首先我们应该要实现能够在队列里修改元素，这里我们以最小优先队列为例来实现索引优先队列，以后有兴趣可以自己用最大堆去实现下

先来看看其实现思路

![](WEBRESOURCEe16f77a30259f8d4853b7e2a360ed9cd)

简而言之是我们可以创建一个新数组来存放元素和元素的索引，每次我们插入元素时，我们不但要传入元素，还要传入索引才能够完成插入

![](WEBRESOURCE85ac49e1a415d018f4237380e127c22d)

可以看到插入完毕之后我们的数组就拥有了元素，而且有了索引，但是我们此时我们的数组是无序的，这不符合堆有序的特点，而如果我们的改造数组令其有序，那么索引又会乱，因此我们创造一个数组pq用于保存当前的索引

![](WEBRESOURCE5fbfa3d78711a593c3b143196fe1d1a0)

再来看看其图示

![](WEBRESOURCEd772cfef845de0ea2b5c3813feb0fd50)

那么此时我们的堆排序就可以用pq数组来表示了，此时pq数组就是存在父节点比子节点大于等于的关系的，当然了，这其实是一个抽象结构，实际上并不是这样的，但是我们可以这么理解

但是这样的堆还是有缺陷，比方说，如果我们修改S的值为H，那么修改之后进行上浮算法对整个堆进行再排序，这时候我们的pq的位置也是要进行相应的改变的，那么pq就应该要改变0的位置，但问题在于，我们要如何获得0在qp的索引呢？一个简单想法就是遍历获得其位置，但是问题在于，这样的效率是比较低的，那我们有什么其他的办法能够快速获取到pq中0位置处的索引吗？有。我们只要再构建一个辅助数组，让辅助数组存储pq的逆序就可以了，至于什么是逆序存储，请看图里的解释

![](WEBRESOURCE585eb1b9a859cc3fde4d32d818ca9918)

最后我们再来看看图里的演示

![](WEBRESOURCE430636a67157565101c7ceef9f76b6ea)

这样我们就可以通过pq数组迅速定位到0在pq中的索引了，这是一种典型的以空间换时间的做法，而且还不是递归，太爽了

那么现在我们来看看其API设计

![](WEBRESOURCE496251fb79bb8832a1ce10ba8e536de7)

根据API设计和上面的演示我们可以构造代码如下

```javascript
package algorithm.sort;

/*
 * 索引优先队列的实现原理是先创建一个数组用于存放元素和关联的索引，第一个数组里存放了元素，同时这个元素自带索引
 * 我们姑且称之为真索引，数组称为真数组，接着第二个数组用于保存真索引排序后的值，其中里面的值都有对应的真索引
 * 这个数组我们成为影数组，其索引我们称之为影索引，接着我们定义了第三个数组用于保存第二个数组的逆序情况，
 * 第三个数组里面的每一个值都是影索引，我们称该数组为逆数组，其索引为逆索引
 * 这三个数组发挥的作用各不相同，真数组的作用其实是为了让影数组能够通过其值来找到对应的元素，而影数组本身是
 * 堆的一种抽象结构，通过影数组可以实现最小索引队列的数据结构，而逆数组的作用主要是为了提高效率，逆数组的存在
 * 能够让我们快速找到影数组的值所在的索引，能够省去很多拉满效率和代码简洁性的操作
 */
//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class IndexMinPriorityQueue<T extends Comparable<T>> {
    //用于存储堆中的元素的真数组
    private T[] items;
    //保存每个元素在items数组里的索引，pq数组需要堆有序，也就是影数组
    private int[] pq;
    //保存qp的逆序，将pq的值作为其索引，将其索引作为值，也就是逆数组
    private int[] qp;
    //记录堆中元素的个数
    private int N;

    //构造方法
    public IndexMinPriorityQueue(int capacity){
        //由于影数组是代表堆结构，因此影数组的首索引的位置废弃不用，影数组的值需要+1，逆数组自然也要+1
        //而真数组需要+1的原因我暂且蒙在鼓里，我怀疑即使不+1也是可以的
        this.items = (T[]) new Comparable[capacity+1];
        this.pq = new int[capacity+1];
        this.qp = new int[capacity+1];
        this.N = 0;

        //默认情况下，逆数组中没有任何数据，则让逆数组的元素都为-1，代表不存在任何元素
        //这里之所以给-1而不是null的原因是因为如果给null，容易造成空指针异常
        for (int i = 0; i < qp.length; i++) {
            qp[i]=-1;
        }
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j) {
        return items[pq[i]].compareTo(items[pq[j]])<0;
        //我们要实际比较的元素必然是真数组里的元素，因此这里利用影数组来获得
        //真数组里的对应元素并比较，而不是直接比较影数组的值
    }

    /*
     * 这个方法只完成交换，不进行复原堆中有序性的操作，当然实际上堆中的有序性
     * 是需要保证的，但是，这不是我们这个方法应该要做的事情，因此这里没有调用
     * 相应的能够恢复堆中有序性的方法
     */
    //交换堆中i索引和j索引处的值
    private void exch(int i,int j){
        //交换影数组pq中的数据
        int tmp = pq[i];
        pq[i] = pq[j];
        pq[j] = tmp;
        //此处我们只交换索引的原因是我们的抽象堆结构是由影数组pq构建的
        //那么我们只需要调整抽象结构里的索引位置就能够达到我们调整抽象结
        //构中索引对应的元素交换位置的目的

        //更新qp中的数据，由于影数组pq进行交换，那么逆数组qp也要进行改变
        qp[pq[i]]=i;
        qp[pq[j]]=j;
        /*
         * 首先我们要知道，pq的值就是qp的索引，而pq的索引就是qp的值，其中
         * 是有着对应的关系的，如果我们修改pq中的值，那么qp中的值也要相应
         * 发生改变，而其改变的方法很简单，首先是找到pq的改变的值所对应的
         * 索引，利用该索引得到变化后的pq的值，该值同时也是qp的索引，那么
         * 我们利用该值定位到qp的索引所对应的值，将该值修改为pq的索引
         * 而这样做之所以能够正确的原理在于，既然在pq里修改了规定索引的值
         * 那么在qp里就要修改原先值所对应的索引的值，qp修改后的值应该要是
         * pq的原先的值所对应的新索引，因为这里是换位操作而不是简单的修改
         * 操作，所以不会发生没有对应索引的情况
         * 这有点套娃的感觉，不是很好理解，但细想之后是能够理解其意思的
         * 实在想不明白的话直接记结论得了
         */
    }

    //判断k对应的元素是否存在
    public boolean contains(int k) {
        return qp[k]!=-1;
        //这里能够这样构造代码来判断是因为我们先将qp逆数组全部赋值为-1
        //而在其他方法中，如果pq影数组索引k真的存放了对应元素，那么在
        //其逆数组pq里必然是做了对应动作令其不为-1的
    }

    //最小元素关联的索引
    public int minIndex() {
        return pq[1];
        //由于我们是最小堆，那么最小堆的pq的第一个索引所对应的值就是该最小元素关联的索引
    }

    //往队列中插入一个元素，并关联索引
    public void insert(int i,T t) {
        //判断i是否已经被关联，若是，则结束方法，不允许关联
        if(contains(i)){
            return;
        }
        //插入元素必然要让元素个数+1，这里先令其+1便于后面添加元素
        N++;
        //把数据存储到items对应的i位置处
        items[i] = t;
        //此处i代表的就是就是我们的真数组的索引，将真数组的索引存于影数组的最后一位
        //把i存储到pq中，直接存储到pq数组的下一位，这里其实也对应了堆的抽象结构，因为
        //我们平时往堆里添加元素也是直接在后面上添加的，所以这里直接添加到pq抽象结构
        //数组的末位，没有任何问题
        pq[N]=i;
        //令逆数组i处索引添加对应逆序值
        qp[i]=N;
        //存储之后堆的有序性被打破，那么就要恢复其有序性
        //通过上浮算法完成对堆的调整
        swim(N);
    }

    /*
     * 删除队列中最小元素的方法和我们之前给最小优先队列的删除方法差不多，都是先将最小的
     * 元素与最后一位元素交换位置之后删除最后一位元素然后调用下沉方法恢复堆的有序性
     * 但是不同的是这里由于有着影数组和逆数组的存在，因此我们在使用这种方法时要进行
     * 影数组和逆数组的对应修改
     */
    //删除队列中最小的元素，并返回该元素关联的索引
    public int delMin() {
        //获取最小元素关联的索引，pq的第一个存储的值就是对应的最小元素的索引
        int minIndex = pq[1];

        //交换pq中索引1处和最大索引处的元素
        exch(1,N);
        //先删除逆数组qp中对应的内容，这里之所以构造如下代码，是因为N代表pq最后一位的索引
        //其索引所对应的值就是qp的索引，既然我们在pq中删除了这个元素，
        //那么在qp中也应该要没有了对应该值的索引，但实际上索引肯定还在，因为索引没法删除
        //那么我们就在qp中将该元素的值赋值为-1，代表该索引不存在亦或是该索引还未指向任何元素
        qp[pq[N]] = -1;
        //元素交换后删除pq最大索引处的内容，赋予-1就代表删除的意思
        pq[N]=-1;
        //删除items中对应的内容，因为我们删除了元素，自然也删除了真数组
        //中对应的元素，因此要将真数组中原来存在的元素删除，这里我们前面
        //记录过最小元素关联的索引，因此我们用其进行删除操作，这里赋值为
        //null是因为真数组的类型是T[]，只能赋值null代表删除
        items[minIndex] = null;
        //元素个数-1
        N--;
        //对堆进行下沉算法，恢复其有序性
        sink(1);
        //返回被删除的最小元素的关联的索引
        return minIndex;
    }

    /*
     * 删除索引i关联的元素其实是上一个删除最小元素的方法大同小异，都是要先将元素交换
     * 然后删除结尾的元素，同时由于影数组和逆数组的存在，所以要先对逆数组影数组修改
     * 最后再轮到真数组，虽然我们交换的不是根结点，而是中间的结点，但是这是最小索引
     * 优先队列，数组前面的元素必然小于后面的元素，因此当我们调换位置时，交换的元素
     * 必然是最大的元素，此时只需要调用下沉方法就可以了，但是即使我们调用了上浮也无妨
     * 由于黑马写的代码里调用了上浮，因此我们这里保留上浮的代码
     */
    //删除索引i关联的元素
    public void delete(int i) {
        //找到i在pq中的索引
        int k = qp[i];
        //交换pq中索引k处的值和索引N处的值
        exch(k,N);
        //删除qp的内容
        qp[pq[N]] = -1;
        //删除pq中的内容
        pq[N] = -1;
        //删除items中的内容
        items[k] = null;
        //元素的数量-1
        N--;
        //堆的调整
        sink(k);//下沉
        swim(k);//上浮
    }

    /*
     * 这个直接修改的方法与前面交换的方法不同，直接修改无法判断其大小关系究竟如何
     * 因此要恢复其堆有序则需要分别调用下沉和上浮算法
     */
    //把索引i关联的元素修改为t
    public void changeItem(int i,T t) {
        //修改items数组中i位置的元素为t
        items[i] = t;
        //找到i在pq中出现的位置并记录为k
        int k = qp[i];
        //堆调整
        sink(k);
        swim(k);
    }

    /*
     * 私以为这里有问题，因为调用了上浮算法，改变的是影数组的位置，但实际上我们的逆数组的位置
     * 也应该要相应进行改变，但是这里并没有做这样对应的改变，因此我觉得这一段其实是有问题的
     * 同样也包括下面的下沉算法，都是存在这个问题的。但是由于黑马的代码里没有提，因此这里也
     * 不多做修改，就这样吧
     */
    //使用上浮算法，使索引k处的元素处于正确位置
    private void swim(int k) {
        while (k>1){
            if(less(k,k/2)){
                exch(k,k/2);
            }
            k = k/2;
        }
    }

    //使用下沉算法，使索引k处的元素处于正确位置
    private void sink(int k) {
        while(2*k<=N){
            //找到子结点中的较小值
            int min;
            if (2*k+1<=N){
                if (less(2*k,2*k+1)){
                    min = 2*k;
                }else{
                    min = 2*k+1;
                }
            }else{
                min = 2*k;
            }
            //比较当前结点和较小值
            if (less(k,min)){
                break;
            }

            exch(k,min);
            k = min;
        }
    }
}
```

有兴趣的话还可以去实现下最大索引优先队列