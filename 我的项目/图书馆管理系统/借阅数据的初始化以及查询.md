那么现在我们拉实现借阅管理这一功能，依旧是先分析代码，首先我们来看看写好的lend对象

```javascript
/*
    借书
 */
public class Lend {
    private int id;

    //借出的书籍
    private Book book;

    //借阅者
    private User user;

    //状态
    private String status;

    //出借日期
    private LocalDate lendDate;

    //归还日期
    private LocalDate returnDate;
```

可以看到这里的属性有id，借出书籍，借阅者，借阅状态以及出借日期和归还日期，都是基本的方法。

那么接下来我们要做的还是借阅数据的初始化，我们先到地址常量类定义新地址

```javascript
public static final String LEND_PATH = "lend/lend.txt";
```

接着我们到初始化方法里去实现初始化借阅管理的数据，我们可以写入如下代码

```javascript
//初始化借阅数据
List<Lend> lendList = new ArrayList<>();
User user = new User(1001,"张大虎",Constant.USER_OK,BigDecimal.TEN);
Book book = new Book(1,"java入门","张三",Constant.TYPE_COMPUTER,"123-1","机械工业出版社",Constant.STATUS_STORAGE);

Lend lend = new Lend();
lend.setBook(book);
lend.setUser(user);
lend.setStatus(Constant.STATUS_LEND);
LocalDate begin = LocalDate.now();
lend.setLendDate(begin);
//设置归还日期
lend.setReturnDate(begin.plusDays(30));
```

这里我们初始化借阅数据的方式是创建一个存放Lend借阅对象的集合（这个集合本身也是用来前台展示的，集合里存放lend对象，前台里取出这个集合的对象并展示），而lend本身需要存放User对象和Book对象，橙黄就对应的User对象和Book对象，然后创建Lend对象，将其设置，在归还日期的设置上，我们直接调用Lend对象里的LocalDate属性设置对应的日期，以及借出的时间，这里你设置的期限是30

但是这里还有一个问题，那就是我们这里借阅提供的id是int类型的，但是借阅是没有上限的，天天借阅指不定有一天就溢出了，所以我们要改成字符串类型的，然后给Lend类提供构造方法就完了

```javascript
//初始化借阅数据
List<Lend> lendList = new ArrayList<>();
User user = new User(1001,"张大虎",Constant.USER_OK,BigDecimal.TEN);
Book book = new Book(1,"java入门","张三",Constant.TYPE_COMPUTER,"123-1","机械工业出版社",Constant.STATUS_STORAGE);

Lend lend = new Lend();

//使用UUID生成编号
lend.setId(UUID.randomUUID().toString());

lend.setBook(book);
lend.setUser(user);
lend.setStatus(Constant.STATUS_LEND);
LocalDate begin = LocalDate.now();
lend.setLendDate(begin);
//设置归还日期
lend.setReturnDate(begin.plusDays(30));

lendList.add(lend);

initData(PathConstant.LEND_PATH,lendList);
```

可以看到我们这里使用UUID来生成编号，因为我们的编号是不可以让用户来自己设置的，否则可能会输入重复的编号，因此我们这里直接调用UUID方法，调用这个方法可以生成一个不会重复的编号，并转换为字符串然后赋值给lend对象的id就完了



借阅数据查询

那么接着我们来做借阅数据的查询，我们要首先要完成的是最简单的将硬盘的数据全部展示出来，同样要创建新的接口，同样要利用代码分层思想，先创建Dao接口并提供方法

```javascript
public interface LendDao {
    
    List<Lend> select(Lend lend);
    
}

```

实现方法

```javascript
/**
 * 查询
 * @param lend
 * @return
 */
@Override
public List<Lend> select(Lend lend) {
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.LEND_PATH));
        List<Lend> list = (List<Lend>) ois.readObject();
        if(lend == null || "".equals(lend.getId())){
            return list;
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    } finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return new ArrayList<>();
}
```

我们这里进行的判断是如果我们传入的lend对象是null或者其id为空字符串，则说明此时用户没有选中任何数据，此时我们返回List集合，即意味着程序将展示所有在硬盘中的lend对象

接着来实现service层接口，新创建一个接口并提供方法

```javascript
public interface LendService {
    List<Lend> select(Lend lend);
}
```

实现方法

```javascript
@Override
public List<Lend> select(Lend lend) {
    return lendDao.select(lend);
}
```

最后我们实现controller层

```javascript
@Override
public void initialize(URL location, ResourceBundle resources) {
    Book book = new Book(1, "java实战入门", "张三", Constant.TYPE_COMPUTER, "12-987", "XX出版社", Constant.STATUS_STORAGE);
    User user = new User(1, "张三", "正常", new BigDecimal(("100")));
    LocalDate now = LocalDate.now();
    lends.add(new Lend("1",book,user, Constant.LEND_LEND, now,now.plusDays(30)));

    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    //获取图书名称
    c2.setCellValueFactory((TableColumn.CellDataFeatures<Lend, String> p) ->
        new SimpleObjectProperty(p.getValue().getBook().getBookName())
    );
    c3.setCellValueFactory((TableColumn.CellDataFeatures<Lend, String> p) ->
            new SimpleObjectProperty(p.getValue().getBook().getIsbn())
    );
    c4.setCellValueFactory((TableColumn.CellDataFeatures<Lend, String> p) ->
            new SimpleObjectProperty(p.getValue().getUser().getName())
    );
    c5.setCellValueFactory(new PropertyValueFactory<>("lendDate"));
    c6.setCellValueFactory(new PropertyValueFactory<>("returnDate"));
    c7.setCellValueFactory(new PropertyValueFactory<>("status"));
    lendTableView.setItems(lends);

}
```

上面是原来的代码，可以看到我们最开始展现到界面上的内容就是我们这里你创建的代码，是固定不变的，现在我们要改成令其自动从硬盘上读取，那么修改代码如下

```javascript
private LendService lendService = new LendServiceImpl();

@Override
public void initialize(URL location, ResourceBundle resources) {

    //最开始必然是要展示所有界面，因此直接传入null
    List<Lend> Lendlist = lendService.select(null);
    lends.addAll(Lendlist);

    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    //获取图书名称
    c2.setCellValueFactory((TableColumn.CellDataFeatures<Lend, String> p) ->
        new SimpleObjectProperty(p.getValue().getBook().getBookName())
    );
    c3.setCellValueFactory((TableColumn.CellDataFeatures<Lend, String> p) ->
            new SimpleObjectProperty(p.getValue().getBook().getIsbn())
    );
    c4.setCellValueFactory((TableColumn.CellDataFeatures<Lend, String> p) ->
            new SimpleObjectProperty(p.getValue().getUser().getName())
    );
    c5.setCellValueFactory(new PropertyValueFactory<>("lendDate"));
    c6.setCellValueFactory(new PropertyValueFactory<>("returnDate"));
    c7.setCellValueFactory(new PropertyValueFactory<>("status"));
    lendTableView.setItems(lends);

}
```

其实就是调用了方法再把返回的集合传入而已，没干啥特别的