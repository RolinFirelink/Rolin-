- 二叉树的层序遍历

接下来，我们即将化身叶问，一次打十个！我们要利用一个层序遍历的迭代思路，通过改造达成一次解决十道题的成就。不过有一点我们要记住，那就是我们这里的重点在于递归的内容，递归的理解才是比较重要的，因为迭代太简单了。

先来看第一题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3a1c83349311b3da98389497ef7f7e86.png)

这题最简单的做法当然是迭代，以前我们也做过了，利用队列辅助解题，可以轻易实现层序遍历，请看代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            List<Integer> integers = new LinkedList<>();
            while (size-->0){
                TreeNode node = deque.pop();
                integers.add(node.val);
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
            }
            list.add(integers);
        }
        return list;
    }
}
```

然后让我们来看看递归的代码

```
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checkFun01(root,0);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }
}
```

我们可以看到这里递归的代码利用的deep参数来实现我们的层序遍历逻辑，这里第一点重要的是构造了新的代码用于递归，这个属于是基本技巧了。然后最妙的在于这个deep变量，初始时为0，意味着根结点的高度为1且初始时我们是在根结点的前一位的，每次到下一个结点时就让高度+1，然后判断我们的集合大小是否大于高度，小于则说明内部对应的集合没有创建出来，那么我们就创建并添加到我们的集合中，然后在利用deep集合的代表高度的特点，每次添加时都取出对应高度的集合并且将集合添加到其中，然后我们的递归顺序是从左到右，所以递归时先遍历左节点，后遍历右节点。

然后我们来看看第二题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf3a36607a3a449b5d8571797f64d14b0.png)

对于这一题，有一个取巧的办法就是先获得正常的遍历代码，然后反转结果就可以了。我们来看看代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            List<Integer> integers = new LinkedList<>();
            while (size-->0){
                TreeNode node = deque.pop();
                integers.add(node.val);
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
            }
            list.add(integers);
        }
        Collections.reverse(list);
        return list;
    }
}
```

官方的题解代码调用了list集合里的add的重载方法，该方法就是可以将元素添加到指定位置，如果该位置有元素就会将该位置的元素挤到后面去，其实本质说实话和我们上面这个差不多。

接下来我们来看看这个递归的代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        dfs(root,0);
        Collections.reverse(list);
        return list;
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(list.size()<deep){
            list.add(new LinkedList<>());
        }
        list.get(deep-1).add(root.val);
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

这递归的代码就不多说了，没啥值得说的

然后我们来看看第三题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf7658699eb491cef7c3493e35dc72dff.png)

我们先来看看迭代代码

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> rightSideView(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            while (size>0){
                 TreeNode node = deque.pop();
                 if(size==1){
                     list.add(node.val);
                 }
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
                size--;
            }
        }
        return list;
    }
}
```

迭代的逻辑是每次取每层的最后一个结点并将其加入到对应的集合中，也是比较容易实现的。

接下来我们来看看递归的代码

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> rightSideView(TreeNode root) {
        dfs(root,0);
        return list;
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(list.size()==deep-1){
            list.add(root.val);
        }
        dfs(root.right,deep);
        dfs(root.left,deep);
    }
}
```

这个递归的代码非常妙，虽然其总体逻辑和我们上面的差不多。其精妙之处的第一点在于其巧妙在于第13行代码，其利用了size大小的==的特点，保证了我们的结点总是只能加第一个，而且我们的将遍历顺序改成先从右遍历，再从左遍历，这就保证了每次都先取到右边的结点，这样就能获得我们的右边结点。同样的，我们先从左边遍历的话，也能获得全部的左边结点。

现在我们来看看第四题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd099142dc9cc872dd23c424bef0dfc4f.png)

先来看看迭代的代码

```
class Solution {
    List<Double> list = new LinkedList<>();
    public List<Double> averageOfLevels(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            int times = size;
            Double sum = 0.0;
            while (size-->0){
                TreeNode node = deque.pop();
                sum+=node.val;
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
            }
            sum/=times;
            list.add(sum);
        }
        return list;
    }
}
```

我们迭代的思路就是获得其全部的值然后除于他的总数罢了再加到我们的集合中，再来看看递归的代码

```
class Solution {
    List<Double> list = new LinkedList<>();
    List<Double> times = new LinkedList<>();
    public List<Double> averageOfLevels(TreeNode root) {
        dfs(root,0);
        for (int i = 0; i < list.size(); i++) {
            list.set(i,list.get(i)/times.get(i));
        }
        return list;
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(list.size()<deep){
            list.add(root.val*1.0);
            times.add(1.0);
        }else {
            list.set(deep-1,list.get(deep-1)+ root.val*1.0);
            times.set(deep-1,times.get(deep-1)+1.0);
        }
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

这里我们的递归利用了list里的set方法，可以利用该方法修改list中的值，我们创建两个list集合，一个用于记录总和，一个用于记录加入的次数，利用递归将讲个集合记录完毕，然后将两个集合进行对应的处理，就可以得到我们想要的结果

然后我们来看看第五题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE77b20bc82ef54bcf0ad2aeb572cdcbd7.png)

我们先来看看迭代的代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> levelOrder(Node root) {
        if(root==null) return list;
        Deque<Node> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            List<Integer> list = new LinkedList<>();
            while (size-->0){
                Node node = deque.pop();
                list.add(node.val);
                deque.addAll(node.children);
            }
            this.list.add(list);
        }
        return list;
    }
}
```

迭代的代码其逻辑其实还是没啥不同，就是两个while循环，每次循环其下一层的结点全部添加到队尾

然后我们来看看递归的代码

```
class Solution {
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> levelOrder(Node root) {
        dfs(root,0);
        return list;
    }

    private void dfs(Node root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(list.size()<deep){
            list.add(new LinkedList<>());
        }
        list.get(deep-1).add(root.val);
        for (Node node:root.children) {
            dfs(node,deep);
        }
    }
}
```

递归代码的逻辑跟之前的也差不多，无非是递归代码变成了利用foreach来进行递归罢了