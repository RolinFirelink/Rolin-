学习完了请求之后，我们接着来学习响应的相关内容。这也是springmvc中比较重要的一章，因此我们要认真学

- 页面跳转

我们先来回顾下我们的回顾的页面跳转，我们是通过返回值类型来进行页面的跳转的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6cce9f9231ead7ab6030e203ee506efd.png)

我们之前在Tomcat的章节中学习过，我们的页面跳转分为两种，一种是转发，另一种是重定向，那我们现在使用的这种方式的到底是重定向还是转发呢？以及我们要如何使用重定向以及转发呢？这是我们接下来的要解决的事情。

在正式学习之前我们要先搞清楚转发和重定向的区别，他们两者最简单的区别在于，使用转发时，我们的地址栏会是我们一开始输入的地址栏，而使用重定向的话，我们的地址栏最终会变为我们定向的位置的地址栏，我们默认的跳转页面的方式是转发方式。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE93826ff694d1d671ed56f9f6bc6ca1b5.png)

如果我们要使用转发方式的话，我们就在其返回的字符串前加入forward:，如果想要使用重定向，则用redirect:，注意我们这里在:的后面其实也可以继续追加我们的/符号的，就当没用过这个时候的用法来用就可以了

最后我们值得一提的是，转发的形式是可以访问我们的WEB-INF文件夹下的创建的页面的，而重定向不可以，因此如果我们想问访问该文件夹下的页面，应该要使用转发的方式来实现页面的跳转。同时如果我们要访问该文件夹下的页面，需要在返回的地址上添加其存放的子文件夹的路径，否则我们springmvc会无法找到。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEda3656fc96bebf3a12680183eef82036.png)

当然每次都要写一次这么长的路径未免太麻烦了，实际上我们也存在快捷设定，这个设定需要在springmvc的xml文件中去设置，这里需要使用到InternalResourceViewResolver类，利用该类添加我们的前缀和后缀，这样我们只需要返回对应的文件名称就完了，其实际执行的时候会自动将前缀和后缀拼接起来再去寻找

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb0c1200ca1cb515f34fb14af16b469d6.png)

那么我们只需要在对应的配置文件上写入代码如下

```
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/page/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

最后我们可以写入我们的代码如下

```
//页面简化配置格式，使用前缀+页面名称+后缀的形式进行，类似于字符串拼接
@RequestMapping("/showPage3")
public String showPage3() {
    System.out.println("user mvc controller is running ...");
    return "page";
}
```

这里值得一提的是，我们一旦使用的这种格式，那么我们默认就只能使用转发，而且我们不能在返回的字符串里去指定我们想要的页面跳转的方式

最后我们来讲讲最后一个跳转方式，如果我们将方法设置会无返回值，那么其就会默认使用访问路径作为页面地址的名字并拼接前缀后缀去查找，具体内容看图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE676803a8ec0bf8fe0db67dd1d17e858e.png)

- 带数据页面跳转

那么接着我们就要学习带着页面跳转的方法，我们的一个简单方法就是使用Servlet里的请求对象，设定对应的数据接受并返回到页面中

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE72c2fc25178fa1a61ffd6bd622e0a060.png)

那么我们可以构造我们的设置代码如下，同样类中还有注解，但是这里省略了

```
@RequestMapping("/showPageAndData1")
public String showPageAndData1(HttpServletRequest request) {
    request.setAttribute("name","itheima");
    return "page";
}
```

然后我们设置我们的页面响应代码如下，其实就是获取了对应的数据而已

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>
<html>
<body>
<h1>页面跳转测试中...sdfasdfa</h1>
info:${name}
</body>
</html>
```

最后我们经过测试会发现这个方法的确能够运行并使用

但是这种方式不是我们所推荐的，我们尽量就不要使用原来学习过的方式，因此这里我们要学习新的方式

我们的第二种跳转方式是使用Model类型的形参来进行数据传递，其内部使用的就是Request对象的方法，其不仅可以放简单类型的数据，还可以放引用类型的数据

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1f95fba78ec39a1cf60e3dc682696382.png)

那么我们按照上图的演示我们可以构造其代码如下

```
@RequestMapping("/showPageAndData2")
public String showPageAndData2(Model model) {
    model.addAttribute("name","Jock");
    Book book = new Book();
    book.setName("SpringMVC入门案例");
    book.setPrice(66.66d);
    model.addAttribute("book",book);
    return "page";
}
```

同时我们这里为了演示其还可以设置一个对象，因此我们这里要创建一个对应的对象的实体类，然后我们这里new一个对象并设置对应的值，然后我们在页面代码上填入我们的代码如下

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>
<html>
<body>
<h1>页面跳转测试中...sdfasdfa</h1>
info的名字:${name}<br/>
book:${book.toString()}
</body>
</html>
```

除了对象里的中文会乱码之外一切都好，这就说明我们的案例已经成功了

但是实际中这种方法仍然不是我们springmvc中最推荐的，因此我们还要学习第三种方法

第三种方式我们是使用ModelAndView的对象进行数据传递，这个对象跟我们以前学习架构的时候出现的对象结构一模一样，同样具有上一个方式的所有方法，那么model可以理解，但是view是什么呢？其实view就是视图，我们这里的对象是将视图也一并封装进去到对象里了，因此我们这里返回的对象也是直接返回该对象，因为该对象就包括视图，而不是返回某个字符串再进行查询到对应的视图然后再返回

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE650097cf72b4f085cd5a73731f414ede.png)

那么根据上图我们可以写入我们的代码如下

```
@RequestMapping("/showPageAndData3")
public ModelAndView showPageAndData2(ModelAndView modelAndView) {
    Book book = new Book();
    book.setName("SpringMVC入门案例");
    book.setPrice(66.66d);

    modelAndView.addObject("book",book);
    modelAndView.addObject("name","Jockme");

    modelAndView.setViewName("page");

    return modelAndView;
}
```

这里我们可以看到我们的数据是添加的，而视图是设置的，如果我们设置多个视图，那么就会以最后一个为准。我个人猜测这里我们传入page名称，其也会根据前后缀查询到对应的视图并将该视图的内容设置到该对象中并返回给用户用于展示。

如果我们希望返回使用重定向的话，那么也是跟之前的一样设定就好了，首先不使用前后缀的简写方式，然后自己在地址中写入想要的方式和对应页面的全路径名，接着就可以实现转发了，同样的，重定向也是无法重定向到WEB-INF文件夹内的页面的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe51de141b93086cacf64c365ed10eefd.png)

最后我们可以设置其代码如下

```
//ModelAndView对象支持转发的手工设定，该设定不会启用前缀后缀的页面拼接格式
@RequestMapping("/showPageAndData4")
public ModelAndView showPageAndData4(ModelAndView modelAndView) {
    modelAndView.setViewName("forward:/WEB-INF/page/page.jsp");
    return modelAndView;
}

//ModelAndView对象支持重定向的手工设定，该设定不会启用前缀后缀的页面拼接格式
@RequestMapping("/showPageAndData5")
public ModelAndView showPageAndData6(ModelAndView modelAndView) {
    modelAndView.setViewName("redirect:page.jsp");
    return modelAndView;
}
```

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfb91388420f7bfc6b0735a54a82779b7.png)

- 返回json数据

学习完了前两种方式之后，接着我们来讲我们的最重要的一节内容，返回json数据的方式来返回页面。

我们的第一种最简单的返回页面的方式自然是通过响应对象直接返回了，具体请看代码

```
@RequestMapping("/showData1")
public void showData1(HttpServletResponse response) throws IOException {
    response.getWriter().write("message");
}
```

但同样的，这是方式是我们所不推荐额，然后我们来看看我们的直接返回信息的方式，由于直接返回信息会找不到对应的返回页面，因此我们这里要额外加入ResponseBody注解，表示我们返回的信息会自己生成一个页面对象并直接返回用于展示

```
@RequestMapping("/showData2")
@ResponseBody
public String showData2() {
    return "message";
}
```

然后我们正式来学习整一个json的的字符串类型的数据，我们自己new一个ObjectMapper对象，传入对应的对象，其会自动生成一个json格式的字符串给我们

```
@RequestMapping("/showData3")
@ResponseBody
public String showData3() throws JsonProcessingException {
    Book book = new Book();
    book.setName("SpringMVC入门案例");
    book.setPrice(66.66d);

    ObjectMapper om = new ObjectMapper();
    return om.writeValueAsString(book);
}
```

当然，每次都要自己放进去就显得太麻烦了，而且还有乱码，我们以后肯定是希望由工具类帮助我们完成json格式数据的展示的，因此我们这里要引入json工具类的依赖

```
<!--json相关坐标3个-->
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-core</artifactId>
  <version>2.9.0</version>
</dependency>

<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.9.0</version>
</dependency>

<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-annotations</artifactId>
  <version>2.9.0</version>
</dependency>
```

然后我们开启对应的注解驱动，注意这是在spring-mvc配置文件中的代码，这点不要忘了，不启动对应的注解驱动连注解都用不了

```
<mvc:annotation-driven/>
```

然后我们可以写入其代码如下

```
@RequestMapping("/showData4")
@ResponseBody
public Book showData4() {
    Book book = new Book();
    book.setName("SpringMVC入门案例");
    book.setPrice(66.66d);

    return book;
}
```

接着在对应的页面上就会展示出json格式的字符串了，这里我们传入了对象，而我们又引入了对应的json格式的依赖，因此我们的json的工具类会发挥其作用，将我们的对象转换为我们想要的字符串格式，Book转成String是我们的json导入的依赖工具类里所完成的事

当然，我们也可以展示集合

```
@RequestMapping("/showData5")
@ResponseBody
public List<Book> showData5() {
    Book book1 = new Book();
    book1.setName("SpringMVC入门案例");
    book1.setPrice(66.66d);

    Book book2 = new Book();
    book2.setName("SpringMVC入门案例");
    book2.setPrice(66.66d);


    List<Book> list = new ArrayList<>();
    list.add(book1);
    list.add(book2);
    return list;
}

```

最后我们可以来看一些总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5f4128dccb5866672bdfe6b783a66012.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE23bac7369d4783652b42c57436b3b2c2.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc2ccb4b01729fd4680c257b061a5d996.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf3a9e3d04d02178065a73c6b5be32313.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE226f0b94361345e59975649a5aeaced8.png)

- Servlet相关接口

本节我们来了解springMVC中的有关于Servlet相关接口的方法，首先在springmvc中提供了原始的Servlet接口API的功能，我们可以通过形参直接声明并调用来使用这些方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE549d1595714adffa8ea3159d6c41acc6.png)

那么我们可以构造其代码如下

```
//获取request,response,session对象的原生接口
@RequestMapping("/servletApi")
public String servletApi(HttpServletRequest request, HttpServletResponse response, HttpSession session){
    System.out.println(request);
    System.out.println(response);
    System.out.println(session);
    return "page";
}
```

但是我们都知道，直接操纵Servlet的对应方法不是springmvc所推荐的，因此在springmvc中提供了RequestHeader的注解，用于获取请求头的消息内容，只需要在传入参数中使用该注解并传入对应的请求头的字符串即可，但是记得我们需要开启注解驱动，否则该注解无法发挥作用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE19bf859fb6c4a59583b564dd5bdf53c8.png)

那么根据上图我们可以写入代码如下

```
//获取head数据的快捷操作方式
@RequestMapping("/headApi")
public String headApi(@RequestHeader("Accept-Encoding") String headMsg){
    System.out.println(headMsg);
    return "page";
}
```

如果我们想要获取Cookie的缓存中的参数的话，则需要使用CookieValue注解，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE84b4036f6f2b83e2cb77a84a928f92d7.png)

那么我们可以构造我们的代码如下，这里我们是获取JSESSIONID的id

```
//获取cookie数据的快捷操作方式
@RequestMapping("/cookieApi")
public String cookieApi(@CookieValue("JSESSIONID") String jsessionid){
    System.out.println(jsessionid);
    return "page";
}
```

然后我们可以可以获取Session共享域中的数据，不过对于这种共享域，我们拿到里面的数据之前要先往里面设定对应的数据才可以，否则会报错，我们这里设置数据就直接调用对应的Session的set方法来设置了，虽然不合规范，但是能用就行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8f8b24b19cc2bc7fdd428515c8f41ce8.png)

那么我们可以构造设置的代码如下，获取的演示代码我们后面一起演示

```
//测试用方法，为下面的试验服务，用于在session中放入数据
@RequestMapping("/setSessionData")
public String setSessionData(HttpSession session){
    session.setAttribute("name","itheima");
    return "page";
}
```

实际上我们数据设置还有一种方式，就是用SessionAttributes注解，具体方式是在对应类上面加入该注解并在括号中指定我们要添加的数据的名字，这样我们后面添加数据时，只要用了相同的名字，其就可以通过SessionAttribute注解进行获取。同时使用该注解时，我们要设置数据是要使用model对象来设置的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEef56ba98e94060485eadc71938c810a0.png)

首先我们往我们的类中加入我们开头注解并设定对应的数据名

```
//设定当前类中名称为age和gender的变量放入session范围，不常用，了解即可
@SessionAttributes(names = {"age","gender"})
```

然后我们写入对应的设置参数的方法

```
//配合@SessionAttributes(names = {"age","gender"})使用
//将数据放入session存储范围，通过Model对象实现数据set，通过@SessionAttributes注解实现范围设定
@RequestMapping("/setSessionData2")
public String setSessionDate2(Model model) {
    model.addAttribute("age",39);
    model.addAttribute("gender","男");
    return "page";
}
```

最后我们再写入我们获取对应的数据的注解到形参中，然后在方法中对对应的数据进行打印

```
//获取session数据的快捷操作方式
@RequestMapping("/sessionApi")
public String sessionApi(@SessionAttribute("name") String name,
                         @SessionAttribute("age") int age,
                         @SessionAttribute("gender") String gender){
    System.out.println(name);
    System.out.println(age);
    System.out.println(gender);
    return "page";
}
```

实际测试之后我们发现这个是可以使用的，是没有问题的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa96535f0b77ccfb7d59bd2e4a391f681.png)

最后我们来说说我们的注解式参数封装原理，其实他的本质还是调用我们的最初的Servlet的方法，只不过是对其进行了封装，然后我们就无法直接调用其最本质的方法，只能调用外面的方法了，同时其是使用顶层接口HandlerMethodArgumentResolver及其其下的许许多多的实现类来达成对应的目的的