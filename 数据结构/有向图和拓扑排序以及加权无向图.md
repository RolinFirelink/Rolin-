学习完了无向图之后，我们接着来学习有向图，所谓有向图，其实有无向图中点与点之间的边多了方向而已，我们先来学习下有向图的相关术语吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15c1396e6a0204796293b5ac6124506b.png)

不多谈啊，这个定义都是适记性的知识，没啥特别值得讲的。而一副有向图中两个顶点v和w可能存在以下四种关系

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8d54941339aa57a1f310bd69c1edd891.png)

那么接着我们当然就要来实现有向图了，先来看看有向图的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7eef0f9ed433a5f6938ccecac0bd172d.png)

这里的添加边的方法addEdge的设计思路和无向图有一点不同，那就是在无向图里我们既可以说是v指向w，也可以说是w指向v，但是在有向图里我们只能说是v指向w，因此我们只让w出现在v的邻接表中，而不让v出现在w的邻接表中，这与无向图里让两个点互相出现在对方的邻接表中有所不同

其次是这里我们又一个获取该图的反向图的reverse方法，这个方法的作用我我听不太懂，总之可以确定其作用是为了便于有向图的使用

那么综上我们可以构造代码如下

```javascript
package algorithm.sort;

public class Digraph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;

    //构造方法
    public Digraph(int V){
         //初始化顶点数量
        this.V = V;
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }

    }

    //获取顶点数目
    public int V(){
        return V;
    }

    //获取边的数目
    public int E(){
        return E;
    }

    //向有向图中添加一条边v->w
    public void addEdge(int v, int w){
         //只让顶点w出现在顶点v邻接表中
        adj[v].enqueue(w);
        //边数+1
        E++;
    }

    //获取由v指出的边所链接的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];
    }

    /*
     * 获取该图的反向图无非要做两点，第一点是将创造一个有向图对象用于
     * 记录该反向图，第二点是实现边的反向指向。实现反向指向的方法很简
     * 单，遍历原有向图的每一个顶点的邻接表，每找到一个顶点在该顶点里
     * 就说明该顶点对邻接表里的顶点有指向，我们在反向图里只要让邻接表
     * 里的顶点指向该代表该邻接表的顶点就可以了
     */
    //该图的反向图
    private Digraph reverse(){
        //创建和原图有相同顶点的有向图对象
        Digraph r = new Digraph(V);
        //遍历所有顶点
        for (int v = 0; v < V; v++) {
            //遍历所有顶点的邻接表
            for (Object w: adj[v]) {
                //令邻接表内的顶点指向代表该邻接表的顶点
                r.addEdge((Integer) w,v);
            }
        }
        //返回我们所创建的反向图
        return r;
    }
}

```



拓扑排序

在学习拓扑排序之前，我们首先当然要对拓扑排序进行一个介绍，什么是拓扑排序呢？我们可以以一个java路线图来进行说明

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE99f4b176b4bce80e2979f5c1f177f979.png)

上图就是我们的一个简略的java简单的路线图，这里我们必然是先学java基础，后面再来学习我们所需要的框架那些，我们无法先学框架，因为我们只有先学了java基础，才能看得懂框架的内容，因此这里的路线图是有优先级的，越左边的内容优先级越高，我们可以将其简化为下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf0314c7073b0f565b09c8459fe6e795d.png)

此时如果有一个同学想要直观地知道学习这些课程的顺序，要求课程按线性排列，那么我们就需要对图进行排序，这里就用得到我们的拓扑排序

那么现在我们就可以确定拓扑排序的作用了，拓扑排序能够将有向图的所有顶点排序，使得所有有向边均从前面的元素指向排在后面的元素，此时就可以明确表示出每个顶点的优先级，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEab262c1a7510ecd075678129292f6712.png)

那么上图就是我们经过拓扑排序之后得到的线形图，可以看到此时我们的优先级是从上往下依次递减的，而且前面的元素均指向后面的元素



检测有向环

但是我们使用拓扑排序前有一件事情需要注意，就是我们的有向图里是不能有环的，因为有环的有向图其优先级是无法判别的，我们的拓扑排序的使用是必须要保证我们的有向图里无环才可以使用的，因此我们要先设计检测有向图是否有环的方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE639effe87201a33c9cdbf738af32e738.png)

我们可以来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaff85639e30dae82726a94e80ecd68ee.png)

在实现这个API之前，我们先来讲讲我们是如何利用栈的思想构建onStack数组来确定有向图中是否有环的具体过程，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0c4a309897fa6b97a130be68f293dd40.png)

可以看到我们的onStack数组的原始状态是全为false的，此时代表还没有任何一个结点被检测过，我们首先从3开始搜索，那么3进栈，将索引3的值赋值为true，同理继续搜索0，将索引0赋为true，然后最后我们最搜索到0出，会发现此时0已经是true了，那么此时就停止遍历，立刻结束方法并判断该有向图中有环就可以了

我们这里不要求我们找出环的起点，也不要求我们找出有向图有几个环，我们只要能够确定其有环就可以了

那么综上我们可以构造代码如下

```javascript
package algorithm.sort;

public class DirectedCycle {
    //索引代表顶点，值代表当前顶点是否已经被搜索
    private boolean[] marked;
    //记录图中是否有环
    private boolean hasCycle;
    //索引代表顶点，使用栈的思想，记录当前顶点是否已经处于正在搜索的有向路径上
    private boolean[] onStack;

    /*
     * 这里之所以要传入每一个顶点作为入口是因为我们的有向图可能是一个非联通图
     * 此时不传入所有顶点作为入口查找的话可能会查找不到有向环，而每次都要进行
     * 当前顶点是否已经被搜索的判断是为了避免重复搜索的情况，可以提升我们的程
     * 序的运行效率
     */
    //创建一个检测环对象，检测图G中是否有环
    public DirectedCycle(Digraph G){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化hasCycle
        this.hasCycle = false;
        //初始化onStack数组
        this.onStack = new boolean[G.V()];

        //找到图中每一个顶点，让每一个顶点都作为入口调用dfs方法进行搜索
        for (int v = 0; v < G.V(); v++) {
            //如果当前顶点没有被搜索过则调用dfs进行搜索
            if(!marked[v]){
                dfs(G,v);
            }
        }
    }

    /*
     * 这个方法我不理解的是为什么最后要将顶点出栈，在我的演示里我认为即使不出栈
     * 也是没有任何问题的，但是在视频里又没有测试环节，所以我也不能够测试最后的
     * 这个出栈代码有什么必要性，所以先这样的，以后时间我自己再构造测试代码试试
     * 试了下，删除会造成空指针异常，给我整不会了
     */
    //利用深度优先搜索检测图G中是否有环
    private void dfs(Digraph G, int v){
        //把顶点v标记为已搜索
        marked[v] = true;
        //把当前顶点进栈
        onStack[v] = true;
        //进行深度搜索
        for (Object w: G.adj(v)) {
            //若当前顶点w没有被搜索过，则递归调用dfs方法进行深度优先搜索
            if(!marked[(int) w]){
                dfs(G, (Integer) w);
            }

            //若当前顶点已经在栈中，证明之前已经搜索过了，现在又要再搜索一次，说明有环
            if(onStack[(int) w]){
                hasCycle = true;
                return;//检测到环就立刻结束方法
            }
        }
        //把当前顶点出栈
        onStack[v] = false;
    }

    //判断有向图中是否有环
    public boolean hasCycle(){
        return hasCycle;
    }
}
```



顶点排序

在实现拓扑排序之前，我们可以先对拓扑排序进行分解，我们可以轻易地看到，进行拓扑排序时我们应该先将顶点按照顺序从上往下排列，这其实就是顶点排序，我们在实现拓扑排序前，应该要先实现顶点排序，我们先来看看顶点排序的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7265ad6b43b6d1680ffdbee616b6418f.png)

我们这里进行顶点排序要用到栈的思想，接下来我们来具体讲讲我们是如何利用栈的思想来实现顶点排序的，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE80a82276e5c04752d6d3fab30623054d.png)

我们以0位顶点，先利用深度优先搜索不断定位其子节点，先定位到5，由于5没有任何的子节点，也没有兄弟结点，因此5先入栈，同时回到4,4中除了5之外也没有任何的子节点和兄弟结点，因此4入栈，接着回到2，2除了4这个子节点外没有其他的子节点，因此2入栈，接着到2的兄弟结点3，3入栈，接着回到0,0的两个子节点都遍历完了，则0入栈，此时以0为起点的深度优先搜索就完了，接着我们用1结点作为起点进行深度优先搜索，由于其子节点3已经搜索过了，因此我们将1结点入栈（这里其实还有2,3,4,5一个个作为起点的过程，不过我们省略了，因为这些结点都已经搜索过了，即使把他们当做起点进行搜索，到最后也是会无法进入搜索方法的），至此，我们的所有结点就入栈完毕了，而且是与我们的当初拓扑排序的优先级队列是一样的（不过我觉得这里有BUG，万一我是先放1的话那不是不符合了吗？只能说其应该是默认从小到大开始放令结点作为起点进行搜索吧）

综上我们可以构造代码如下

```javascript
package algorithm.sort;

public class DepthFirstOrder {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //使用栈，存储顶点序列
    private Stack<Integer> reversePost;

    //创建一个检测环对象，检测图G中是否有环
    public DepthFirstOrder(Digraph G){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化reversePost栈
        this.reversePost = new Stack<Integer>();

        //遍历图中的每一个顶点并令其作为入口完成深度优先搜索
        for (int v = 0; v < G.V(); v++) {
            //若没被搜索过则作为起点调用深度首先搜素方法
            if(!marked[v]){
                dfs(G,v);
            }
        }
    }

    //基于深度优先搜索将顶点排序，排序后顶点放入栈中
    private void dfs(Digraph G, int v){
        //标记当前v已经被搜索
        marked[v] = true;
        for (Object w: G.adj(v)) { 
            //如果当前顶点w没有搜索，则递归调用dfs方法进行搜索
            if(!marked[(int) w]){
                dfs(G, (Integer) w);
            }
        }
        //遍历完该点的邻接表后令顶点v进栈
        reversePost.push(v);
    }

    //获取顶点线性序列
    public Stack<Integer> ReversePost(){
        return reversePost;
    }
}

```



拓扑排序

那么经过了前面的学习，现在我们要实现拓扑排序就比较简单了，首先我们先判断一个有向图有没有环，若无环我们则调用顶点排序就可以了。

那么我们来看看拓扑排序的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbcff40f7448ad3cde015fb65cbc7b933.png)

那么根据API我们可以构造如下代码

```javascript
package algorithm.sort;

public class TopoLogical {
    //顶点的拓扑排序
    private Stack<Integer> order;

    //构造拓扑排序对象(构造方法)
    public TopoLogical(Digraph G) {
        //创建一个检测有向环的对象
        DirectedCycle cycle = new DirectedCycle(G);
        //如果没有环则进行顶点排序——创造一个顶点排序对象
        if(!cycle.hasCycle()){
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);
            //将排序好的栈赋给order
            order = depthFirstOrder.reversePost();
        }
    }

    //判断图G是否有环
    private boolean isCycle(){
        //若其不为null则说明if语句成功执行了，则说明没有环
        return order==null;
    }

    //获取拓扑排序的所有顶点
    public Stack<Integer> order(){
        //返回排序好的栈对象
        return order;
    }
}
```

最终经过测试发现我们构造的代码没有任何问题



加权无向图

所谓加权无向图，简而言之就是给无向图的边加上距离或金钱属性，使我们的边具有属性，比方说，两个城市之间是连通的那么就有边，我们可以给边加上距离属性，那么就可以通过这个属性来计算距离，最终给用户导出一个从一个城市到另一个城市的最佳路径

在这里我们加上的属性就是权重，具体的解释请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE355f8291c26fdbc1d74181c74d4402f7.png)

那么由于我们这里边时有权重的，那么我们表示边时就要用一个对象来去表示，当然我们要去构造这么一个类出来，让我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfc69b258fc4a547399777b9b1f3bbc41.png)

那么根据API设计我们可以实现加权边的代码如下

```javascript
package algorithm.sort;
//加权边需要比较，因此要实现Comparable接口并提供比较方法
public class Edge implements Comparable<Edge>{
    private final int v;//顶点一
    private final int w;//顶点二
    private final double weight;//当前边的权重

    //通过顶点v和w以及权重weight构造一个边对象(构造方法)
    public Edge(int v,int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取边上的一个点
    public int either(){
        return v;
    }

    //获取边上除了顶点vertex外的另外一个顶点
    public int other(int vertex){
        //如果是v顶点则返回w，不是则返回v
        if(vertex==v){
            return w;
        }else {
            return v;
        }
    }

    //重写父类方法提供比较规则
    @Override
    public int compareTo(Edge that) {
        int cmp;//记录比较的结果
        if(this.weight()>that.weight()){
            //如果当前边的权重大，则让cmp=1
            cmp = 1;
        }else if(this.weight()<that.weight()){
            //如果当前边的权重大，则让cmp=-1
            cmp = -1;
        }else {
            //一样大则令cmp=0
            cmp = 0;
        }
        return cmp;
    }
}
```

那么实现了加权边之后，现在我们来实现加权无向图，先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4d4152dbf3c06e72a684bdb061095880.png)

这里值得一提的是我们这里的泛型不是Interger类型的，而是我们自己定义的加权无向边Edge类型的，这是因为在加权无向图里的边都是加权无向边，而加权无向边并不是单纯的Interger类型的，而是由用户自己定义的属性的，因此这里泛型里填写Edge

那么我们可以构造代码如下

```javascript
package algorithm.sort;

public class EdgeWeightedGraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表，这里存储的对象是Edge，这里邻接表内不再存储另一个结点的值，而是存储边的权重
    //同样的，相同的权重也会出现在边所连接的两个顶点上
    private Queue<Edge>[] adj;

    //创造一个含有V个顶点的空加权无向图
    public EdgeWeightedGraph(int V){
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Edge>();
        }
    }

    //获取图中顶点的数量
    public int V() {
        return V;
    }

    //获取图中边的数量
    public int E() {
        return E;
    }

    /*
     * 这里我们创造加权无向边的方式是先创建Edge对象边，一条边里有两个结点
     * 然后在这个方法里获取到这两个结点，再将这两个结点分别加入到其邻接表
     * 中，相当于我们是先创建了两个结点和属性，然后这里是将结点连起来并
     * 赋予其属性值
     */
    //向加权无向图中添加一条边e
    public void addEdge(Edge e) {
        //加权无向图还是无向图，因此添加方式区别不大
        int v = e.either();//获得一个点
        int w = e.other(v);//获得另一个点

        adj[v].enqueue(e);
        adj[w].enqueue(e);

        //边的数量+1
        E++;
    }

    //获取和顶点v关联的所有边
    public Queue<Edge> adj(int v) {
        return adj[v];
    }

    /*
     * 此处我们令边只添加一次的方法是比较两个结点的值，如果一个结点值小于另一个则添加
     * 如果不小于则不添加。这个方法的实现前提是每一个结点的值都必不相同且按照顺序递增
     * 我猜测我们这里把<改成>也是可以实现我们的需求的
     */
    //获取加权无向图的所有边
    public Queue<Edge> edges() {
        //创建一个队列对象用于存储所有加权边
        Queue<Edge> allEdges = new Queue<>();

        //遍历图中每一个顶点的邻接表，每一个顶点的邻接表中存储了该顶点关联的每一条边
        //因为这是无向图，所以同一条边会出现在它关联的两个顶点中，而我们只需要让一条
        //边记录一次就可以了
        for (int v = 0; v < V; v++) {
            //遍历v顶点的邻接表，找到每一条和v关联的边
            for (Object e: adj(v)) {
                Edge E = (Edge) e;
                if(E.other(v)<v){
                    allEdges.enqueue(E);
                }
            }
        }
        return allEdges;
    }
}

```

