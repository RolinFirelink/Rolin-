然后我们来看看第六题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd24950067d50cf758b793c8aede244eb.png)

先来看看迭代代码：

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> largestValues(TreeNode root) {
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            int max = Integer.MIN_VALUE;
            while (size-->0){
                TreeNode node = deque.pop();
                max = Math.max(node.val,max);
                if (node.left!=null) deque.add(node.left);
                if (node.right!=null) deque.add(node.right);
            }
            list.add(max);
        }
        return list;
    }
}
```

迭代代码的思路时每次遍历时取到每层的最大值，然后将该最大值加入到集合中，最后得到我们需要的集合

再来看看递归代码

```
class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> largestValues(TreeNode root) {
        dfs(root,0);
        return list;
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(list.size()<deep){
            list.add(root.val);
        }else {
            list.set(deep-1,Math.max(list.get(deep-1),root.val));
        }
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

递归代码的逻辑也和之前一样，只是这一每次都将最大值添加到我们的对应集合中

接着我们来看看第七题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2e0016deef86be6f9e0463ffaa357f37.png)

我们先来看看迭代代码：

```
class Solution {
    public Node connect(Node root) {
        if(root==null) return null;
        Node ans = root;
        Deque<Node> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            while (size-->0){
                Node node = deque.pop();
                if(size!=0){
                    Node node2 = deque.peek();
                    node.next=node2;
                }else {
                    node.next=null;
                }
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
            }
        }
        return ans;
    }
}
```

迭代代码利用了队列实现，每次循环获得队列的第一个结点和下一个结点，每层每层的处理，只要没到达该层的最后一个结点，那么就不断弹出结点并令其指向下一个结点，如果到了，那么就将该结点赋为null，最后可以完成我们的修改

接下来我们来看看递归代码

```
class Solution {

    Node[] nodes = new Node[13];
    public Node connect(Node root) {
        dfs(root,0);
        return root;
    }
    
    private void dfs(Node root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(nodes[deep-1]!=null){
            nodes[deep-1].next=root;
        }
        nodes[deep-1]=root;
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

递归代码创建了一个结点数组辅助解题，其思路是结点数组每次保存对应层的第一个结点值，如果该层还没有结点，那么就将该结点加入队列，若已经有结点了，那么就将该数组中的结点的next指向下一个结点，并将该结点更新到数组中，deep在这里的作用是指代层数，用于将结点正确加入到对应的数组中。其实这样做有种用数组去模拟栈的这样一种感觉

不过我们上面的递归代码还是以层为思路进行的遍历的，实际上，我们还有更加精妙的递归思路，请看代码

```
class Solution {
    public Node connect(Node root) {
        if(root == null || root.left == null)
            return root;
        root.left.next = root.right;
        if(root.next != null){
            root.right.next = root.next.left;
        }
        connect(root.left);
        connect(root.right);
        return root;
    }
}
```

这个递归代码的精妙在于，其第三行代码直接判断自身和左节点是否为空来决定要不要结束，能这样做是因为题目规定了其为完全二叉树。接着其直接进行了左子节点的next指向右子节点的动作，这是基本的操作。但是接下来才是最精妙的部分，其直接通过该结点查看其next下结点是否为空，若不为空就直接进行该next下结点的左子节点被其自身的右子节点的next指向的动作。这里运用了两点来保证这个代码能够正确执行，一是这是个完全二叉树，这就表明了只要root的next不为空，则其必然有左子节点，二是由于第5个代码的执行，保证了next的指向不总是为null，可谓是精妙之至。无敌我只能说！

然后我们来看看第八题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE54dc9ac0182267e8836ee20d44683ca3.png)

与第七题不同的是，这题没有完全二叉树的条件了，而且有进阶解法，需要用常数空间来完成

我们先来看看迭代的代码

```
class Solution {
    public Node connect(Node root) {
        if(root==null) return null;
        Node ans = root;
        Deque<Node> deque = new LinkedList<>();
        deque.add(root);
        while (!deque.isEmpty()){
            int size = deque.size();
            while (size-->0){
                Node node = deque.pop();
                if(size!=0){
                    Node node2 = deque.peek();
                    node.next=node2;
                }else {
                    node.next=null;
                }
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
            }
        }
        return ans;
    }
}
```

迭代的代码其实和上一个一模一样了，因为根本都不需要更换代码其实，没有必要我只能说。

接下来我们来看看递归的代码

```
class Solution {

    Node[] nodes = new Node[1000];
    public Node connect(Node root) {
        dfs(root,0);
        return root;
    }

    private void dfs(Node root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(nodes[deep-1]!=null){
            nodes[deep-1].next=root;
        }
        nodes[deep-1]=root;
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

递归的代码同样也是可以用的，不过我们的数组的长度要加大。可以看到唯一输麻了的只有最精妙的递归解法，但是即使如此，我们还是有非常精妙的解法，请看代码

```
class Solution {
    public Node connect(Node root) {
        if(root==null) return root;
        if(root.left!=null && root.right!=null){
            root.left.next=root.right;
        }
        if(root.left!=null && root.right==null){
            root.left.next=getNext(root.next);
        }
        if(root.right!=null)
            root.right.next=getNext(root.next);
        connect(root.right);
        connect(root.left);
        return root;
    }

    public Node getNext(Node root){
        if(root==null) return null;
        if(root.left!=null) return root.left;
        if(root.right!=null) return root.right;
        if(root.next!=null) return getNext(root.next);
        return null;
    }
}
```

不过这个就只做了解了，不解释了，没什么必要，有兴趣的自己去看看吧

然后我们来看看第九题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9fb2b53dfb1a142c5cefd07f4236f2c7.png)

先来看看迭代代码

```
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        int depth = 0;
        while (!deque.isEmpty()){
            int size = deque.size();
            while (size-->0){
                TreeNode node = deque.pop();
                if(size==0){
                    depth++;
                }
                if(node.left!=null) deque.add(node.left);
                if(node.right!=null) deque.add(node.right);
            }
        }
        return depth;
    }
}
```

迭代代码其实就是每次遍历每一层，当每一层到达最后一个结点时添加让层数+1，最后返回层数

然后我们看看递归的代码

```
class Solution {
    int maxDepth = 0;

    public int maxDepth(TreeNode root) {
        dfs(root, 0);
        return maxDepth;
    }

    public void dfs(TreeNode root, int deep) {
        if (root == null){
            return;
        }
        deep++;
        maxDepth = Math.max(deep,maxDepth);
        dfs(root.left, deep);
        dfs(root.right,deep);
    }
}
```

递归的代码本身也没有太多变化，也是不断记录我们的最大深度，最后返回这个最大深度。最开始我们解题还卡死了，就是因为出现了返回值int，搞得无所适从，其实我们的记录最大深度的变量可以定义为成员变量的，没必要非要用deep返回一个我们所需要的变量来

最后这个代码其实可以在一行内解决，请看代码

```
class Solution {
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

这行代码的原理就是利用了三元运算符，设叶结点的高度为0，每次只要能成功进入一个，就让高度+1，最后返回高度最高的数、

不过其实我们这里还可以利用回溯来做，回溯其实也是递归的一种，不过其是会返回最后面的信息给上一层结点，然后上一层结点会利用这个信息进行判断，来看看回溯的代码

```
class Solution {
    int ans;
    public int maxDepth(TreeNode root) {
        ans = 0;
        if(root==null) return ans;
        getDepth(root,1);
        return ans;
    }

    private void getDepth(TreeNode root, int deep) {
        ans = Math.max(ans,deep);
        if(root.left==null && root.right==null){
            return;
        }
        if(root.left!=null){
            deep++;
            getDepth(root.left,deep);
            deep--;
        }
        if(root.right!=null){
            deep++;
            getDepth(root.right,deep);
            deep--;
        }
        return;
    }
}
```

可以看到我们这里先将deep++，因为我们要令深度+1，但是当我们回来的时候，我们又需要让深度-1，这是因为回溯算法要求我们所需要的东西在原本的那一层里是不变的，我们进入下一次时执行了+1的操作，那么返回时就要进行-1的动作。实际上这个代码还可以改良，就是将++和--的两个代码合并，请看合并的代码

```
class Solution {
    int ans;
    public int maxDepth(TreeNode root) {
        ans = 0;
        if(root==null) return ans;
        getDepth(root,1);
        return ans;
    }

    private void getDepth(TreeNode root, int deep) {
        ans = Math.max(ans,deep);
        if(root.left==null && root.right==null){
            return;
        }
        if(root.left!=null){
            getDepth(root.left,deep+1);
        }
        if(root.right!=null){
            getDepth(root.right,deep+1);
        }
    }
}
```

可以看到合并的代码就是将+1的动作放到我们的递归代码中了，这就相当于是我们将代码+1传入，当回来时+1的动作又不复存在了，这就将两个代码合并起来了，就很棒。

我们这里讲解回溯，我们可以先做了解，后续我学习回溯的时候，也会用大致这样的思路来做，并且会更加深入和细致。

接下来我们来看看最后一题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4d70892c31f69584261bf46b76209dc9.png)

我们同样先来看看迭代代码

```
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.add(root);
        int minDepth = 1;
        int ans = Integer.MAX_VALUE;
        root.val=minDepth;
        while (!deque.isEmpty()){
            int size = deque.size();
            while (size-->0){
                TreeNode node = deque.pop();
                if(node.left==null && node.right==null){
                    ans=Math.min(ans,node.val);
                }
                if(node.left!=null) {
                    node.left.val=minDepth+1;
                    deque.add(node.left);
                }
                if(node.right!=null) {
                    node.right.val=minDepth+1;
                    deque.add(node.right);
                }
            }
            minDepth++;
        }
        return ans;
    }
}
```

迭代代码采用的是将全部树的值全部赋为高度的方式，然后每次比较叶子结点的值来获取最小高度

接着来看看递归的代码

```
class Solution {
    int maxDepth = Integer.MAX_VALUE;
    public int minDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        dfs(root,0);
        return maxDepth;
    }

    private void dfs(TreeNode root, int deep) {
        if(root==null){
            return;
        }
        deep++;
        if(root.left==null && root.right==null){
            maxDepth =Math.min(maxDepth,deep);
            return;
        }
        dfs(root.left,deep);
        dfs(root.right,deep);
    }
}
```

递归采用的方式是每次前进让deep代表的深度+1，然后每次到叶子结点就对我们的最短深度进行维护，最后得到我们所需要的结果

这题和上一题的本质思路没什么不同，这题给我们的提示是，我们求某些值的方式未必要用其返回的结果来获得，我们可以在这个函数本身对我们的值进行赋值，然后再返回该值，这样可以有效降低难度

OK，那么到此为止，我们就终于把层序遍历给搞定了，真正实现了，打十个，而且还是用两种方式打