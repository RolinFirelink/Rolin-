%c用于输出字符

%d用于输出int类型的数字

使用a=getchar()可以达到输入字符的效果

小写英文字符-32位都会取他的大写

大写英文字符+32位都会取他的小写

“C语言中%X的意思是以十六进制数形式输出整数

sizeof()可以取某个数组或者是某种类型的大小，带结尾停止符号-1

strlen()可以取某个数组的长度，不带结尾停止符号，注意使用本方法时应在头文件中写上#include <string.h>

可以做a=sizeof(b),l=strlen(e)的运算

char a[]="sdfeasdfea"，可以存在这种形式，编译器会自动帮你数

在数组里利用sizeof(a)/sizeof(0)可以将数组的个数求出来，当作数组长度来用



do....while循环里，while()括号内的意思是只有当条件成立时才会进行循环

while循环里的意思是只有当条件成立时才会终止循环



利用for循环构建杨辉三角的代码

#include <stdio.h>


#define N 6		


void main(void){


	int a[N][N];


	int i, j; 


	for(i=0;i<N;i++){


		a[i][0] = 1;


		a[i][i] = 1;


	}


	for(i=2; i<N; i++)


		for(j=1; j<i; j++)  


			a[i][j]=a[i-1][j]+a[i-1][j-1];


	printf("杨辉三角为：\n");


	for(i=0; i<N; i++){


		for(j=0;j<i+1;j++)


			printf("%5d",a[i][j]);


		printf("\n");


	}}



输入十个学生的名字，并对其进行排序，令学生的姓名会按照其字母顺序输出

代码如下：

int main()

{

 char arr[10][20];

 char arr1[20];

 int k;

 printf("请输入10个学生姓名:>");

 for (int i = 0; i < 10; i++)

 {

  gets(arr[i]);

 }

 for (int i = 0; i < 10; i++)

 {

  k = i;

  for (int j = i + 1; j < 10; j++)

  {

   if (strcmp(arr[k], arr[j]) > 0)

   {

    k = j;

   }

   if (k != i)

   {

    strcpy(arr1, arr[i]);

    strcpy(arr[i], arr[k]);

    strcpy(arr[k], arr1);

   }

  }

 }

 printf("-------------排序后--------------\n");

 for (int i = 0; i < 10; i++)

 {            

  puts(arr[i]);

 }

 return 0;

}



逐一来解释下这个代码

这里先定义了一个char类型的二维数组，二维数组可以简单理解为行列，第一个是列，第二个是行

gets(a[i])的作用就相当于是scanf("%s", a[i]);，不同的是gets不用去特殊处理空格，这里的意思是将char类型的每一列赋予值，我们赋予的值只能在19个字符内，因为我们的行定义的就是19个

比如说我输入mario，其实是给第一列的五个对应的行里输入了mario这五个字符，第一列每一个具体的行都赋予一个字符，最后组成一个名字

所有char类型的数组它的结尾如果没有其他字符了，那么它都是自带一个停止字符的，int类型的则不会带有，所以即使我们赋值的时候有很多位置我们都没有赋予字符，程序也不会将那些没有赋值的地方给打印出来，因为一旦没有字符，程序就会立刻退出这个字符

最后是关于strcmp函数，它是用于比较字符的大小，它的大小比较是一个个转换成阿斯克码的形式进行比较的，如果两者相同，则继续进行下一个比较，如果到底了两者都没有出现不同的字符，那么就返回0

如果中间出现前者大于后者的，则返回1，同时结束比较

反之则返回-1

如果比较的字符一长一短，比如a比较aaaaaa，则碰上结束字符的对应的那一个比较就终止，但是之后的比较仍然会继续，会成为空值比较a值，自然会是a值大，那么就会返回-1

strcpy函数的作用是把后者赋值到前者，要求全是char类型的，当然了，这里有一个前提就是前者的char类型的数组必须要有足够的长度用于赋值，否则会出错

中间一段的嵌套循环是一种方法



void main()



{



 int a[2][3]={{1,2,3},{4,5,6}};



 int (*p)[3]=&a[1];



 int (*q)[3]=a;



 printf("%d,%d\n",(*p)[0],(*p)[1]);



 printf("%d,%d",*q[0],*q[1]);



}



最后输出的结果是

4,5

1,4

这是因为对于*p而言，它得到的是第二列的地址，因此从4开始打印

对于*q而言，它得到的是全部的地址，*q[0]是从第一列开始打印，而*q[1]则是从第二个开始打印

对其做相应的加法可以让它们打印相应的数，当然，减法也可以，因为他们的地址是按顺序排列着的



int f1(int x) 


          {    static int z=3,y=0; 


               y++; 


               z++; 


               return(x+y+z); 


          } 


void main() 


{    int a=1,k; 


      for(k=0;k<3;k++) 


printf("%4d",f1(a)); 


}

对于函数内有过static关键字修饰的变量，这种变量一旦在函数内进行修改那么在程序运行时再次进入本函数时会以上次修改的值作为起始值，而不会重置



