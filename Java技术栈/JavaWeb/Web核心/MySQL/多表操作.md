接下来我们要学习的内容就偏向于面试而非实际了，因此我们可以抱着了解的心态来，但并非是说不重要，该学还是要学的，我们照旧要打起十分精神。

首先我们来介绍下什么是多表，顾名思义，多表其实就是有多张数据表，而表与表之间由一定的关联关系，这种关联关系可以通过外键约束实现

多表的分类有三种，分别是一对一、一对多、多对多。这三种，我们先来介绍第一种

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE40d2dff00eba0fe153c0a3788e72ba50.png)

- 一对一

一对一的情况，其最佳的例子就是人和身份证，一个人只能有一张身份证，同时一张身份证也只能对应一个人。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe5b52753219df997a7f4c907cdab2b4d.png)

其建表原则是在任意一个表中建立外键，去关联另外一个表的主键。

我们可以构造其示例代码如下

```
-- 创建db3数据库
        CREATE DATABASE db3;

        -- 使用db3数据库
        USE db3;

        -- 创建person表
        CREATE TABLE person(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        NAME VARCHAR(20)                        -- 姓名
        );
        -- 添加数据
        INSERT INTO person VALUES (NULL,'张三'),(NULL,'李四');

        -- 创建card表
        CREATE TABLE card(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        number VARCHAR(20) UNIQUE NOT NULL,    -- 身份证号
        pid INT UNIQUE,                         -- 外键列
        CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id)
        );
        -- 添加数据
        INSERT INTO card VALUES (NULL,'12345',1),(NULL,'56789',2);
```

在我们的sqyog中，我们可以下图中的红圈选项，打开架构设计器，然后将对应的表拖入设计器中，可以看到表与表之间的关系

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2f7880d3f3dee0315cbbafc8059bb08a.png)

我们这里是一对一的关系，并且person是主键，因此card表内的pid指向person表中的主键id。而且我们也可以看到，这里两边都写着1

- 一对多

一对多的关系，在现实生活中有很多，最简单的场景就是，购物车，也就是用户和订单，一个用户可以有多个订单，多个订单可以是一个人的。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd0a89d66bb5a8b7f4f2c52fa68ee4202.png)

我们最重要的是要记住一对多的建表原则，记住，一对多的建表原则是在多的一方建立外键约束，来关联一的一方主键。所以对于一对多的场景而言，多的那一方，肯定不是主键。

我们可以构造其示例代码如下

```
-- 创建user表
        CREATE TABLE USER(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        NAME VARCHAR(20)                        -- 姓名
        );
        -- 添加数据
        INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四');

        -- 创建orderlist表
        CREATE TABLE orderlist(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        number VARCHAR(20),                     -- 订单编号
        uid INT,            -- 外键列
        CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)
        );
        -- 添加数据
        INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),(NULL,'hm003',2),(NULL,'hm004',2);



/*
   商品分类和商品
*/
        -- 创建category表
        CREATE TABLE category(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        NAME VARCHAR(10)                        -- 分类名称
        );
        -- 添加数据
        INSERT INTO category VALUES (NULL,'手机数码'),(NULL,'电脑办公');

        -- 创建product表
        CREATE TABLE product(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        NAME VARCHAR(30),        -- 商品名称
        cid INT,            -- 外键列
        CONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id)
        );
        -- 添加数据
        INSERT INTO product VALUES (NULL,'华为P30',1),(NULL,'小米note3',1),
        (NULL,'联想电脑',2),(NULL,'苹果电脑',2);
```

我们同样可以在架构设计器上查看这两者的关系

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe2b5206dc525b54d33b39ad0c692cb1b.png)

- 多对多

多对多的关系最好的就是例子就是学生选课，一个学生可以选多门课程，而一门课程也可以被多个学生选择

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8d8e7cedcd66c84def9e4daf0e4ba0cf.png)

我们多对多的建表原则是要借助第三张中间表，中间表至少要包含两个列。这两个列分别作为中间表的外键，关联另外两张表的主键。比如在上图中，我们中间的表就可以表示张三选择了两门课程，同时李四也选择了两门课程，这里就是靠sid和cid来令两张表关联出关系的

最后我们可以构造示例代码如下

```
-- 创建student表
        CREATE TABLE student(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        NAME VARCHAR(20)         -- 学生姓名
        );
        -- 添加数据
        INSERT INTO student VALUES (NULL,'张三'),(NULL,'李四');

        -- 创建course表
        CREATE TABLE course(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        NAME VARCHAR(10)         -- 课程名称
        );
        -- 添加数据
        INSERT INTO course VALUES (NULL,'语文'),(NULL,'数学');


        -- 创建中间表
        CREATE TABLE stu_course(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id
        sid INT,  -- 用于和student表中的id进行外键关联
        cid INT,  -- 用于和course表中的id进行外键关联
        CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束
        CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)   -- 添加外键约束
        );
        -- 添加数据
        INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);
```

其在架构设计器中的表示如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa40d69881b962a485723e12788912352.png)

当然，我们也可以很容易的知道，多对多的关系里，我们的中间表是没有一个主键的，两个表分别有主键。其实，这个可以理解为两个一对多，用两个一对多构建一个多对多

- 多表查询

接下来我们来学习多表查询，多表查询的分类有内连接查询、外连接查询、子查询、自关联查询。我们接下来就来一个个学习

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeccc25046a7ac842c5609add5d34499f.png)

但是在学习之前，我们要先做查询所需要的数据准备，请看代码

```
-- 创建db4数据库
        CREATE DATABASE db4;
        -- 使用db4数据库
        USE db4;

        -- 创建user表
        CREATE TABLE USER(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 用户id
        NAME VARCHAR(20),        -- 用户姓名
        age INT                                 -- 用户年龄
        );
        -- 添加数据
        INSERT INTO USER VALUES (1,'张三',23);
        INSERT INTO USER VALUES (2,'李四',24);
        INSERT INTO USER VALUES (3,'王五',25);
        INSERT INTO USER VALUES (4,'赵六',26);


        -- 订单表
        CREATE TABLE orderlist(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 订单id
        number VARCHAR(30),          -- 订单编号
        uid INT,    -- 外键字段
        CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)
        );
        -- 添加数据
        INSERT INTO orderlist VALUES (1,'hm001',1);
        INSERT INTO orderlist VALUES (2,'hm002',1);
        INSERT INTO orderlist VALUES (3,'hm003',2);
        INSERT INTO orderlist VALUES (4,'hm004',2);
        INSERT INTO orderlist VALUES (5,'hm005',3);
        INSERT INTO orderlist VALUES (6,'hm006',3);
        INSERT INTO orderlist VALUES (7,'hm007',NULL);


        -- 商品分类表
        CREATE TABLE category(
        id INT PRIMARY KEY AUTO_INCREMENT,  -- 商品分类id
        NAME VARCHAR(10)                    -- 商品分类名称
        );
        -- 添加数据
        INSERT INTO category VALUES (1,'手机数码');
        INSERT INTO category VALUES (2,'电脑办公');
        INSERT INTO category VALUES (3,'烟酒茶糖');
        INSERT INTO category VALUES (4,'鞋靴箱包');


        -- 商品表
        CREATE TABLE product(
        id INT PRIMARY KEY AUTO_INCREMENT,   -- 商品id
        NAME VARCHAR(30),                    -- 商品名称
        cid INT, -- 外键字段
        CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id)
        );
        -- 添加数据
        INSERT INTO product VALUES (1,'华为手机',1);
        INSERT INTO product VALUES (2,'小米手机',1);
        INSERT INTO product VALUES (3,'联想电脑',2);
        INSERT INTO product VALUES (4,'苹果电脑',2);
        INSERT INTO product VALUES (5,'中华香烟',3);
        INSERT INTO product VALUES (6,'玉溪香烟',3);
        INSERT INTO product VALUES (7,'计生用品',NULL);


        -- 中间表
        CREATE TABLE us_pro(
        upid INT PRIMARY KEY AUTO_INCREMENT,  -- 中间表id
        uid INT, -- 外键字段。需要和用户表的主键产生关联
        pid INT, -- 外键字段。需要和商品表的主键产生关联
        CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id),
        CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id)
        );
        -- 添加数据
        INSERT INTO us_pro VALUES (NULL,1,1);
        INSERT INTO us_pro VALUES (NULL,1,2);
        INSERT INTO us_pro VALUES (NULL,1,3);
        INSERT INTO us_pro VALUES (NULL,1,4);
        INSERT INTO us_pro VALUES (NULL,1,5);
        INSERT INTO us_pro VALUES (NULL,1,6);
        INSERT INTO us_pro VALUES (NULL,1,7);
        INSERT INTO us_pro VALUES (NULL,2,1);
        INSERT INTO us_pro VALUES (NULL,2,2);
        INSERT INTO us_pro VALUES (NULL,2,3);
        INSERT INTO us_pro VALUES (NULL,2,4);
        INSERT INTO us_pro VALUES (NULL,2,5);
        INSERT INTO us_pro VALUES (NULL,2,6);
        INSERT INTO us_pro VALUES (NULL,2,7);
        INSERT INTO us_pro VALUES (NULL,3,1);
        INSERT INTO us_pro VALUES (NULL,3,2);
        INSERT INTO us_pro VALUES (NULL,3,3);
        INSERT INTO us_pro VALUES (NULL,3,4);
        INSERT INTO us_pro VALUES (NULL,3,5);
        INSERT INTO us_pro VALUES (NULL,3,6);
        INSERT INTO us_pro VALUES (NULL,3,7);
        INSERT INTO us_pro VALUES (NULL,4,1);
        INSERT INTO us_pro VALUES (NULL,4,2);
        INSERT INTO us_pro VALUES (NULL,4,3);
        INSERT INTO us_pro VALUES (NULL,4,4);
        INSERT INTO us_pro VALUES (NULL,4,5);
        INSERT INTO us_pro VALUES (NULL,4,6);
        INSERT INTO us_pro VALUES (NULL,4,7);
```

这里我们所创建的各个数据表的关系如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb2d126164e9c3992041545870f2d7fa0.png)

其中user表和orderlist表时一对多的关系，而category和product也是一对多的关系。然后user和product具有多对多的关系，其中us_pro是中间表。

在这里就是将用户绑定用户表，然后商品绑定商品表，然后中间表就将具体的用户和商品连接在一起，通过用户我们可以查看到多个中间表的数据，通过这个数据可以知道其购买的商品，又可以通过该商品知道其具体购买的商品种类，这也就是多对多的好处，虽然复杂了些，但的确适合更加复杂的业务

- 内连接查询

我们先来学习内连接查询，所谓内连接查询就是查询两张表有交集的部分数据，也就是主键和外键有关联的部分数据

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE02dea42ab77948061c050b72063be357.png)

查询的语法有两种，分别是SELECT 列名 FROM 表名1 [INNER] JOIN 表明2 ON 条件的显示内连接查询和SELECT 列名 FROM 表名1,表名2 WHERE 条件

的隐式内连接查询

那么我们可以写入其示例代码如下

```
/*
   显示内连接
   标准语法：
      SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 关联条件;
*/
-- 查询用户信息和对应的订单信息
        SELECT * FROM USER INNER JOIN orderlist ON orderlist.uid = user.id;

        -- 查询用户信息和对应的订单信息，起别名
        SELECT * FROM USER u INNER JOIN orderlist o ON o.uid=u.id;

        -- 查询用户姓名，年龄。和订单编号
SELECT
        u.name,       -- 用户姓名
        u.age,    -- 用户年龄
        o.number   -- 订单编号
FROM
        USER u          -- 用户表
INNER JOIN
        orderlist o     -- 订单表
ON
        o.uid=u.id;


/*
   隐式内连接
   标准语法：
      SELECT 列名 FROM 表名1,表名2 WHERE 关联条件;
*/
        -- 查询用户姓名，年龄。和订单编号
SELECT
        u.name,       -- 用户姓名
        u.age,    -- 用户年龄
        o.number   -- 订单编号
FROM
        USER u,       -- 用户表
        orderlist o     -- 订单表
WHERE
        o.uid=u.id;
```

这里我们首先要讲下显示内查询和隐式内查询的分别，简单来看，这两者的分别无非也就是前者是的关键字是INNER JOIN ... ON ，而后者的关键字是WHERE。不过底层上这两者到底有什么分别，说实话我也搞不懂，那就先不管吧。不过无论是哪种方式，我们都是要在最后加入判断条件的，比如在上面我们就加入了两张表的对应id要相等的判断条件

我们先看我们的第七行代码，可以看到我们写入判断条件时我们写入了全部的数据表的名称，这样未免有些不方便。因此在第10行里我们采用了将我们的数据表再命名的方式来简化我们的代码，以后我们写sql语句也可以常常使用这种方式来优化我们的代码、

其次是有时候我们可能会觉得我们的代码全挤在一行不好，那么我们就可以采用13~22行的代码，我们总是将关键词写在最左边，将我们的具体的命令内容写在一个换行符的后面，这样我们就可以让我们的代码变得美观，而且，还可以加注释

还有一点需要提及的是，在SQL语句中，即使我们是在后面进行的重命名动作，我们在前面仍然可以使用这些重命名之后的内容来进行调用，这样做是不会报错的

最后我们得到的结果如下，这个结果其实是将我们的user的数据和orderlist里的数据进行了对应的填充，这样的结果用户看到了就会一目了然。比如我们在这里就能轻易知道张三有两个订单，李四也有两个。中间的id列是orderlist的id列，没有什么意义，这里存在只是因为一开始我们没过滤掉这个无用列而已

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE42eb88c153a27266f59a6f17f80042e3.png)

- 外连接查询

现在我们来学习外连接查询，外连接查询分左外连接查询和右外连接查询。左外连接的查询的意思是查询左表的全部数据以及和左右两表有交集的数据。其查询语法是SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件。这具体是什么意思呢？比方说在我们的用户表里，有一个用户是没有数据的，在我们之前的内连接查询里，我们只能查询到交集部分，那如果我们希望不但要查询到交集部分的内容，还希望将没有交集部分的内容也一起显示，这时候就需要用到我们的左外连接查询了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE397b38609d3ec1e3aa61d43db39ef84d.png)

同理还有右外连接查询，这个就依葫芦画瓢了，因此不再赘述。

那么我们可以写入其示例代码如下

```
/*
   左外连接
   标准语法：
      SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;
*/
-- 查询所有用户信息，以及用户对应的订单信息
SELECT
        u.*,
        o.number
FROM
        USER u
LEFT OUTER JOIN
        orderlist o
ON
        o.uid=u.id;
   


/*
   右外连接
   标准语法：
      SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;
*/
        -- 查询所有订单信息，以及订单所属的用户信息
SELECT
        o.*,
        u.name
FROM
        USER u
RIGHT OUTER JOIN
        orderlist o
ON
        o.uid=u.id;
```

其实，左外连接和右外连接本质上是差不多的，因为实际上我们可以调整我们的调用命令的顺序来达到同样的效果，所以实际上我们只要记住一个就够了

- 子查询

子查询的概念是查询已经中嵌套了查询语句，我们将这个嵌套查询成为子查询。子查询也分情况，各种情况，首先是单行单列的子查询

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbaca3841c40fba7b2516ab89ff9bd95a.png)

多行单列的子查询和多行多列的子查询

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE958d02cdc208067de5306ea2484f5656.png)

其实，嵌套查询就类似于我们java中的直接调用我们的函数，然后该结果不赋予任何变量，直接将这个变量拿来用的感觉。请看代码

```
/*
   结果是单行单列的
   标准语法：
      SELECT 列名 FROM 表名 WHERE 列名=(SELECT 列名 FROM 表名 [WHERE 条件]);
*/
-- 查询年龄最高的用户姓名
        SELECT MAX(age) FROM USER;/*获得年龄最高的年龄*/
        SELECT NAME,age FROM USER WHERE age=(SELECT MAX(age) FROM USER);/*将该年龄用于查询，获得年龄最高的用户姓名*/


/*
   结果是多行单列的
   标准语法：
      SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); 
*/
        -- 查询张三和李四的订单信息
        SELECT * FROM orderlist WHERE uid IN (1,2);/*查询uid为1和2的订单信息*/
        SELECT id FROM USER WHERE NAME IN ('张三','李四');/*查询张三和李四的uid*/
        /*将该查询的结构的uid直接用在第一个查询上，可以查询到对应的张三和李四的订单信息*/
        SELECT * FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME IN ('张三','李四'));


/*
   结果是多行多列的
   标准语法：
      SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];
*/
        -- 查询订单表中id大于4的订单信息和所属用户信息
        SELECT * FROM orderlist WHERE id > 4;/*先获得id大于4的表*/
SELECT
        u.name,
        o.number
FROM
        USER u,
        (SELECT * FROM orderlist WHERE id > 4) o/*获取该表并命名为o，在该表中进行查询*/
WHERE
        o.uid=u.id;
```

如果是单行单列的结果，我们可以直接将该结果结合WHERE来用。如果是多行单列的结果，我们可以结合IN进行使用。如果得到的结果是一个多行多列的另外一个表，那么我们可以将这个表与另外一个表结合使用，进行一个内查询或者是外查询。其实我觉得理论上也可以对这个表进行再次查询，获得一个单行单列的结果然后再查询的，不过很麻烦就没有去试了。反正具体怎么用到时候看我们的业务逻辑吧

- 自关联查询

什么是自关联查询？也就是说，当我们的同一张表中的数据有关联性的时候，我们可以把这张表当成多个表来查询

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0f8690f60a1030e3e962bc56bd602d98.png)

举个例子，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe83a42f4dcffdc3d6cd8d95400bcdd44.png)

比方说在上图中，我们可以看到孙悟空的上一级是1005，而1005是唐僧。这就是一种在一张表中存在数据关联性的典型例子。如果我们现在想要实现一种需求，就是将所有的人的上一级都找出来，没有的也要找，那我们应该怎么办呢？这时候就要用到自关联查询

请看示例代码

```
-- 创建员工表
        CREATE TABLE employee(
        id INT PRIMARY KEY AUTO_INCREMENT, -- 员工编号
        NAME VARCHAR(20),        -- 员工姓名
        mgr INT,            -- 上级编号
        salary DOUBLE           -- 员工工资
        );
        -- 添加数据
        INSERT INTO employee VALUES (1001,'孙悟空',1005,9000.00),
        (1002,'猪八戒',1005,8000.00),
        (1003,'沙和尚',1005,8500.00),
        (1004,'小白龙',1005,7900.00),
        (1005,'唐僧',NULL,15000.00),
        (1006,'武松',1009,7600.00),
        (1007,'李逵',1009,7400.00),
        (1008,'林冲',1009,8100.00),
        (1009,'宋江',NULL,16000.00);


        -- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询
/*
分析
   员工信息 employee表
   条件：employee.mgr = employee.id
   查询左表的全部数据，和左右两张表有交集部分数据，左外连接
*/
SELECT
        e1.id,
        e1.name,
        e1.mgr,
        e2.id,
        e2.name
FROM
        employee e1
LEFT OUTER JOIN
        employee e2
ON
        e1.mgr = e2.id;
```

我们这里是将一张表当调用两次，令其自己和自己比较，最后得到我们所需要的结果，这就是自关联查询。最后我们得到的结果如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1077ed8a6590ab934a9089a8703fa300.png)

这里我们的唐僧和宋江由于根本就没有对应的数据可供展示，因此我们可以看到其显示的除了前两列之外，都是null。因为前两列是调用原来的表的数据，而后两列的数据是要求比较到了结果之后才可以选择的，而由于根本比较不出来什么，所以结果是null

- 多表查询练习

由于本章节我们的内容很多，所以我们最好还是做一些对应的练习来加强我们对本章节的知识的印象。请看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE74fe8a95d52f36dde77f3f9244890cd7.png)

但是捏，因为我们现在还是了解阶段，所以，我们这里的练习也不具体去练习，听个思路就行了。

我们这里对于任何的题目，在解题之前，我们都应该要进行对应的分析，要知道我们解题具体要使用什么语句，然后我们的解题又具体要用到怎样的判断条件，又要用到哪些表进行对比，之后我们再进行解题。请看题解代码

```
-- 1.查询用户的编号、姓名、年龄。订单编号
/*
分析
   用户的编号、姓名、年龄  user表      订单编号 orderlist表
   条件：user.id=orderlist.uid
*/
SELECT
        u.id,
        u.name,
        u.age,
        o.number
        FROM
        USER u,
        orderlist o
        WHERE
        u.id=o.uid;



        -- 2.查询所有的用户。用户的编号、姓名、年龄。订单编号
/*
分析
   用户的编号、姓名、年龄  user表    订单编号 orderlist表
   条件：user.id=orderlist.uid
   查询所有的用户，左外连接
*/
        SELECT
        u.id,
        u.name,
        u.age,
        o.number
        FROM
        USER u
        LEFT OUTER JOIN
        orderlist o
        ON
        u.id=o.uid;



        -- 3.查询所有的订单。用户的编号、姓名、年龄。订单编号
/*
分析
   用户的编号、姓名、年龄 user表    订单编号 orderlist表
   条件：user.id=orderlist.uid
   查询所有的订单，右外连接
*/
        SELECT
        u.id,
        u.name,
        u.age,
        o.number
        FROM
        USER u
        RIGHT OUTER JOIN
        orderlist o
        ON
        u.id=o.uid;



        -- 4.查询用户年龄大于23岁的信息。显示用户的编号、姓名、年龄。订单编号
/*
分析
   用户的编号、姓名、年龄 user表    订单编号 orderlist表
   条件：user.id=orderlist.uid AND user.age > 23
*/
        SELECT
        u.id,
        u.name,
        u.age,
        o.number
        FROM
        USER u,
        orderlist o
        WHERE
        u.id=o.uid
        AND
        u.age > 23;


        -- 5.查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号
/*
分析
   用户的编号、姓名、年龄 user表   订单编号 orderlist表
   条件：user.id=orderlist.uid AND user.name IN ('张三','李四')
*/
        SELECT
        u.id,
        u.name,
        u.age,
        o.number
        FROM
        USER u,
        orderlist o
        WHERE
        u.id=o.uid
        AND
        u.name IN ('张三','李四');


        -- 6.查询商品分类的编号、分类名称。分类下的商品名称
/*
分析
   商品分类的编号、分类名称 category表    商品名称 product表
   条件：category.id=product.cid
*/
        SELECT
        c.id,
        c.name,
        p.name
        FROM
        category c,
        product p
        WHERE
        c.id=p.cid;


        -- 7.查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称
/*
分析
   商品分类的编号、分类名称 category表    商品名称 product表
   条件：category.id=product.cid
   查询所有的商品分类，左外连接
*/
        SELECT
        c.id,
        c.name,
        p.name
        FROM
        category c
        LEFT OUTER JOIN
        product p
        ON
        c.id=p.cid;


        -- 8.查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称
/*
分析
   商品分类的编号、分类名称  category表   商品名称 product表
   条件：category.id=product.cid
   查询所有的商品信息，右外连接
*/
        SELECT
        c.id,
        c.name,
        p.name
        FROM
        category c
        RIGHT OUTER JOIN
        product p
        ON
        c.id=p.cid;



        -- 9.查询所有的用户和该用户能查看的所有的商品。显示用户的编号、姓名、年龄。商品名称
/*
分析
   用户的编号、姓名、年龄 user表   商品名称 product表    中间表 us_pro
   条件：us_pro.uid=user.id AND us_pro.pid=product.id
*/
        SELECT
        u.id,
        u.name,
        u.age,
        p.name
        FROM
        USER u,
        product p,
        us_pro up
        WHERE
        up.uid=u.id
        AND
        up.pid=p.id;



        -- 10.查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称
/*
分析
   用户的编号、姓名、年龄 user表   商品名称 product表   中间表 us_pro
   条件：us_pro.uid=user.id AND us_pro.pid=product.id AND user.name IN ('张三','李四') 
*/
        SELECT
        u.id,
        u.name,
        u.age,
        p.name
        FROM
        USER u,
        product p,
        us_pro up
        WHERE
        up.uid=u.id
        AND
        up.pid=p.id
        AND
        u.name IN ('张三','李四');
```

主要问题在于第九第十题，有些难理解，其他都还好