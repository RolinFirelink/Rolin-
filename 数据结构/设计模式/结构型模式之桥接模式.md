现在我们来学习桥接模式，我们先来看看下面的案例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEece7432b04296ba567bb7051f984e796.png)

当然，有的同学可能会说，那我不可以使用装饰者模式吗？答案当然是可以的，但是我们这里主要要演示的是桥接模式，所以我们这里就用桥接模式来做

先来看看桥接模式的定义和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe0bcf2a89a04ef4f8f6e3e378b3d3227.png)

 然后我们通过桥接模式来完成下面的案例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE80cda38e4ebb35fa3abde34c95b17a3b.png)

首先我们定义我们的实现化角色，其实就是一个具有解码功能的接口

```
//实现化角色
public interface VideoFile {
    //解码功能
    void decode(String fileName);
}
```

然后我们创建具体的实现化角色，其下具体实现了解码功能，还有一个RMVB的实现化角色，这里就不展示了

```
//具体的实现化角色
public class AviFile implements VideoFile{

    @Override
    public void decode(String fileName) {
        System.out.println("AVI视频文件:"+fileName);
    }
}
```

然后我们创建抽象化角色，其是一个抽象类，其下聚合了对实现化角色的引用，我们这里用接口来提高其扩展性，其下有一个展示的抽象方法

```
//抽象化角色
public abstract class OpratingSystem {

    //声明videoFile变量
    protected VideoFile videoFile;

    public OpratingSystem(VideoFile videoFile) {
        this.videoFile = videoFile;
    }

    public abstract void play(String fileName);
}
```

接着我们创建扩展抽象话角色，我们这里以windows系统类为例，我们这里实现了其构造方法和抽象方法，实现对应的抽象方法我们的方式是调用其上存在的具有解码方法的属性

```
//扩展抽象化角色
public class windows extends OpratingSystem{

    public windows(VideoFile videoFile) {
        super(videoFile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}
```

最后我们可以写入我们的测试代码如下，可以看大此处我们创建对应的操作系统，其下传入具体的视频文件类，然后调用操作系统的播放方法就可以正确执行我们想要的功能了

```
public class Client {
    public static void main(String[] args) {
        //创建mac系统对象
        OpratingSystem mac = new Mac(new AviFile());
        //使用操作系统播放视频文件
        mac.play("复仇者联盟");
    }
}
```

现在我们这个案例就非常符合我们的需求，我们以后如果有了新的操作系统，我们只需要创建一个新的类令其继承操作系统抽象类即可，如果有了新的视频格式，我们也只需要令其实现VedioFile接口即可，都非常的便利

最后我们再来看看桥接模式的好处和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE51018611d354febac40a76cf184873c7.png)

