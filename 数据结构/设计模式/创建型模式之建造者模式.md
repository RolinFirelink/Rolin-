接着我们来学习创建型模式中的最后一种模式，建造者模式，先来看看对应的概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0e948de75cd9f17fdfaf875613dd156d.png)

光看概述好像有点云里雾里的，没关系，我们等后面实际造例子的时候我们再来加深理解，来看看其结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc9f20030a0224f9c210891c1e8021739.png)

接着我们通过创建一个共享单车类来加深我们对于建造者模式的理解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE636b32f45778b21bbfc299805d884fc2.png)

首先我们创建对应的自行车类，其下带有车架和车座的私有属性

```
public class Bike {

    private String frame; //车架

    private String seat; //车座

    public String getFrame() {
        return frame;
    }

    public void setFrame(String frame) {
        this.frame = frame;
    }

    public String getSeat() {
        return seat;
    }

    public void setSeat(String seat) {
        this.seat = seat;
    }
}

```

然后我们创建对应的Builder抽象类，这里我们声明的私有属性用protected修饰，这样我们的子类就可以直接使用该属性而不用特别获取了

我们还在其下定义了三个创建自行车的方法

```
public abstract class Builder {
    //声明Bike类型的变量，并进行赋值
    protected Bike bike = new Bike();

    public abstract void buildFrame();

    public abstract void buildSeat();

    //构建自行车的方法
    public abstract Bike createBike();
}

```

然后我们创建两个自行车的实现类，分别是摩拜自行车类和ofo自行车类，我们这里只展示其一

```
public class MobileBuilder extends Builder{
    @Override
    public void buildFrame() {
        bike.setFrame("碳纤维车架");
    }

    @Override
    public void buildSeat() {
        bike.setSeat("真皮车座");
    }

    @Override
    public Bike createBike() {
        return bike;
    }
}
```

接着我们创建一个指挥者类，类中定义builder类型的私有属性，然后提供一个方法用于构造自行车

```
public class Director {

    //声明builder类型的变量
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    //组装自行车的功能
    public Bike construct() {
        builder.buildFrame();
        builder.buildSeat();
        return builder.createBike();
    }
}
```

最后我们只要在测试类中创建指挥者对象，然后其下传入具体的建造者对象，调用指挥者对象的具体方法即可建造我们的目标自行车

```
public class Client {
    public static void main(String[] args) {
        //创建指挥者对象
        Director director = new Director(new MobileBuilder());
        //让指挥者指挥组装自行车
        Bike bike = director.construct();

        System.out.println(bike.getFrame());
        System.out.println(bike.getSeat());
    }
}
```

那么学到这里，我们大概也懂建造者模式是个什么样子了，我们的建造者模式首先需要的就是我们的产品类，这是当然的，要建造一个产品首先我们应该要将指定的产品给定义出来，否则产品都没有我们怎么建造，接着我们要抽象我们的建造者类，这个建造者类只是定义我们的建造的一个特定对象时应该要执行的建造步骤，并不执行具体的建造过程，然后我们创建具体的建造者实现类，实现具体的建造过程，最后我们再创建一个指挥者类，其会调用建造者类中的方法，以此来实现按照我们指定的顺序来构造我们的所需要的产品

当然，实际上我们有时候为了简化我们的结构，我们是可以将指挥者类的功能和建造者类的功能合二为一的，但是，如果指挥者类的功能是比较复杂的话，我们还是推荐使用指挥者类

然后我们来看看建造者模式的优缺点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc661f29dc7ddd1056808140218be439a.png)

最后我们来看看建造者模式的适用场景，简单来说，就是如果当我们的不同产品的创建过程大部分具有共同点时，我们推荐使用建造者模式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf6a3566dfe6a0723af3b957ca16bf7da.png)

- 模式扩展

建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。

举个例子，我们可以看看下面的原来没有使用建造者模式进行扩展的代码

```
public class Phone {
    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    public Phone(String cpu, String screen, String memory, String mainboard) {
        this.cpu = cpu;
        this.screen = screen;
        this.memory = memory;
        this.mainboard = mainboard;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getScreen() {
        return screen;
    }

    public void setScreen(String screen) {
        this.screen = screen;
    }

    public String getMemory() {
        return memory;
    }

    public void setMemory(String memory) {
        this.memory = memory;
    }

    public String getMainboard() {
        return mainboard;
    }

    public void setMainboard(String mainboard) {
        this.mainboard = mainboard;
    }

    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

public class Client {
    public static void main(String[] args) {
        //构建Phone对象
        Phone phone = new Phone("intel","三星屏幕","金士顿","华硕");
        System.out.println(phone);
    }
}
```

可以看到上面的代码是真的非常麻烦，可读性比较差，那么此时我们就可以使用建造者模式来重构该代码

```
package com.itheima.reggie.login;

public class Phone {

    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    //私有的构造方法
    private Phone(Builder builder) {
        this.cpu = builder.cpu;
        this.screen = builder.screen;
        this.memory = builder.memory;
        this.mainboard = builder.mainboard;
    }

    static final class Builder {
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        public Builder cpu(String cpu){
            this.cpu = cpu;
            return this;
        }

        public Builder screen(String screen){
            this.screen = screen;
            return this;
        }

        public Builder memory(String memory){
            this.memory = memory;
            return this;
        }

        public Builder mainboard(String mainboard){
            this.mainboard = mainboard;
            return this;
        }

        //使用构建者创建Phone对象
        public Phone build() {
            return new Phone(this);
        }
    }

    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

```

我们首先定义一个不可修改的Builder类在我们的手机类内部中，其下我们提供对应的设置属性的方法让我们的Builder可以设置对应的属性到我们之前所创建的属性中，每次设置完之后我们都返回这个Builder对象，所以我们可以直接用this关键字返回结果，最后我明天工一个构建者来创建Phone对象，直接返回一个新的Phone对象即可，由于Phone类中只提供了一个构造方法，且需要传入一个builder对象，因此我们这里直接传入this即可，代表我们传入一个当前的builder对象来创建一个phone对象

然后我们的构造方法中只需要将builder中对应的属性赋予到我们的手机类中的对应属性即可，当然，有的同学可能会觉得这特么不脱裤子放屁吗？我直接用我原来的方式不简单多了？但其实我们这样做是有道理的，虽然这样我们的编程上却是麻烦了些，但是使用起来却非常方便，请看我们的测试方法

```
package com.itheima.reggie.login;

public class Client {
    public static void main(String[] args) {
        //创建手机对象,通过构建者对象获取手机对象
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .screen("三星屏幕")
                .memory("金士顿内存条")
                .mainboard("华硕主板")
                .build();

        System.out.println(phone);
    }
}

```

在这里，我们可以使用使用链式编程，用户可以很直观的看到其设置的内容究竟是什么，其次链式编程也允许用户随意设置其想要的数据且不指定顺序，这是我们原来传统的方式所做不到的

重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。

最后我们来看看创建者模式的四种方法的对比

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6461cffa04d81757fa8cd95fb78b1655.png)

