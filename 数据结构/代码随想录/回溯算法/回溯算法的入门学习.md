本节我们来学习回溯算法，我们先来看看回溯算法能够解决哪些问题

- 切割问题：一个字符串按一定规则有几种切割方式

- 子集问题：一个N个数的集合里有多少符合条件的子集

- 排列问题：N个数按一定规则全排列，有几种排列方式

- 组合问题：N个数里面按一定规则找出k个数的集合

- 棋盘问题：N皇后，解数独等等

有一点我们要先提一下，任何递归算法都是非常低效率的算法，即使加了剪枝也是，所以能用for循环构建解决的算法，就不要用递归和回溯，这点要先搞清楚，不要看到一个题目就想着什么几把递归回溯，到时候给你整个超时你就知道什么是痛苦。另外有的同学可能搞不懂组合和排序的分别，他们的区别请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE09c0c8088ff8c7d22f984e53004ba0df.png)

我们如何理解回溯法呢？我们首先要记住一点，那就是回溯法解决的问题都可以抽象为树形结构，这一点我们会在后面的算法问题中反复提到，我们无论是构建回溯法的思路还是去理解回溯法都是将其抽象会树形结构来进行理解的。为什么其可以理解为树形结构呢？因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成的树的深度。现在可能还听不太懂，但是随着我们做题的深入，我们肯定是可以听懂的

接着我们来讲我们回溯法的代码模板，我们的模板就是我们以后做回溯题目都用的上的模板，非常重要，所以我们要认真学

我们第一步要确定的是我们的回溯法的结束条件，这个一般是我们左边界大于右边界或者是我们的集合存放的数量达到了我们的题目所要求的量。第二步我们要确定的是我们的递归逻辑，一般我们可以将其抽象为一个树型结构，如下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc3969b78f9f78c88d691ef30b099f5bb.png)

一般这里是要使用一个for循环来进行递归，且进入递归之前我们要添加对应的值，而出去递归之后又要将加入的值给删去，不然就不是回溯了，他会一直往上加，这肯定不行的。这里的for循环的逻辑是随着我们的具体的题目需求的变化而变化的。

最后是我们的结束代码，不过一般我们的回溯代码的返回值都是void，所以这个其实也可以不加，这里我们先按下不表，要加的时候再加上吧

学习完了模板之后，我们就来正式做我们的回溯的题目

- 组合

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb6aaa830fae202444f8d0e91201e8304.png)

对于本题，我们就可以使用我们之前的模板来进行解题了，注意我们这里要求的是组合，其对顺序的互异是不要求的，也就是两个元素相同但顺序不同的组合，其会被认为是一个元素。那么我们就需要在做的时候，同时做到去重。

那么我们要如何做到去重呢？其实很简单，我们只要让我的起始坐标在递归时不断前进，当集合的数量到达指定数量时就收集结果，按照这样的逻辑，我们在我们收集的过程中就能够完成去重，因为实际上这样做根本不会得到重复的元素，具体请看下路

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6544a08049dfbe4e8a53ca92b974f18b.png)

最后我们可以写入我们的代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        dfs(n,k,1,new ArrayList<>());
        return list;
    }

    private void dfs(int n, int k, int start, List<Integer> list) {
        if(list.size()==k){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i <= n; i++) {
            list.add(i);
            dfs(n,k,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

我们上面的这个代码的确是可行的，但是他的效率有些不尽人意，我们要怎么才能对其进行对应的优化呢？这当然就需要用到剪枝。那么我们的剪枝应该怎么做呢？其实我们不难分析出来，如果当前的指针到边界里所能拿到的数据量比我们当前的集合所存放的数据数量与到目标数量之差还要少，那么就可以执行剪枝。这样听着似乎很不好理解，我们直接看图就可以了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE667a2e74ab08f96ca24dc09b1b6e8066.png)

那么我们可以将我们的代码改造如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        dfs(n,k,1,new ArrayList<>());
        return list;
    }

    private void dfs(int n, int k, int start, List<Integer> list) {
        if(list.size()==k){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i <= n - (k - list.size()) + 1; i++) {
            list.add(i);
            dfs(n,k,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

我们这里的n是边界，而k是我们的目标大小，那么k-list.size()，就是目标大小与集合当前数据总量的差，那么n-(k-list.size())就是所有集合数据与上一个结果的差值，我们的i必须要比这个所剩余的值还要小，否则就没必要进行继续递归，同时这里还进行了一个+1，这里由于边界值问题所以给的一个+1补偿。另外我们的原式应该是n-i<=k-list.size()-1，我们上面最后的结果只不过是进行了一个式子的转换而已

我们如果不想做这种转换行为，我们也可以将我们的代码写成如下的形式

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        dfs(n,k,1,new ArrayList<>());
        return list;
    }

    private void dfs(int n, int k, int start, List<Integer> list) {
        if(list.size()==k){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i <= n; i++) {
            if(i>n - (k - list.size()) + 1){
                break;
            }
            list.add(i);
            dfs(n,k,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

我们这个代码的逻辑就更好理解了一些，不过更加繁琐了就是，而且本质还是一样的

- 组合总和III

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbcde271e94776ad174dd5c66799c54e0.png)

这题直接套用我们的模板就可以了，其组合的最终情况是我们的总和为我们的目标和时，其剪枝条件时总和比我们的目标和还要大时或者是我们集合中的数量超越了我们想要的数量时，那么我们可以写入我们的代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        dfs(k,n,1,0,new ArrayList<>());
        return list;
    }

    private void dfs(int k, int n, int start, int sum, List<Integer> list) {
        if(sum>n || list.size()>k){
            return;
        }
        if(sum==n && list.size()==k){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < 10; i++) {
            list.add(i);
            dfs(k,n,i+1,sum+i,list);
            list.remove(list.size()-1);
        }
    }
}
```

- 电话号码的字母组合

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE853347dcf45b56e3174ae51d47f574d7.png)

对于这一题，同样是套用模板，不过这里我们套用的模板有些不一样，首先，为了便于我们后续的递归，我们先创建一个符合条件的字符串数组，用其来模拟我们电话号码上的字符串

```
class Solution {
    List<String> list = new ArrayList<>();
    String[] arr = new String[]{"0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    public List<String> letterCombinations(String digits) {
        if(digits.equals("")){
            return list;
        }
        StringBuffer sb = new StringBuffer();
        dfs(digits,0,0,sb);
        return list;
    }

    private void dfs(String digits, int is, int js, StringBuffer sb) {
        if(sb.length()==digits.length()){
            list.add(sb.toString());
            return;
        }
        int index = digits.charAt(is) - '0';
        String s = arr[index];
        for (int j = js; j < s.length(); j++) {
            sb.append(s.charAt(j));
            dfs(digits,is+1,js,sb);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

这里我们注意我们的递归，我们这里递归用了两个参数来传递我们的指针，第一个指针是is，这个指针用于递归遍历我们的号码，第二个是js，这个是用于遍历递归我们的每一个数据能代表的具体值的指针，同样使用回溯模板，不过我们这里多加了一个指针而已

最后来看看我们的思路图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15edaf9b13ca5f1393e4cbab00a16932.png)

- 组合总和

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE038e8dde375d4c70cbcf2e068920b7bd.png)

这题也不难，没什么特别值得说的，我们可以直接写入我们的回溯代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    int target;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        this.target=target;
        Arrays.sort(candidates);
        dfs(candidates,0,0,new ArrayList<>());
        return this.list;
    }

    private void dfs(int[] candidates, int all, int start, List<Integer> list) {
        if(all>target){
            return;
        }else if(all==target){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if(all+candidates[i]>target){
                break;
            }
            list.add(candidates[i]);
            dfs(candidates,all+candidates[i],i,list);
            list.remove(list.size()-1);
        }
    }
}
```

这里我们进行了剪枝，不过值得注意的是，我们的剪枝操作必须要事先对我们的数组进行排序才可以达到，否则是无法排序的。