现在我们来学习备忘录模式，先来看看其概述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE65fbc15a1cd0dc6acbcc523d971540b8.png)

然后我们来看看其定义的结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9ce6db5631d062d8b3caaa8a18e8a8a9.png)

同样的我们通过一个案例来加深理解，来看看案例需求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEac57c7b14bdaba325800565b2a21849f.png)

实现这种案例有两种方式，分别是白箱和黑箱，我们先来实现白箱方式，所谓白箱方式指的是对备忘录角色的任何一个对象都提供宽接口，备忘录角色内部存储的状态对所有角色公开，来看看类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8f48e39f413354e5fd5ffa3fd31e20a4.png)

首先我们创建备忘录角色类，该角色类可以保存我们的状态，我们的角色属性就生命、攻击、防御三种，所以我们这里只往内部设置这三个属性，然后提供对应的方法

```
//备忘录角色类
public class RoleStateMemento {

    private int vit; //生命
    private int atk; //攻击
    private int def; //防御

    public RoleStateMemento(int vit, int atk, int def) {
        this.vit = vit;
        this.atk = atk;
        this.def = def;
    }

    public RoleStateMemento() {
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }
}

```

然后创建发起人角色，其在我们案例中代表的是游戏角色类，我们给予其赋予生命、攻击、防御三个属性，提供对应的构造和setandget方法，然后我们体用初始化内部状态的方法，给对应的属性赋值，接着提供一个保存角色状态功能的方法，返回一个保存角色状态的对象，然后我们再提供一个恢复角色状态的方法，要求提供一个角色状态对象，然后内部会自动获得里面的值并赋予到原来的对象中

```
//游戏角色类（发起人角色）
public class GameRole {

    private int vit; //生命
    private int atk; //攻击
    private int def; //防御

    //初始化内部状态
    public void initState() {
        this.vit=100;
        this.atk=100;
        this.def=100;
    }

    //战斗
    public void fight() {
        this.vit=0;
        this.atk=0;
        this.def=0;
    }

    //保存角色状态功能
    public RoleStateMemento saveState() {
        return new RoleStateMemento(vit,atk,def);
    }

    //恢复角色状态
    public void recoverState(RoleStateMemento roleStateMemento){
        //将备忘录对象中存储的状态赋值给当前对象的成员
        this.vit= roleStateMemento.getVit();
        this.atk= roleStateMemento.getAtk();
        this.def= roleStateMemento.getDef();
    }

    //展示状态功能
    public void stateDisplay() {
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "GameRole{" +
                "vit=" + vit +
                ", atk=" + atk +
                ", def=" + def +
                '}';
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }
}

```

最后我们创建管理者角色，其下聚合了备忘录类，还提供了一些必要的方法

```
public class RoleStateCaretaker {

    //声明RoleStateMemento类型的变量
    private RoleStateMemento roleStateMemento;

    public RoleStateCaretaker(RoleStateMemento roleStateMemento) {
        this.roleStateMemento = roleStateMemento;
    }

    public void setRoleStateMemento(RoleStateMemento roleStateMemento) {
        this.roleStateMemento = roleStateMemento;
    }

    public RoleStateMemento getRoleStateMemento() {
        return roleStateMemento;
    }

    public RoleStateCaretaker() {
    }
}
```

接着我们可以写入我们的测试类代码如下，我们这里先创建游戏对象，然后创建游戏管理者对象，接着我们往管理者对象中设置一个游戏保存的状态对象，直接调用游戏角色内部的方法即可，接着调用游戏角色的恢复方法，传入一个管理者类中保存的游戏状态类即可完成恢复

```
public class Client {
    public static void main(String[] args) {
        System.out.println("h之前");
        //创建游戏角色对象
        GameRole gameRole = new GameRole();
        gameRole.initState();//初始化状态操作
        gameRole.stateDisplay();

        //将该游戏角色内部状态进行备份
        //创建管理者对象
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());

        System.out.println("h之后");
        //损耗严重
        gameRole.fight();
        gameRole.stateDisplay();
        System.out.println("恢复之前的状态");
        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());
        gameRole.stateDisplay();
    }
}
```

-  黑箱备忘录模式

那么接着我们来用黑箱备忘录模式来实现这个案例，其实现的方式就是提供一个备忘录接口，然后将备忘录类设计为发起人类的内部成员类

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE21312edac4a6dafa836e918b13ffecc9.png)

首先我们创建备忘录接口，其用于对外提供窄接口

```
//备忘录接口，对外提供窄接口
public interface Memento {
}
```

然后我们创建管理者类，其拥有我们刚刚定义的接口属性，同时提供对应的getandset方法

```
public class RoleStateCaretaker {

    //声明Memento类型的变量
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```

然后我们定义游戏角色类，内部再定义一个保存状态的类，令其实现我们的接口，然后其下提供对应的方法即可

```
//游戏角色类（发起人角色）
public class GameRole {

    private int vit; //生命
    private int atk; //攻击
    private int def; //防御

    //初始化内部状态
    public void initState() {
        this.vit=100;
        this.atk=100;
        this.def=100;
    }

    //战斗
    public void fight() {
        this.vit=0;
        this.atk=0;
        this.def=0;
    }

    //保存角色状态功能
    public Memento saveState() {
        return new RoleStateMemento(vit,atk,def);
    }

    //恢复角色状态
    public void recoverState(Memento memento){
        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;
        //将备忘录对象中存储的状态赋值给当前对象的成员
        this.vit= roleStateMemento.getVit();
        this.atk= roleStateMemento.getAtk();
        this.def= roleStateMemento.getDef();
    }

    //展示状态功能
    public void stateDisplay() {
        System.out.println(this.toString());
    }

    @Override
    public String toString() {
        return "GameRole{" +
                "vit=" + vit +
                ", atk=" + atk +
                ", def=" + def +
                '}';
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    private class RoleStateMemento implements Memento{
        private int vit; //生命
        private int atk; //攻击
        private int def; //防御

        public RoleStateMemento() {
        }

        public RoleStateMemento(int vit, int atk, int def) {
            this.vit = vit;
            this.atk = atk;
            this.def = def;
        }

        public int getVit() {
            return vit;
        }

        public void setVit(int vit) {
            this.vit = vit;
        }

        public int getAtk() {
            return atk;
        }

        public void setAtk(int atk) {
            this.atk = atk;
        }

        public int getDef() {
            return def;
        }

        public void setDef(int def) {
            this.def = def;
        }
    }
}

```

最后我们写入我们的测试类的代码如下，最终也可以得到同样的效果

```
public class Client {
    public static void main(String[] args) {
        System.out.println("h之前");
        //创建游戏角色对象
        GameRole gameRole = new GameRole();
        gameRole.initState();//初始化状态操作
        gameRole.stateDisplay();

        //将该游戏角色内部状态进行备份
        //创建管理者对象
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setMemento(gameRole.saveState());

        System.out.println("h之后");
        //损耗严重
        gameRole.fight();
        gameRole.stateDisplay();
        System.out.println("恢复之前的状态");
        gameRole.recoverState(roleStateCaretaker.getMemento());
        gameRole.stateDisplay();
    }
}

```

而且我们这样定义，我们的管理者类就无法随意获取到我们的状态类并修改其内容了，如果其采用向下转型的话，那么会报类型转换异常

值得一提的是，我们将该状态类即使放到外面来，不定义成其内部的类，也是可行的，那为什么我们这里就要定义成内部类呢？这个问题值得我们思考

最后我们来看看其优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE65fb85aaa19d9395bcce2fc803764928.png)

