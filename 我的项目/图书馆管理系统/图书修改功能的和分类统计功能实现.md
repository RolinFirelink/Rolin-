本节我们来实现图书修改功能，依葫芦画瓢了，先在Dao层添加接口方法

```javascript
void update(Book book);
```

实现方法

```javascript
/**
 * 修改
 * @param book
 */
@Override
public void update(Book book) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.BOOK_PATH));
        List<Book> list = (List<Book>) ois.readObject();
        if(list!=null){
            Book originbook = list.stream().filter(b -> b.getId()==book.getId()).findFirst().get();
            
            originbook.setIsbn(book.getIsbn());
            originbook.setBookName(book.getBookName());
            originbook.setAuthor(book.getAuthor());

            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.BOOK_PATH));
            oos.writeObject(list);
            oos.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

跟删除方法其实大差不差，本质上还是一样的，因为我们这里是修改，所以要对集合中的对象进行对应数据的修改，但是这样的代码是存在问题的，最明显的问题就是含金量不高，因为如果我们的图书的属性非常多的话，那我们就要重复做非常多次的赋值操作，这样的代码就太烂了，也不通用，因此我们需要使用上反射机制，创建一个工具类BeanUtil，来让一个对象的属性自动赋值到另外一个对象上

我们先来创建这个工具类并取名叫BeanUtil，然后创建对应的方法并写入代码

```javascript
/**
 * 对象属性值的拷贝方法
 * @param origin
 * @param dest
 */
//工具类要具有通用性，要能够完成所有对象属性的拷贝，因此类型要些终极父类型Object
public static void populate(Object origin,Object dest){
    //使用反射解决此问题
    //判断两个对象是否为同一类型，若不是则抛出异常
    if(origin.getClass() != dest.getClass()){
        throw new RuntimeException("两个对象必须为同一对象");
    }
    Class<?> clazz = origin.getClass();
    //获取origin中的属性
    Field[] fields = clazz.getDeclaredFields();
    for (Field f: fields) {
        //排除serialVersionUID
        if("serialVersionUID".equals(f.getName())){
            continue;
        }
        //首先要打破封装
        f.setAccessible(true);
        //赋值
        //从dest对象中找到对应的属性值并赋值到origin相应的属性中
        try {
            f.set(origin,f.get(dest));
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
```

我们首先判断传入的对象是否为同一对象，若不为同一对象则要抛出异常，这是自然的，因为不是同一对象属性根本无法拷贝，因此要抛出异常，接着我们获取要修改的图书对象的class对象，然后获取其所有属性，接着调用增强for循环进行属性的一对一赋值，首先排除掉序列号，因为序列号是不可修改的，接着要打破封装，然后调用属性的修改方法完成一个属性的修改，利用整个for循环完成对一个对象的所有属性的修改

这里完成修改的代码是f.set(origin,f.get(dest));，这个方法只要传入要修改的对象和修改的内容，就会自动从对象中获取到要修改的与其相同的属性完成修改，而f.get()方法则是获得对象里与其相同的属性并返回该属性的值，那么合并起来这个代码的作用就是先找到要修改的对象里的对应属性，然后找到传入的另一个对象的对应属性的值，将其传入完成修改。这样我们就利用反射完成了我们的工具类

接着我们就利用这个工具类来完成我们的图书的修改，那么我们图书修改的代码最终版本如下

```javascript
/**
 * 修改
 * @param book
 */
@Override
public void update(Book book) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.BOOK_PATH));
        List<Book> list = (List<Book>) ois.readObject();
        if(list!=null){
            Book originbook = list.stream().filter(b -> b.getId()==book.getId()).findFirst().get();
            BeanUtil.populate(originbook,book);
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.BOOK_PATH));
            oos.writeObject(list);
            oos.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

然后我们只需要添加对应的service层和controller层方法就可以完成修改了

当然，我们用户的修改功能也应该要使用这个工具类来完成修改，这里就不贴代码了，改一个代码的事而已



图书分类统计功能

接着我们来实现图书分类统计功能，这里对应的模块是我们图书馆管理系统里的图书统计，是一个全新的模块，因此我们要重新创建新的接口

当然，首先我们应该要先分析下其界面代码，否则我们无从下手，首先我们进入到module包下的charts包下，寻找对应的界面代码，可以找到这个代码

```javascript
<PieChart fx:id="pieChart" title="图书类别" />
```

可以看到其有id属性，点进这个id属性，可以看到如下代码

```javascript
/**
 * @author admin
 */
public class PieChart implements Initializable {

    @FXML
    private javafx.scene.chart.PieChart pieChart;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        ObservableList<javafx.scene.chart.PieChart.Data> pieChartData = FXCollections.observableArrayList(
                new javafx.scene.chart.PieChart.Data("计算机", 20),
                new javafx.scene.chart.PieChart.Data("文学", 12),
                new javafx.scene.chart.PieChart.Data("经济", 25),
                new javafx.scene.chart.PieChart.Data("管理", 22)
        );
        pieChart.setData(pieChartData);
        pieChart.setClockwise(false);
    }
}
```

第七行其实将这个底层代码与界面代码联系起来，接着方法内部获取了图书的可观察集合，然后将内容手动添加到集合中，接着将这个集合设置到pieChart中，然后就可以在界面中观察到我们所需要的方块图了，我们为了简洁，将这个代码再修改一下

```javascript
import javafx.scene.chart.PieChart.Data;
/**
 * @author admin
 */
public class PieChart implements Initializable {

    @FXML
    private javafx.scene.chart.PieChart pieChart;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        ObservableList<Data> pieChartData = FXCollections.observableArrayList(
                new Data("计算机", 20),
                new Data("文学", 12),
                new Data("经济", 25),
                new Data("管理", 22)
        );
        pieChart.setData(pieChartData);
        pieChart.setClockwise(false);
    }
}
```

通过手动导入javafx.scene.chart.PieChart.Data包，然后我们可以在类中省略全限定名

接着我们要做的事情就是将硬盘中的文件数量读取出来，对各种不同类比的书做出统计，然后将这个统计对象返回给controller层，然后controller层接受这些数据之后做出对应的界面展示

```javascript
public interface ChartDao {
    Map<String,Integer> bookTypeCount();
}
```

这里你提一下为什么我们的返回值是Map<String,Integer>呢？这是根据前台的数据得来的，我们可以看到前台所需要的数据类型就是图书类型的字符串和图书数量组合的数据，因此我们这里也就返回这样的数据给它

接着实现该方法

```javascript
public class ChartDaoImpl implements ChartDao {
    /**
     * 统计图书分类的数量
     * @return
     */
    @Override
    public Map<String, Integer> bookTypeCount() {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream(PathConstant.BOOK_PATH));
            List<Book> list = (List<Book>) ois.readObject();
            //使用stream流进行分类统计,本行代码可以获取到List集合中各种不同类型的对象，并将其放置于不同的List集合中
            //而存放所有不同的List集合的集合就是Map集合
            Map<String, List<Book>> collect = list.stream().collect(Collectors.groupingBy(Book::getType));
            //要处理Map对象，使得我们返回一个符合条件的值
            HashMap<String,Integer> map = new HashMap<>();
            //获得此前获得的Map集合的迭代器对象
            Iterator<Map.Entry<String, List<Book>>> iterator = collect.entrySet().iterator();
            //迭代遍历，当迭代器还有下一个元素时进行迭代
            while (iterator.hasNext()){
                //获取迭代器的下一个Map对象，该对象以List集合的形式存储了该类型的所有图书对象
                Map.Entry<String, List<Book>> next = iterator.next();
                //将该对象的图书类型与图书数量添加到map集合中，如果为空则添加0，不为空则添加对应数量，此处使用三元运算符达成条件
                map.put(next.getKey(), next.getValue()==null ? 0:next.getValue().size());
            }
            return map;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException();
        } finally {
            if(ois!=null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

创建service接口并提供方法

```javascript
package com.bjpowernode.service;

import java.util.Map;

public interface ChartService {
    
    Map<String,Integer> bookTypeCount();
    
}
```

实现service接口方法

```javascript
public class ChartServiceImpl implements ChartService {

    private ChartDao chartDao = new ChartDaoImpl;

    @Override
    public Map<String, Integer> bookTypeCount() {
        return chartDao.bookTypeCount();
    }
}
```

最后实现controller层

```javascript
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        //通过service获取数据
        Map<String,Integer> map = chartService.bookTypeCount();
        Data[] dataArray = new Data[map.size()];
        //定义数组下标
        int i = 0;

        Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()){
            Map.Entry<String, Integer> next = iterator.next();
            dataArray[i++] = new Data(next.getKey(),next.getValue());
        }
        //将数组转换为ObservableList集合
        ObservableList<Data> pieChartData = FXCollections.observableArrayList(dataArray);
        pieChart.setData(pieChartData);
        pieChart.setClockwise(false);
    }
}
```

这里为什么我们可以传入一个数组到界面对象里去？因为界面对象的源码里是允许数组对象传入的，会自动转换成可观察的集合，因此我们这里将数据转换集合再传入的方式没有任何问题