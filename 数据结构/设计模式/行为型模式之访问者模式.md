现在我们来学习下访问者模式，首先我们来看看其定义和结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE114b42b5f5c47cc0b83ad2be02ecb8f0.png)

当然，只看上面的说明肯定是空洞的，我们同样通过一个例子来加深理解，先来看看其需求和类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE690bb1a25cca8888cbf589017c11928c.png)

那么首先我们创建抽象访问者角色，其下提供两个喂食方法，分别喂食我们的猫和狗，为什么不统一用Animal接口来表示？因为如果使用统一的接口表示，后续我们喂食的时候将无法具体对应喂食到某个宠物，只能喂食整个宠物一个大的类别

```
//抽象访问者角色
public interface Person {

    void feed(Cat cat);

    void feed(Dog dog);

}

```

然后我们定义主人类和路人类，其都实现Person类并重写其下的方法（只展示一个）

```
public class Owner implements Person{

    @Override
    public void feed(Cat cat) {
        System.out.println("主人喂食猫");
    }

    @Override
    public void feed(Dog dog) {
        System.out.println("主人喂食狗");
    }
}
```

接着我们定义抽象动物类，其实抽象元素角色，其下我们定义一个可以接受人访问的方法

```
public interface Animal {

    //接受访问者访问的功能
    void accept(Person person);
}

```

然后定义具体的宠物类实现动物类，重写其方法，直接调用人的喂食方法，将当前的宠物对象传入即可

```
public class Dog implements Animal{

    @Override
    public void accept(Person person) {
        person.feed(this);//访问者给宠物猫喂食
        System.out.println("好吃汪...");
    }
}
```

最后我们要创建结构对象角色，这里代表的主人家类，其下组合了一个宠物对象的集合，具有添加宠物和遍历宠物的功能，遍历宠物就直接调用宠物里的接受访问的方法即可，即是可以让外人或者是主人直接访问所有的宠物

```
//对象结构类
public class Home {

    //声明一个集合对象，用来存储元素对象
    private List<Animal> animals = new ArrayList<>();

    //添加元素功能
    public void add(Animal animal){
        animals.add(animal);
    }

    public void action(Person person){
        //遍历集合，获取每一个元素，让访问者访问每一个元素
        for (Animal animal : animals) {
            animal.accept(person);
        }
    }
}
```

然后我们可以写入我们的测试类代码如下，我们这里创建主人类，然后往其中添加宠物，接着分别创建主人对象和路人对象并调用主人家里的统一访问方法，最后可以得到主人和路人都分别给宠物进行了喂食的结果

```
public class Client {
    public static void main(String[] args) {
        //创建Home对象
        Home home = new Home();
        //添加元素到Home对象中
        home.add(new Dog());
        home.add(new Cat());

        //创建主人对象
        Owner owner = new Owner();
        //让主人喂食所有的宠物
        home.action(owner);

        //创建路人对象
        Someone someone = new Someone();
        home.action(someone);
    }
}
```

接着我们来看看其优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf90f8990fa5269ac8028da7659e8e18a.png)

- 扩展

实际上，我们的访问者模式是使用到了一种双分派的技术，我们这里就来扩展一下这个知识点

分派又两种，分别是静态分派和动态分派，我们来看看他们三者的描述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcbaffc2d291872e13565b6385f21dfee.png)

静态分派可以简单理解为是方法重载，其是发生在编译时期，而动态分派是发生在运行时期，可以动态置换掉某个方法

我们先来讲讲动态分派的例子，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE35571b1758a56f074db6a0c1f6a7ed91.png)

所以简单来说，我们可以将都动态分派理解为多态，Java编译器在编译时期会对对象的类型进行判断，此处判断的类型是静态类型，但是对方法的调用是根据对象的真实类型，而不是静态类型，因此我们调用对应的方法时会执行其真实类型里的方法

接着我们再来说说静态分派，方法重载可以简单理解为是静态分派，我们来看看下图中的例子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE36348a92fbdf15358fd086ea1bcb80f5.png)

这个结果似乎有些楚人意料，之所以会产生这个结果是因为重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。这样说可能有些云里雾里，简单来说就是只有我们调用对象中的方法的时候其才会调用其真实对象，而如果我们只是给其定义了一个类型然后直接传入给对应类调用方法，那么最终其会认为这三个类都是我们之前指定的类型然后进入到对应的方法中并执行，具体就体现在上面的三个结果都是animal

最后我们来谈谈什么是双分派，简单来说，双分派就是在选择一个方法的时候，不仅仅要根据消息接收者的运行时区别，还要根据参数时的运行区别

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcaf446adc190aea46faba694203646e0.png)

我们这里首先创建动物对象，而其下定义一个Execute对象的方法，该方法会调用Execute对象的excute方法，调用内部的方法需要传入一个具体的动物对象，其会根据对应的动物对象来执行对应的方法。

那么我们在测试类中先创建这个三个方法，然后创建一个Execute对象，接着我们分别调用三个对象的accept方法传入exe对象，此处我们调用子类的真实方法，就完成的动态分派，然后我们在对应的子类的方法中，会将自身对象传入给exe对象中，此处就是实现了静态分派，定义一个对象并传入，而exe类又会根据对应的类执行对应的方法，最终就能够得到我们想要的结果，那么在这个过程中我们就实现了双分派

双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了

简单来说，双分派的作用就是可以实现我们的动态重载，虽然比较麻烦就是