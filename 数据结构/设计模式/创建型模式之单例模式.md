接着我们来学习第一种模式，创建型模式。创建型模式的主要特点是将对象的创建与使用分离，使用者不需要关注对象的创建细节，可以降低系统耦合度

创建型模式一共有五种，分别是单例模式、工厂方法模式、抽象工程模式、原型模式、建造者模式。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb6d044965ebb00e3dfd27531b2ba3266.png)

- 单例设计模式

单例设计模式主要包含以下两个角色

1、单例类。只能创建一个实例的类

2、访问类。使用单例类

单例设计模式的设计分类总分为两种：

饿汉式：类加载就会导致该单实例对象被创建

懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建

我们先来将饿汉式设计，饿汉式的设计又可以再细分为两种方式，一种是静态变量方式，另一种是静态代码块方式。我们先来讲第一种，我们可以写入其代码如下

```
/**
 * 饿汉式
 *      静态变量创建类的对象
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance = new Singleton();

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

我们上面的代码就是采用静态变量方式的饿汉式设计，我们先设计一个静态对象变量并令其创建我们的当前对象，然后对外提供静态方法令其可以获得该静态对象。这里有两点需要提，第一点是我们的对外提供的方法为什么要是静态方法，因为如果我们不提供静态方法，那么使用者必须创建该对象才能使用该方法，然而使用者使用该方法就是为了创建过该对象，这样就俄罗斯套娃了，所以我们一开始就要提供可以获取该对象的静态方法，这样使用者即使不创建该类的对象也可以调用该方法。同时由于我们的方法是静态方法，我们的静态方法不可以调用非静态的成员变量，因此我们的成员变量也必须设计为是静态的。

最后是关于为什么静态方法不可以调用非静态变量的解释

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEadb68bba0b7fedab04f0c09d10f3b759.png)

接着我们来讲讲静态代码块的方式，其实静态代码块的方式的原理和静态变量的原理几乎一模一样，无非是创建对象的过程放到了静态代码块中了，其作用是如果我们的一些类的创建之前需要执行一些其他的代码操作的话，我们可以使用这种方式

```
/**
 * 饿汉式
 *      在静态代码块中创建该类对象
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

值得一提的是饿汉式由于其变量都是静态变量，因此无论我们调用多少次其提供的静态方法，得到的对象都会是同一个对象。同时饿汉式存在的重大问题在于，如果说这个类一开始就被加载好了，但是却没有被使用，那么就会造成内存的上的浪费。

最后我们来讲一种重量级的饿汉式，就是枚举方式，直接创建一个枚举类然后其下写入对应的变量名即可，用户想要使用就直接调用枚举类里的变量即可，现在枚举方式也是我们极力推荐的一种单例实现模式。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE49c2dde9080995e8d2c838836cf742f0.png)

同时枚举的写法不但简单，而且无法被破坏，至于什么是破坏，我们留到后面再来讲

饿汉式讲完之后，接着我们来将懒汉式，懒汉式就可以避免内存浪费的问题，因为其是只有使用时才会创建对应的对象，懒汉式同样也有多种实现方式，我们挨个讲。

首先我们来讲第一种懒汉式方式，我们这种的原理跟之前的也差不多，只不过我们每次进入对应方法的时候都要判断该对象是否已经创建而已，其最后的结果同样也是遵从返回的都是同一个对象的结果的

```
/**
 * 懒汉式
 *  线程不安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

但是上面的这个的代码是线程不安全的，在多线程的情况下会出现创建出多个不同对象的情况，要解决这个问题也很简单，加个线程同步的关键词即可

```
/**
 * 懒汉式
 *  线程安全
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static synchronized Singleton getInstance() {

        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

虽然说上面的代码解决了线程不安全的问题，但是其存在的问题是效率太低了，实际上，我们分析上面的代码，容易知道多线程只有在创建对象时才会产生问题，而对于单纯的判断而言，是不会有什么问题的，所以我们可以缩小锁的范围，这里我们就可以使用我们的双重检查锁模式，请看下面的代码

```
/**
 * 双重检查方式
 */
public class Singleton { 

    //私有构造方法
    private Singleton() {}

    private static Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例
        if(instance == null) {
            synchronized (Singleton.class) {
                //抢到锁之后再次判断是否为null
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

我们可以看到我们这里先判断我们的对象是否为空，如果不为空则直接返回对应的对象，如果为空的话我们再执行同步代码块，判断我们的对象是否为空，若为空再执行创建即可。说实话，我其实不太理解为什么这样做就可以有效提高效率，但是这里我们总之先记住就可以了。

最后我们上面这份代码在多线程的情况下可能会出现空指针异常，其原因在于JVM在实例化对象时会进行优化和指令重排序操作，要避免这种问题就就要使用volatile关键字来保证其可见性可有序性（这方面的内容和多线程有关，这里就不深入讲了）

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0b26df5051a448d1eaa24d8e9cb18b04.png)

```
/**
 * 双重检查方式
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    private static volatile Singleton instance;

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际
        if(instance == null) {
            synchronized (Singleton.class) {
                //抢到锁之后再次判断是否为空
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

最后我们来介绍一种重量级的方式，这种方式是我们目前最常用的懒汉式方式，就是静态内部类方式。

由于静态内部类单例模式中实例由内部类创建，且 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序，所以能够做到当使用时才创建对应的对象的目的

```
/**
 * 静态内部类方式
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

我们在我们的类中再定义一个静态内部类，该类中就拥有一个外部类的私有静态属性（并直接创建），该类外则提供一个直接获得该类内部属性的方法，最终来达到我们的目的。由于静态内部类不会在类加载时创建，所以不会有内存浪费，而当我们调用了该类的方法时，该类又会被自动创建出来，此时就达到了需要时再创建的效果了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa6ac4928615ed438311dc41b9098f176.png)

- 序列化破坏单例模式

接着我们来学习如何序列化破坏单例模式，所谓破坏单例模式，其实就是使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。我们首先来学习序列化方式

要想要序列化，当然首先要将我们给我们的Singleton实现序列化接口，然后我们正式来做我们的序列化工作，我们创建两个方法，一个是将单例模式产生的对象放到我们对应的硬盘中，第二个方法是从对应的地址中读出该对象，我们先调用一次写方法，然后调用两次读方法，接着看看看两者的地址是否相同

```
package com.itheima.reggie.design;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
 * 测试序列化破坏单例模式
 */
public class Client {
    public static void main(String[] args) throws Exception {
        //writeObject2File();
        readObjectFromFile();
        readObjectFromFile();
    }

    //从文件中读取数据（对象）
    public static void readObjectFromFile() throws Exception {
        //1.创建对象输入流对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:\\a.txt"));
        //2.读取对象
        Singleton instance = (Singleton) ois.readObject();

        System.out.println(instance);

        //释放资源
        ois.close();
    }

    //向文件中写数据（对象）
    public static void writeObject2File() throws Exception {
        //1.获取Singleton
        Singleton instance = Singleton.getInstance();
        //2.创建对象输出流对象
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\a.txt"));
        //3.写对象
        oos.writeObject(instance);
        //4.释放资源
        oos.close();
    }
}

```

结果会发现该两者是不同的，这里有的同学可能会疑问为什么同一个对象两次读取最后的结果会不一样，因为实际上两次读取涉及到了拷贝，这里他们的值是一样的，但是在内存中的地址是不同的，更多的解释就涉及到了深拷贝相关的知识，这里我们就不在提了

那么我们要如何解决这个问题呢？其实解决的方法很简答，直接在我们要序列化的对象上加上readResolve方法即可，我们设置了这个方法，这样我们进行反序列化时就会自动调用该方法

```
//当进行反序列化时，会自动调用该方法，将该方法的返回值直接返回
public Object readResolve() {
    return SingletonHolder.INSTANCE;
}
```

这里面的所以然是要分析源码的，有时间自己看吧，反正我们记住我们只要构造这个名字的方法，这样序列化再创建对象时就会调用该方法就可以了，使用这种方法即可解决序列化

接着我们来学习反射破坏单例模式，我们容易构造我们的代码如下，最后我们容易看到运行结果，用反射获得的两个对象并不是同一个对象，这样也破坏了我们的单例模式

```
/**
 * 测试反射破坏单例模式
 */
public class Client {
    public static void main(String[] args) throws Exception {
        //1.获取Singleton的字节码对象
        Class clazz = Singleton.class;
        //2.获取无参构造方法对象
        Constructor cons = clazz.getDeclaredConstructor();
        //3.取消访问检查
        cons.setAccessible(true);
        //4.创建Singleton对象
        Singleton s1 = (Singleton) cons.newInstance();
        Singleton s2 = (Singleton) cons.newInstance();

        System.out.println(s1==s2);
    }
}
```

那么我们要如何解决这个问题呢？其实也很简单，由于反射每次调用的都是构造方法，所以我们要在构造方法上下功夫，我们先定义一个布尔类型的成员变量，然后我们判断其值是否为真，若为真则说明不是第一次进入，我们就抛出异常，不是则说明是第一次，我们就令其正常调用该方法，同时将布尔类型的值设置为true

同时为了防止出现线程不安全的问题，我们这里还要使用线程同步关键词将对应的代码块封锁住

```
package com.itheima.reggie.design;

import java.io.Serializable;

public class Singleton implements Serializable {

    private static boolean flag = false;

    //私有构造方法
    private Singleton() {
        synchronized (Singleton.class) {
            //判断flag的值是否是true，如果是true则是非首次访问，抛出异常
            if(flag){
                throw new RuntimeException("不能创建多个对象");
            }
            //将flag的值设置为true
            flag = true;
        }
    }

    //定义一个静态内部类
    private static class SingletonHolder {
        //在内部类中声明并初始化外部类的对象
        private static final Singleton INSTANCE = new Singleton();
    }

    //提供公共的访问方式
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

```

最后我们来看看在我们的JDK中哪些类使用了单例设计模式，其中最为经典的就是我们的Runtime类，该类就是使用了单例设计模式中的饿汉式，请看源码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE17dded7f45caca7488c21a8a13460d56.png)

可以看到其自己拥有自己的一个静态属性，并且提供了无参的构造方法和获得对象的静态方法

最后再来看些科普知识，通过exec方法，可以获得含有对应信息的对象，可以将信息调出来，达到跟在控制台上获取对应信息同样的效果

```
package com.itheima.reggie.design;

import java.io.InputStream;

public class RuntimeDemo {
    public static void main(String[] args) throws Exception{
        //获取Runtime类的对象
        Runtime runtime = Runtime.getRuntime();

        //调用runtime的方法exec，参数需要一个代表命令的字符串
        Process process = runtime.exec("ipconfig");

        //调用process对象的获取输入流的方法
        InputStream is = process.getInputStream();
        byte[] arr = new byte[1024 * 1024 * 100];

        //读取数据
        int len = is.read(arr); //返回读到的字节的个数
        //将字节数组转换为字符串输出到控制台
        System.out.println(new String(arr,0,len,"GBK"));
    }
}

```

