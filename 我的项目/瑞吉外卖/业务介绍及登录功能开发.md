哎呀，终于开始做项目了兄弟们，这次我们做的这个项目是一个十分简单的小的外卖项目，做完了之后有收获就行了，这个笔记是用于记录做项目时遇上的难点重点以及我们解决的方法的笔记，以后面试的时候指不定用得上

- 软件开发整体介绍

首先我们来介绍下我们的软件开发流程，这个自己看图就行了，不多谈了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8292118b9caa79ea207977d4b629161c.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4ca001699c600bd9a31c21826171cdaa.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE41f843f63e4578db99b07c2b5fbafad7.png)

- 瑞吉外卖项目整体介绍

接着我们来学习对瑞吉外卖的项目整体的介绍，这个直接看图就行了，如果看不明白，那么就去看黑马视频里的P3，这里我们就不一一赘述了。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6deea2c6e381a551e05732dfe7aeeb53.png)

然后我们来看看我们的这个项目用得到的技术

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1921590edd3e548aebd8514ec7cc9eb1.png)

然后我们来看看我们的项目所拥有的功能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE430c964552520fca170f998a5d43d1d3.png)

最后来看一下我们的项目所拥有的可能的角色及其他们应该具有的功能

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb03594bcf0b593ce6546dfd69063e7e6.png)

- 数据库环境搭建

本章节我们要进行一个数据库环境的搭建，搭建有两种方式，第一种是利用图形方式

我们这里的各种表后续我们用到了再提，我们这里现在自己看一下就行了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE377e8f03361919df29fc518dece42ae3.png)

- 开发环境搭建

接着我们来做开发环境的搭建，首先我们要在我们的pom文件中导入对应的坐标，当然这里的前提是我们已经创建好了一个maven工程了，我们往其中的pom文件写入其代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.itheima</groupId>
    <artifactId>reggie_take_out</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.2</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.76</version>
        </dependency>

        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.23</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.5</version>
            </plugin>
        </plugins>
    </build>

</project>
```

然后我们导入我们的资源里的yml的配置设置文件，当然我们这里的连接的url是需要更改的，我们这里先提一下，真正需要修改的时候我们再来修改

```
server:
  port: 8080
spring:
  application:
    name: reggie_take_out
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
      username: root
      password: root
mybatis-plus:
  configuration:
    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: ASSIGN_ID
```

然后我们在resources文件夹中加入我们的静态资源和动态资源，一般来说，我们的静态资源是要放到我们的static文件夹中的，但是我们这里没有这么做，那么为了解决这个问题，我们可以在我们的启动类中创建一个配置类文件夹并创建一个配置类，然后写入其代码如下

```
package com.itheima.reggie.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {

    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        log.info("开始进行静态资源映射...");
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
    }
}

```

通过上面的代码，我们就可以将网址中的映射正确导向到我们的文件路径中了

最后我们编写一个启动类，然后启动我们的SpringBoot即可

```
package com.itheima.reggie;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@Slf4j
public class ReggieApplication {
    public static void main(String[] args) {
        SpringApplication.run(ReggieApplication.class,args);
        log.info("项目启动成功");
    }
}
```

最后我们要提一下什么是Slf4j，其实就是类似于log4j的日志文件，我们可以这么简单的理解，如果要看更加详细的说明请参照本文档https://www.jianshu.com/p/6f7f70cc7485

- 后台系统登录功能的需求分析

首先我们来进行需求分析，我们这里进入到我们的登录页面，按F12进入到控制器，然后我们发送请求看控制器中的记录情况，这里会显示我们发送了一个post请求，并且发送的也是json数据的格式，这些都是老生常谈就不多提了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9e3f4fc02c0f8be8793ef58f86fd5ed4.png)

然后我们来看看我们要用到的数据模型

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe8974619dfe7431459845ad66f73881c.png)

最后我们来分析下我们的前端页面，前端页面里最重要的是分析这一段代码，我们可以看到我们返回的请求里，有用于判断是否成功的code，有数据内容data以及提示信息msg，也就是说，我们后端构造我们的返回的类的时候，一定要有这三个内容，那么我们就可以得到我们的后端开发目标

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf5e20d23db458f8bbc5ce5afe85b665d.png)

- 后台登录功能的代码开发

接着我们正式到我们的代码开发阶段，我们这里开发就很简单了，因为我们的mybatisplus，简化了我们的许多开发内容

首先我们要创建一个对应的员工实体类并写入其代码

```
package com.itheima.reggie.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import lombok.Data;
import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * 员工实体
 */
@Data
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;//身份证号码

    private Integer status;

    private LocalDateTime createTime;

    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT)
    private Long createUser;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;

}

```

后面的TableField注解我们后面用到的时候再来解释，同时我们的对应属性可以和数据表中对应字段对应上是因为我们开启了我们的驼峰命名法，其会自动去除数据表中字段的下划线并将下划线后的第一个字母改为大写

然后我们创建对应的三个文件夹，对应我们的三层调用，分别是controller、serivce、mapper，其中我们的实体类放置在entity包下

mapper包下的实体类直接令其继承BaseMapper即可

```
package com.itheima.reggie.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.Employee;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface EmployeeMapper extends BaseMapper<Employee> {
}

```

然后我们来写service包下的内容，首先我们创建对应的service包下的接口，令其继承Iservice

```
package com.itheima.reggie.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.Employee;

public interface EmployeeService extends IService<Employee> {
}

```

然后写入其实现类，令其继承ServiceImpl并且令其实现我们之前设置的接口

```
package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.Employee;
import com.itheima.reggie.mapper.EmployeeMapper;
import com.itheima.reggie.service.EmployeeService;
import org.springframework.stereotype.Service;

@Service
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployeeService{
}

```

然后我们还需要创建一个通用包，里面存放我们返回的通用结果类，我们可以写入其代码如下，其中的动态数据等到我们用到的时候我们再来讲其作用，这里我们先按下不表

```
package com.itheima.reggie.common;

import lombok.Data;
import java.util.HashMap;
import java.util.Map;

/**
 * 通用返回结果，服务端响应的数据最终都会封装成此对象
 * @param <T>
 */
@Data
public class R<T> {

    private Integer code; //编码：1成功，0和其它数字为失败

    private String msg; //错误信息

    private T data; //数据

    private Map map = new HashMap(); //动态数据

    public static <T> R<T> success(T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = 1;
        return r;
    }

    public static <T> R<T> error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }

    public R<T> add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }

}

```

然后我们来确定下我们的密码的比对逻辑，具体如下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcf0d2db0cdadde3169d58287a9da3133.png)

最后我们进入到controller层的代码如下，写入其对应的注解，然后配置其映射为employee，其下用Autowired注解将对应的对象注入到我们的属性中，我们这里的登录方法里提供了request的请求对象，因为我们将数据注入到我们的对应的共享域中需要用（虽然不也不知道注入进去干嘛，不过总之先记着吧）

```
package com.itheima.reggie.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.itheima.reggie.common.R;
import com.itheima.reggie.entity.Employee;
import com.itheima.reggie.service.EmployeeService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.DigestUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@Slf4j
@RestController
@RequestMapping("/employee")
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    /**
     * 员工登录
     * @param request
     * @param employee
     * @return
     */
    @PostMapping("/login")
    public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){

        //1.将提交的密码password进行md5加密处理
        String password = employee.getPassword();
        password = DigestUtils.md5DigestAsHex(password.getBytes());

        //2.根据用户名查询数据库
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        //之所以可以选择查询一个是因为在数据表中已经对用户名进行了唯一约束
        Employee emp = employeeService.getOne(queryWrapper);

        //3.如果没有查询到结果则返回登录失败的结果
        if(emp == null){
            return R.error("登录失败,用户名不存在");
        }

        //4.用户名比对成功，进行密码比对
        if(!emp.getPassword().equals(password)){
            return R.error("登录失败,密码错误");
        }

        //5.查看员工状态，若禁用则拦截该登录
        if(emp.getStatus()==0){
            return R.error("该账号已禁用");
        }

        //6.登录成功，将员工id存出Session并返回结果
        request.getSession().setAttribute("employee",emp.getId());
        return R.success(emp);
    }
}

```

- 退出功能

接着我们来实现退出功能，分析前端代码我们容易知道我们的退出功能会向服务器发送一个请求，因此我们可以在控制层中写入我们的退出方法的代码如下

```
    /**
     * 员工退出
     * @param request
     * @return
     */
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request) {
        //清理Session中保存的当前登录员工的id
        request.getSession().removeAttribute("employee");
        return R.success("退出成功");
    }
}
```

可以看到我们这里做的事情很简单，就是清除共享域中的保存内容并返回退出成功的结果，至于切换页面的事情前端的内容已经帮我们做好了。

最后我们提一下我们这里的PostMapping一类的注解的作用，其作用是指定一个对应的映射路径，和类上的RequestMapping是结合在一起的，结合起来的映射路径最终可以通过一些特定的地址来令其执行我们写好的方法，这个我们一般是通过前端的触发事件来达到这个效果的，点击对应的选项，前端就会自动往后端发送对应地址的请求来执行我们事先设置好的方法

- 完善登录功能

接着我们要完善我们的登录功能，我们现在的登录功能存在的一个很大的问题是，用户可以不登录，直接通过网页跳转的方式跳转到我们的主页面，这当然是不被允许的，我们要避免这种情况，此时我们应该要使用我们的拦截器对象来帮助我们完成这件事

首先我们创建对应的过滤器类，给其加上对应的WebFilter注解，给其取个名字然后拦截所有的请求，接着我们在主方法中加入ServletComponentScan注解，加上该注解之后我们的拦截器类才可以被正确扫描到，然后我们来看看我们的拦截器的逻辑

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfb346503dff3ed2398eac04f8da94515.png)

根据上面的逻辑，我们可以写入我们的过滤器的代码如下

```
package com.itheima.reggie.filter;

import com.alibaba.fastjson.JSON;
import com.itheima.reggie.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 检查用户是否完成登录
 */
@Slf4j
@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    //路径匹配器，支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        //1.获取本次请求的URI
        String requestURI = request.getRequestURI();

        log.info("拦截到请求:{}",requestURI);

        //定义不需要处理的请求路径
        String[] urls = new String[]{
                "/employee/login",//登录
                "/employee/logout",//登出
                "/backend/**",//请求静态资源
                "/front/**"//请求前端静态资源
        };

        //2.判断本次请求是否需要处理
        boolean check = check(urls,requestURI);

        //3.如果不需要处理，则直接放行
        if(check){
            log.info("本次请求{}不需要处理",requestURI);
            filterChain.doFilter(request,response);
            return;
        }

        //4.判断登录状态，如果已登录则直接放行
        if(request.getSession().getAttribute("employee")!=null){
            log.info("用户已登录，用户id为:{}",request.getSession().getAttribute("employee"));
            filterChain.doFilter(request,response);
            return;
        }

        log.info("用户未登录");
        //5.如果未登录则返回未登录结果，通过输出流的方式向客户端页面响应数据
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
    }

    public boolean check(String[] urls,String requestURI){
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url,requestURI);
            if(match) return true;
        }
        return false;
    }
}

```

我们这里用AntPathMatcher类来辅助我们判断URI地址是否是我们要拦截的，然后我们这里确定了要拦截了地址之后，由于前端已经有拦截器了，因此我们这里不需要手动进行页面的跳转，直接利用前端的页面拦截器进行页面跳转就可以了，这里只需要返回一个JSON格式的错误信息并写着NOTLOGIN即可触发前端的拦截器令页面图跳转到登录页面

最后我们前端的拦截器的代码也可以通过F12直接在网页端进行调试，非常方便