之前我们学习了二叉查找树以及红黑树，但他们每个结点最多存储两个key，比如在红黑树立就利用红链接组成3-结点存储两个key。那么接下来我们就学习能够存储多个key的数据结构，B树

B树

B树中允许一个结点包含多个key，能包含多少个key，我们就称该树为多少阶的B树，姑且将这个多少用参数M来代替，那么B树就有三个重要性质

1-每个结点最多有M-1个key，并且以升序排列

2-每个结点最多有M个子节点（两边各有一个结点，每两个数据间又会夹杂一个结点，总和为M）

3-根结点至少有两个子节点（至少两边各有一个结点）

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbb138d10f99bb0b2fa1a9b509337f438.png)

在我们的实际场景中，B树的阶数通常是大于100的，所以即使存储大量的数据，B树的高度仍然比较小，在某些应用场景里就能体现出这个数据结构的树的高度小的优势



B树的插入原理

接下来我们来具体讲解下其是如何完成插入动作的，请看图，这里我们取M=5为例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE84c947db340142e89d51e3d73696dc91.png)

可以看到我们先插入39，此时39最小因此我们将其置于最左边。接着插入22，97,41，全部按照升序排列，最终就将一个树插满了元素，然后我们再插入53

此时53比41大比97小，此时就会产生个一个临时的6-结点，其数据分别是22,39,41,53,97，而我们要将结点中间的数据往上提，就是把41往上提，然后分别构建三个新的未填满的5-结点

接着我们继续插入53，按照二叉查找树的查找原则查找就将其添加在根结点的右子树中的第一个中，再插入13,21，那么左子树就填满了

然后我们再插入40，此时40小于41又大于39，则根结点的左子树形成了一个临时的6-结点，其数据是13,21,22,39,40，此时我们将中间的数据往上提，那么22提出来和41组合，然后产生两个新未填满的5-结点，同样的还有一个先前存在的5-结点，他们都被根结点所连接

接着我们插入30,27,33,36,35,34,24,29，那么根结点和根结点其下的一个子树就都被填满了，接着我们插入26，显然26大于24但是小于27，于是在其左子树下形成一个临时的6-结点24,26,27,29,30，我们将中间的27往上提，剩下的两个数据形成两个新的5-结点，提上去的27又和根结点刑形成一个新的6-结点22,27,33,36,41，此时将33提出来，形成三个新的未满的5-结点，并最终将他们分别指向

其实整个过程和2-3树差不多，无非是这里复杂了些罢了，本质还是没变的



B树在磁盘文件中的应用

那么讲了这么久，我们还是要回归到一个本质问题，就是B树就什么用呢？这我们就得先讲解我们的磁盘保存和传入传出数据的原理

首先磁盘由盘片构成，每个盘片有两个盘面，盘片中央有可以旋转的主轴，使盘片以固定速率旋转，通常是5400rpm或7200rpm，盘片每个表面由一组成为磁道同心圆组成的，每个磁道被划分为了一组扇区，每个扇区包含相等数量的数据位，通常是512个字节扇区之间由一些空隙隔开，这些空隙不存储数据

一个磁盘中包含了多个这样的盘片封装在一个密封的容器内

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE139ccdf07c119537464016462e8ce8df.png)

那么磁盘是如何被读取的呢？这里我们要提及磁头这个概念，磁盘是用磁头来读写存储于盘片表面的数据的，一次对磁盘的访问要经过三个阶段，分别是利用移动臂将磁头定位到对应磁道的寻道时间，磁盘本身要进行旋转让数据被磁头读取旋转时间，以及将数据从磁头传送过来的传送时间

由于存储介质的特性，磁盘本身的存储是比较慢的，但是顺序读取的效率是比较快的（不需要寻道时间，只需要很少的旋转时间），为了提高效率，所以我们要尽量减少对磁盘的读取，为了达到这个目的，磁盘往往不是按需读取的，而是每次都会预读入一定长度的数据放入内存中，预读的长度一般是页的整数倍

那么什么是页呢？页是计算机管理存储器的逻辑块，硬件及操作系统往往将内存和磁盘存储区分割为连续的大小相等的块，每个存储块就成为一页（其大小为1024个字节或其整数倍）

内存和磁盘以页为单位交换数据，程度就在内存中读取数据，当程序要读取的数据不在内存中时，会触发缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的其实位置并向后连续读取几页载入内存中，然后异常返回，程序继续运行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE03d832bc0dadd4ce131bdd9b96b9eba6.png)

文件系统的设计者就利用了磁盘预读原理，将一个结点的设为等于一个页的大小，这样每个结点只要一次I/O就可以完全载入，那么三层的B树就可以容纳大概10亿个数据，如果换成二叉查找树，就需要30层

显然30层比3层的查找效率要低得多，因此B树在这里其高度小的优势就出来了，能够大大提高IO的操作效率



B+树

学习完了B树之后，现在我们来学习B+树，B+树其实是B树的一种变形树，其与B树主要有这两点差异

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6f542fddf9e1752cf7003e8cbc24b7e1.png)

也就是说，B树只在叶结点处存储对应的数据，且所有的叶结点共同组成了一个链表



B+树的插入原理

现在让我们来学习下B+树的插入原理，同样的我们以M=5为例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE157057e61460a0d4998b8e0acf5516bb.png)

我们现在空树中插入5，8,10，15，此时填满了第一个树，再插入16就形成了临时的6-结点5,8,10,16,15，我们将10的值提出，形成三个未满的5-结点，但与B树不同的是，我们只提出10的值创造一个新结点，而其他的值按照左二右三的分配方式分配到两个新创建的左右子树中

其他的过程和B树的几乎是一模一样，我这里就不多提一遍了



B树和B+树的对比

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1192db52c68c9bffc691185d29f88dee.png)

简而言之，B+树对比B树在同内存中B+树能存放更多的key，其次是B+树对整棵树进行遍历可以线性遍历叶子结点，而B树则要使用到递归遍历，显然前者更加简单方便

但是B树也有优点的，B树的优点在于只要找到key就能找到value，如果想要通过key找到value除非你在最坏情况下，不然肯定比B+树方便，因为B+树一定要定位到子节点才能找到对应的value



B+树的数据库引用

我们都知道在数据库的操作中，查询是最频繁的操作，因此我们在设计数据库中首先要考虑的就是数据库的查询效率，为了提高查询效率，我们可以基于某张表的某个字段建立索引来提高查询效率，其实这个索引就是B+树这种数据结构实现的

我们不妨先来看看这张表

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4b46a273bc88a56ef6c208bbdcb3e8c9.png)

假设我们要查找id为8的数据，那我们就只能从头开始遍历，那就要查找6次

接着我们来建立主键索引查询

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE29cad478b484dd2e7b9e2ebb6fee768f.png)

那么建立完了主键索引查询之后，我们此时要查找到18的话，只需要三次查询就够了，第一次查询定位到第二个结点，第二次是12，第三次到18

而有时候我们需要建立区间查询，比如说我们要查找12-22区间的数据，这时由于B+树底部是按照升序排序的，因此区间查找也会很方便，效率也很高



并查集

接着我们来学习树的最后一种结构，并查集。并查集是一种树型的数据结构，并查集应该要可以高效执行查询元素PQ是否在同一组以及合并元素p和元素q所在的组这两个动作

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbd90dab0f6a546ac959ed3e9d2308804.png)

并查集相对二叉树红黑树B树那些而言，其要求要简单得多，主要有以下四个

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE906a3ae3fb97dfa74d77bb42cb3e3c26.png)

具体我们可以看下面的例子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4a1297d527294101720e34279ce35be1.png)

可以看到我们一共有三组数据，每组数据都对应一棵树，而且树中的结点排序没有什么固定要求，两个不同组就对应不同的树，树与树之间也没有任何联系

那么我们要如何去实现并查集的两个重要方法呢？就第一个而言，判断两个结点是否是同一组，其实就是判断两个结点是否是同一棵树，那么我们只要判断这两个结点的根结点是不是一样的就行了，如果是则说明其为同一组，反之则说明不是同一组

而我们要实现合并两组数据的方法的思路也很简单，只要将要合并的两组数据的其中一个根结点指向另一个的根结点就行了

接下来我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcb28d6f9be7e085eb54a6ce3ef5e70f0.png)

这里我们成员变量主要有二，一是一个int类型的数组，该数组不但可以记录结点元素，还可以记录该元素所在分组的标识，而第二个int类型的变量则是用于记录并查集中的分组个数，注意是分组个数，而不是元素个数

在实现代码之前，我们要先讲讲其构造方法的实现

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfe8b587d519c043a1f3645acc47f4375.png)

初始情况下，每一个元素都有一个独立的分组，因为当我们传入数据为N时，我们的并查集就就有N个组，而且我们将其索引的值都存储到对应索引中，这里就是将每个索引的对应的值赋给对应数字的位置用来视为分组的标识符，每个标识符都不一样，因此传入N，就会有N个组

这个可能不是特别好理解，但是多看几遍其实还是能理解到的，下面也有加深理解的案例，所以不用太慌

接着我们再来讲下合并方法的实现

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0d9475a40de51058c4b6d8885f181bca.png)

我们之前讲过实现两个不同组的思路是将其中一组的头结点指向另一个组的头结点就完了，那么在数组底层中我们可以转变成将两个拥有不同标识符的元素的组中的其中一组的标识符变成另外一组的标识符，比方说在上图中的元素一共处于三个组中，其中013处于一个组，245处于一个组，678处于一个组，如果我们想要将013组与245组合并，我们只需要将013的索引处的值全变为2或者是245索引的值全变为0就行了

那么根据上面的理解我们可以构造其代码如下

```javascript
package algorithm.sort;

/*
 * 这个并查集本身倒是不难理解，但是说实话，最开始讲并查集的时候是有
 * 树的，但后面实现并查集的代码是用数组实现的，只不过我们理解时可以
 * 将其抽象为树的实现，说实话这个抽象过程还是挺难理解的，如果直接理
 * 解成数组的话感觉要容易理解得多，而且并查集的底层用数组来实现的方
 * 式说实话效率不高
 * 但总之是实现了，实现了就行了
 */
public class UF {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //初始化并查集
    public UF(int N){
        //初始化分组的数量，默认情况下，有N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //将数组中每个索引的值赋予数组内部，代表不同分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //元素p所在分组的标识符
    public int find(int p){
        return eleAndGroup[p];
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connect(int p,int q){
        return find(p) == find(q);
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //判断元素pq是否已经在同一组中
        if(connect(p,q)){
            return;
        }
        //代码执行到此说明不为同一组
        
        //先找到p所在分组的标识符
        int pGroup = find(p);
        
        //找到q所在分组的标识符
        int qGroup = find(q);
        
        //合并组：将p所在组的所有元素的组标识符变为q所在组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            if(eleAndGroup[i]==pGroup){
                //如果其为p分组的表示符，则将其修改为q分组的标识符
                eleAndGroup[i] = qGroup;
            }
        }
        
        //分组个数-1
        this.count--;
    }
}
```



并查集的应用场景及其缺陷

那么并查集有什么用呢？我们可以假设我们并查集里存储的每一个整数是一个网络中的计算机，此时我们就可以通过connected(int p,int q)来检测其是否联通，若联通则说明可以通信，反之则不行。如果不连通的话，那么我们还可以调用union方法令其联通

但是，如果我们要对N个不同组的计算机全部连通的话，我们要调用几次union方法呢？答案是N-1次，而我们每次调用union方法又要进行一次数组遍历，那我们合并算法的时间复杂度就是O(N^2);，这显然是需要优化的算法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf9b32791756ca7c9cdeec5163b9c1671.png)



UF_Tree算法优化

那么为了提高union算法的性能，我们需要重新实现find和union方法，此时我们需要对数组中的含义进行重新定义

我们仍然让数组的索引作为某个结点的元素，但该结点的值不再是当前结点所在的分组表示，而是该结点的父节点（其实我一开始我就是这么理解的，结果一开始它居然不是这样的形式，终究还是错付了啊）

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE38eb17e1997683c59e619e23c7572f71.png)

在API设计上，我们不用做什么改动，只需要将find和union方法进行修改就可以了，那么我们现在先来讲讲find方法的实现原理，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8d05fe25b6dc45678135c58ead8cecc8.png)

光看图理论可能难以理解，我们来直接看看演示图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc0162233653aa7642ed9c206e37a1aba.png)

我要说的话图上都说完了，不就不重复一遍了，这里我说点别的。

虽然这里底层是调用的是数组的结构，但其实我们是可以将其抽象为一个树的结构的，只不过这个树没有指向，只有连接而已，说实话这可比上一个并查集要好理解多了

那么接着我们来讲下如何实现合并方法，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE46a835b53e997bd53281d6cc5b412e38.png)

我们先找到pq的根结点，再判断其是否在同一个树中，若是，则无需合并，若不是则进行合并，合并的过程很简单，只要将p元素的根结点设置为q元素的根结点即可，为什么这样设置就可以完成合并了呢？请看下图的演示过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE92622861c76861e65b0f1c472cf2c70b.png)

可以看到，我们通过数组能抽象出两个树，其根结点分别是5和8，我们只要将5索引处的值5改为8索引处的值8，那么就是完成了数组的合并了，因为此时我们同样进行树的抽象能够抽象出一个完整的具有先前两个树的结点的一个树来

而且这个树的根结点为8，左右子树分别为0135,76。这里我们是让长的树被短的树的根结点指向，但如果我们令其过来，令短树被长树指向，那么我们的树的就会变成根结点是5，左右子树分别为013,678的树，但无论是何种情况，我们都能够将树合并，只是树的样子有所不同罢了

那么综上我们可以实现并查集的改良代码如下

```javascript
package algorithm.sort;

public class UF_Tree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //初始化并查集
    public UF_Tree(int N){
        //初始化分组的数量，默认情况下，有N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //将数组中每个索引的值赋予数组内部，代表不同分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //查找某个结点的父节点
    public int find(int p){
        //此处传入的p是我们要查找的结点
        while (true){//构建不断查找的循环
            //如果要查找的元素p(在数组中对应其索引)正好与其值相同
            //则说明我们找到了其根结点，返回p即可
            if(p == eleAndGroup[p]){
                return p;
            }
            //如果没找到，则令p变为p索引处的值，其动作意义是将p
            //在树中往根结点前进一位，在数组中表达的意义是将p定
            //位到其值所在的索引
            p = eleAndGroup[p];
        }
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connect(int p,int q){
        return find(p) == find(q);
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //找到p元素和q元素所在组对应的树的根结点
        int pRoot = find(p);
        int qRoot = find(q);

        //判断pq是否已经在同一分组
        if(pRoot==qRoot){
            //如果已经在了则无需合并，直接结束方法
            return;
        }

        //让p所在的树的根结点的父节点为q所在树的根结点的父节点
        eleAndGroup[pRoot] = qRoot;
        
        //组的数量-1
        this.count--;
    }
}
```

那么我们同样来分析下改良后的并查集的时间复杂度，由于我们优化了union方法，此时我们只要调用N-1次union方法就能达到目的，而union自身每次运作只要一次就能定位成功，因此时间复杂度就变成了O(N);

但是不幸的是，由于我们还修改了find算法，而修改后的find算法里构建while循环，当我们的find算法遇到最坏情况时，其复杂度时O(N);

而我们又在union方法中调用了find方法，因此我们的时间复杂度仍然为O(N^2);

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE80cb349ce604c40f7ae6d31eb38bd9ad.png)

显然，我们还要对代码进行进一步的改良。那么我们改良的思路是什么呢？可以看到，我们之所以会出现时间复杂度为O(N^2);的情况是因为当我们的find算法遇见了最坏情况时其复杂度是O(N);，而之所以其会出现时间复杂度为O(N);的情况是因为我们的抽象的树的高度太高了，这样每次要取到父节点都要循环遍历到最底部才能找到父节点，那如果我们能够让树的高度保持在一定程度时，那是不是就能够有效降低其时间复杂度了呢？因为当我们的树总是在一定高度时，那我们无论是用寻找哪个结点的父节点，其总运算次数总是会小于该树的最大深度

那我们要怎么让树的高度降低呢？我们的一个简单想法就是当两个抽象树合并时，我们让结点数量较低的树的根结点被结点数量较高的树的根结点所指向，这样我们可以构造出一个高度不会增加的新树了，如下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE03ed1fae113d4ac88c0a432a2db8edb0.png)

为了实现这个目的，我们需要另外一个数组来记录存储每个根结点对应的树中的元素，并且需要一些代码来调整数组中的值。同时我们也要修改union方法里的代码，再不能让其进行如此简单暴力的无脑指向，应该每次都准确地让小树被大树指向

来看看最终改良的并查集的API设计吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE405a80d3f9f78c70454e1210a7e04b55.png)

除了多了一个数组之外，其他方法倒是没有什么不同

那么我们可以构造最终改良并查集的代码如下

```javascript
package algorithm.sort;

public class UF_Tree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //用来存储每一个根结点对应的树中保存的结点的个数
    private int[] sz;
    //初始化并查集
    public UF_Tree(int N){
        //初始化分组的数量，默认情况下，有N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //将数组中每个索引的值赋予数组内部，代表不同分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }
        this.sz = new int[N];
        //默认情况下,sz中每个索引处的值都是1,此处其抽象意义表示的是每个树中
        //都只存储着一个根结点
        for (int i = 0; i < sz.length; i++) {
            sz[i] = 1;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //查找某个结点的父节点,也是根结点，union方法里需要此方法
    public int find(int p){
        //此处传入的p是我们要查找的结点
        while (true){//构建不断查找的循环
            //如果要查找的元素p(在数组中对应其索引)正好与其值相同
            //则说明我们找到了其根结点，返回p即可
            if(p == eleAndGroup[p]){
                return p;
            }
            //如果没找到，则令p变为p索引处的值，其动作意义是将p
            //在树中往根结点前进一位，在数组中表达的意义是将p定
            //位到其值所在的索引
            p = eleAndGroup[p];
        }
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connect(int p,int q){
        return find(p) == find(q);
    }

    /*
     * 说实话我觉得这里union方法还有问题，而且创建的数组不是为了表示抽象树的高度而是元素个数
     * 我也觉得有些奇怪，总感觉某些地方过不去又或者说是很奇怪，而且在抽象图上我也不能理解地特
     * 别明白，只能说明白个七七八八而已。但我又没法举出一个很好的反例出来，那就先这样吧
     */
    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //找到p元素和q元素所在组对应的树的根结点
        int pRoot = find(p);
        int qRoot = find(q);

        //判断pq是否已经在同一分组，因为都是父节点所以可以直接比较
        if(pRoot==qRoot){
            //如果已经在了则无需合并，直接结束方法
            return;
        }

        //先判断pRoot和qRoot谁的树大，并将较小的树合并到较大的树中去
        //都是父节点，因此可以直接传进sz[]中进行其值的比较
        if(sz[pRoot]<sz[qRoot]){
            //如果A小于B，则让A的根结点被B指向，代码上是令A索引处的值变为B索引的值
            eleAndGroup[pRoot] = qRoot;
            //将B树的元素数量加上A树元素的数量
            sz[qRoot]+=sz[pRoot];
        }else {
            eleAndGroup[qRoot] = pRoot;
            sz[pRoot]+=sz[qRoot];
        }

        //组的数量-1
        this.count--;
    }
}
```



畅通工程

最后我们用一个案例来加深我们对并查集的印象，请看题目

![](WEBRESOURCE8dcb9b1e3fe1b1a270ab028ea4f25491)

注意这里的连通是只要A能到达B就算是连通的意思啊，比方说A连通B，B连通C，那么我们也算AC连通，因为A能到达C（这个正好对应并查集里的抽象的树的结构），那么显然这个题目要求就正好对应我们的并查集的情况，因此我们可以利用并查集求解

那我们的思路其实就可以是如图所示

![](WEBRESOURCE60a51d5f422dcf492abd732d1d76b0ac)

这个其实好理解，先将题目的状态表示出来，然后剩余组数-1就是我们还要修建的道路数目。因为其实每调用一次union方法就是让两个城市连通，而我们要让所有城市连通的话，就要调用N-1次union方法，因此我们只需要求出修建七条道路时还剩下的并查集的组数-1就是其还要修建的道路数了

先来看看我们要传入的文件trffic_project的数据放置情况

![](WEBRESOURCEb4f1e64a4a2c89453d3ffffb3145edcc)

那么我们可以构造代码如下

![](WEBRESOURCEbddc88a510f7e20fe536c0c2321451c4)

最后我们来解释下这个代码，构建缓冲读入流的方法前面好理解，后面搞得这么复杂我属实没整明白，回去看JavaSe里的IO内容，也没有提及这种方式，有时间就去问问其他人吧

接着读入第一行代码，该方法是字符输入流BufferedReader的特有方法

然后利用了字符串里的split();方法，可以传入特定字符串然后将字符串按照传入字符串分割开并返回一个分割之后的字符串数组

这里两个数据之间隔着一个空格，因此传入一个空格字符将其分割之后返回

其他的代码就是调用并查集中的方法的代码了，不多提了