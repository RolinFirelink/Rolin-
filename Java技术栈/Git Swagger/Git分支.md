接着我们来学习Git里面的一个重要内容，分支。首先我们来介绍下什么是分支，我们之前说过协同开发，但是难道我们的协同开发到底是怎么实现的呢？其实我们一般是不动我们的主线开发，而是让不同的人开发不同的分支，然后最后确定功能没有问题了，我们再来将分支上的代码合并到我们的主线上。

所以分支简单来说就是你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。接着我们来讲讲我们的关于分支的常用方法

首先我们先来进行一个分支的页面的科普，我们输入git-log，可以看到如下内容

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbf6b076f360957c27f3f73e5cca63bb5.png)

我们这里可以在最后我们的括号内看到master，这个master就代表的是当前分支，如果我们进入了其他分支，那么该名字也会正确转换为其他分支的名字，一般来说，我们的master是作为主支来使用的。其次我们可以在下面看到HEAD和是一个箭头，其代表的就是指向当前的使用的支点，目前我们使用的支点是master，因此其指向master

接着我们来正式讲分支中的常用方法，具体请看下路

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa6c6d345c1dc1fd6f986912c7c970d4c.png)

其中我们最重要的要学习的命令就是创建分支和合并分支，这里我们值得一提的是，如果我在主支上创建了一个文件，又在分支上创建了一个文件，那么这两个分支上在仓库上是否显示与否取决于我们是否切换到了对应的分支，否则其就不显示（但主支上原来就存在的文件会在分支上同样创建一次然后能在分支中查看到同名的文件，但是两者的修改却是不一样的）。

如果我们都希望其能在一个分支上进行显示的话，就要进行分支的合并，一般我们都是将我们的其他分支加到我们的master分支上，一般我们是切换到master分支中，然后写入git merge 分支名称，这样的命令，这样就可以将我们的其他分支合并到当前分支中了，我们调用这个命令其会进入到一个提示页面，这个页面类似于vim，我们先按下不表，直接按shift+冒号，然后输入wq就完了

那么合并之后我们查看其提交记录的显示样式如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6b1c9358102d790d9adac628be92b0db.png)

我们可以看到我们执行的合并操作，并且其下合并的分支就有dev01

- 解决冲突

接着我们来学习解决冲突，什么是冲突呢？简单来说，就是当两个分支上都对同一个文件的同一行进行了修改之后，又对其进行了合并，那git根本就不知道你到底要用哪个，此时就会出现冲突，git往往会将这个冲突交给程序员自己来解决，他自己只负责合并，我们具体来看看其解决冲突的过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6af2aae31aca137a09f509c0c54e92a1.png)

当我们出现冲突后，其会提示合并失败，并提示出现冲突的位置，然后我们进入到冲突位置的文件中查看，可以看到其中已经有了git编辑器给我们写上的冲突位置的标记，HEAD到======代表的是我们当前的分支的代码，而======到后面的分支代表是我们要合并的分支上的代码，两者的差异就代表其冲突的位置，我们修改的方式也很简答，直接将对应的提示代码全删掉，然后将该行改为我们所需要的具体内容就可以了。

之后我们通过同样的添加和提交命令，其会自动识别出我们正在进行合并的动作，在提交完成后会将我们的文件的分支进行一个成功合并。同时如果我们的合并提交时没有使用-m命令，其会提示一个窗口，也类似于文本编辑器，我们直接wq就完了

注意我们这里的冲突一般都是同一行的冲突，如果不是同一行的那他就自动进行一个合并了

- 分支使用流程

接着我们来学习我们的分支开发的规范，实际上我们开发肯定不可能跟我们这里一样瞎几把生成分支是吧。我们先来讲一种最普遍的分支的使用情况，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeaabbe6085d553af31b2c8bb703f9657.png)

首先我们的主支上有一个develop分支，develop分支下有许多的feature分支，develop分支主要用于进行阶段开发功能，开发完成之后我们会将这些功能合并到我们的主支上发布，开发功能当然不是在develop自身上开发的，而是在其下的feature分支上开发的，在该分支上不但开发功能，而且会经过测试，测试通过后就合成到develop分支上，然后为了节省空间，我们的feature分支就可以删除了。

在我们的主支上还有release分支，其不但可以用来标记每次上先的时间点，还可以从中生成新的子支用于bug修复，修复完的版本进行了开发之后要经过测试，测试完成之后就和主支合并，该动作意为bug修复，然后再将其合并到develop中，代表我们的新功能也在我们的develop中了，另外我们一般是不做主支里往分支里合并这种操作的，所以我们总是要从其他的用于bug修复的子支合并到develop上

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3cc51454ddc4acccb6543676cfb9c5bf.png)

当然实际的开发中还有一些其他的分支，比如用于测试的分支，或者是pre预上线分支等，不过这些分支是根据我们不同公司的情况自己设置的，我们这里就不赘述了

最后我们来做一些对应的练习

> ###########################创建并切换到dev01分支，在dev01分支提交 

> # [master]创建分支dev01 

> git branch dev01 

> # [master]切换到dev01 

> git checkout dev01 

> # [dev01]创建文件file02.txt 

> 略

> # [dev01]将修改加入暂存区并提交到仓库,提交记录内容为：add file02 on dev 

> git add . 

> git commit -m 'add file02 on dev' 

> # [dev01]以精简的方式显示提交记录 

> git-log 

> ###########################切换到master分支，将dev01合并到master分支 

> # [dev01]切换到master分支 

> git checkout master 

> # [master]合并dev01到master分支 

> git merge dev01 

> # [master]以精简的方式显示提交记录 

> git-log 

> # [master]查看文件变化(目录下也出现了file02.txt) 

> 略

> ##########################删除dev01分支 

> # [master]删除dev01分支 

> git branch -d dev01 

> # [master]以精简的方式显示提交记录 

> git-log

- 强制删除分支的场景

接着我们来讲下我们需要强制删除分支的场景，这个使用场景我们了解下就好了，并不做强制要求。最经典的应用场景就是我们新创建了一个分支并写入了信息，然后提交，接着我们回到主支上删除这个分支（注意分支不能自己删除自己，因此要删除分支必须到其他分支中），此时普通删除就会提示你还没有合并这个分支而无法删除，因为git认为你这个分支创建出来但是又什么都还没有干，所以你这个很可能是误操作，因此提供这个信息，相当于是要你确定删除这个分支，此时如果我们一定要删除这个分支，我们就直接用-D的选项调用命令来删除这个分支就可以了。其命令是git branch -D 分支名

最后我们可以来做一个小结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0ef658dc2a6aa0cd021e62366d44d04d.png)

- 合并的快进模式

最后我们再补充一个内容，我们先来说这么一种场景，假如我们我们在主干上创建了一个分支，然后切换到分支上创建了一个文件，此时我们将分支提交，我们此时查看我们的提交记录会发现，从上往下，第一个提交记录是我们的分支的提交记录，第二个记录是我们的原来的主干的提交记录，此时我们的第一个提交和第二个提交只差了只是第一个提交的内容有变动而已，此时如果我们再执行合并操作的话，git会智能的识别到我们要做的事，此时就会启动合并的快进模式，直接将主干的位置移动到分支上，此时的结构就不会有原来的那种树型结构了，而是在主干上创建了一个分支的结构，虽然结构不一样，但是他们的作用是一样的

合并之后的结构图如下所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE235f675384f354e48d9421ac13c6833d.png)

当我们的一个分支做了修改另一个没有做且要对这两个分支进行合并时git会自动启动合并的快进模式，反过来，如果我们的两个分支都做了修改，此时要合并，那就只能使用普通方式来进行合并了

- 仓库托管

我们之前说过我们的git除了有本地仓库之外还有远程仓库，我们一般现在已经把本地仓库的内容给讲完了，接着我们来讲远程仓库的内容。

首先，我们的远程仓库有以下三种

> 前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库 

> 呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。 

> gitHub（ 

> 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 

> Git 作为唯一的版本库格式进行托管，故名gitHub 

> 码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 

> GitHub，码云速度会更快 

> GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作 

> 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。

我们这里使用码云来作为我们的远程仓库，因为码云是国内的一个平台，速度比较快。

首先我们进行一个码云的注册，注册过程就不谈了，注册完之后我们创建仓库

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEda1599e37ef1dd82260ef61d8e0cc830.png)

创建完之后我们要将我们的仓库推到我们的git中，我们应该要怎么做呢？一种通用的方式就是使用SSH公钥来推送，首先我们按照下面的步骤在我们的git窗口中配置我们的公钥，接着获取公钥并复制

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE603e849edcd886676a1d5a949c0715c8.png)

然后我们将ssh的公钥的内容全部赋值下来，然后我们进入码云的个人首页的设置页面中，选择SSH公钥，接着复制进去就完了，上面的名字随便写

然后我们在在git窗口中输入，ssh -T git@gitee.com，然后输入yes（第一次访问要输入yes），然后就能看到对应的欢迎文本了，此时就说明我们的ssh已经配置成功了，我们已经可以连接到码云中了

- 远程仓库添加

接着我们就来正式添加我们的远程仓库，要添加远程仓库，首先我们要进入我们码云中的设置，复制其中的SSH，然后我们调用命令 git remote add <远端名称> <仓库路径>

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEce6b24f2f94474399961c955b2d76ab1.png)

然后我可以通过git remote命令来查看我们当前所连接的远程仓库

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1a66875784e5b6c1968289626a7f560d.png)

这里值得一提的是，我们的一个本地仓库是可以连接多个远程仓库的，不过一般我们都连接一个，不贪多。

然后我们来细说一下我们的推送本地仓库到远程仓库的方法，其完整方法是git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0ba04873064919c567e2481bc482f184.png)

但如果远程分支名和本地分支名相同，我们可以只写本地分支。这里我们就要搞清楚，本地仓库有多个分支，远程仓库也是能有多个分支的，一般来说我们第一个指定的名称是远程仓库的名称，然后我们要指定我们这里要推送的本地仓库的分支，接着是要更新的远程仓库的分支

而-f表示的是强制覆盖，不过这个用不太上，因为一般情况下我们都是只允许添加代码而不允许覆盖代码，要不然公司来个小白把代码覆盖了那就全完了

然后是我们的--set-upstream选项，其代表的是推送到远端的同时建立起推送的本地仓库的分支和远端仓库的关联关系，使用了这个代码，我们就可以在推送本地仓库的同时建立起相关的联系，这样我们进入到对应的分支，如果该分支已经建立了联系，那我们直接输入git push就可以直接将该分支推送到我们的远程仓库中去了

另外使用git branch -vv命令可以查看到本地仓库和远程仓库的联系

- clone

实际开发的时候，往往是多个人的本地仓库要连接到一个远程仓库的，而且其要进行开发，其就需要对远程仓库做一个内容上的复制，将远程仓库的东西下载到自己的仓库上来，此时就需要用到仓库克隆的指令

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfe01d922b24712275df1da80e2271a35.png)

其命令是git clone <仓库路径> [本地目录]，仓库路径就是在码云中仓库旁边点击克隆后看到的ssh，里面的内容就是我们的远程仓库的路径，本地目录如果不指定其会在当前目录下自动生成，且名字与远程仓库的仓库名保持一致

- 抓取和拉取

在我们实际的协同开发里，是有多个人操纵一个远程仓库的，那不可能远程仓库更新一次我们本地仓库就克隆一次吧？这不折磨人么，所以一般来说，我们都是使用一次克隆，后续我们的仓库更新了，我们就在本地仓库中做对应的更新就可以了。

接着我们就来讲更新本地仓库的两种方法，抓取和拉取。前者只是将更新的内容下载到本地，而没有对本地的对应内容进行一个覆盖更新，如果我们要进行覆盖更新的话，还需要自己手动进行合并操作，后者则是将下载和更新操作合二为一

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE01a7949a956f63a2257efeac5f9e65bb.png)

介绍这两种方法之前我们先要认识到一件事情，那就是当我们的将本地的修改推送到我们的远程仓库中时，此时我们可以认为本地仓库和远程仓库为两个分支，此时我们就只对我们的本地仓库做了更新，远程仓库则没有。而我们所谓的推送其实就是合并，那么当我们将我们的本地仓库与远程仓库合并时，同样也会启用快进模式，反过来当我们将远程仓库和本地仓库合并时，也会开启快速合并（这个是我边看边猜测的，不保证对）

我们这里抓取的命令是将仓库中的更新都抓取到本地，不会进行合并，当然，我们这里需要指定我们的远端名称和分支名，用/隔开，如果不指定就抓取所有分支，不过一般来说我们抓取之后可能会需要合并，那我们还有手动进行一个merge命令，这样就太麻烦了，因此我们又拉取命令，这个命令就等同于我们的抓取+合并，同样的如果不指定远端名称和分支名则默认抓取所有并更新当前分支

- 远程解决冲突

有这么一种业务情况，A和B用户都修改了同一个文件的同一行代码，此时如果我们进行合并就会发生合并冲突。举个简单的例子，我修改了A文件中的代码，此时我要将其更新都云端，然后我发现云端仓库更新了，那么我们就应该先更新云端仓库，后提交，但是我们执行对应的pull指定的时候，其报了合并异常错误，那么此时我们就还是跟之前学习的一样，进入对应的发生冲突的文件，然后将该文件的发生冲突的内容修改为我们最后要保留的内容，保存之后进行添加和提交我们就合并成功了，之后我们再往云端中推入我们的本地仓库就完了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfcdb76fec8c42204854be569814ff098.png)

最后我们提一嘴，我们即使执行了fetch操作，也可以执行pull操作，这个不影响，无非是其发现远程仓库里没什么需要更新的，会直接执行合并操作就完了

最后我们来做一下对应的练习

> ##########################1-将本地仓库推送到远程仓库 

> # 完成4.1、4.2、4.3、4.4的操作 

> 略

> # [git_test01]添加远程仓库 

> git remote add origin git@gitee.com/**/**.git 

> # [git_test01]将master分支推送到远程仓库,并与远程仓库的master分支绑定关联关系 

> git push --set-upstream origin master 

> ###########################2-将远程仓库克隆到本地 

> # 将远程仓库克隆到本地git_test02目录下 

> git clone git@gitee.com/**/**.git git_test02 

> # [git_test02]以精简的方式显示提交记录 

> git-log 

> ###########################3-将本地修改推送到远程仓库 

> # [git_test01]创建文件file03.txt 

> 略

> # [git_test01]将修改加入暂存区并提交到仓库,提交记录内容为：add file03 

> git add . 

> git commit -m 'add file03' 

> # [git_test01]将master分支的修改推送到远程仓库 

> git push origin master 

> ###########################4-将远程仓库的修改更新到本地 

> # [git_test02]将远程仓库修改再拉取到本地 

> git pull 

> # 以精简的方式显示提交记录 

> git-log 

> # 查看文件变化(目录下也出现了file03.txt) 

> 略 