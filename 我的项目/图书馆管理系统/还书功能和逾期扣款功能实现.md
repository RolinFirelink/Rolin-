一旦用户还了书，那么我们就应该将对应的书和用户的状态进行修改，同时我们应该删除我们借阅管理中的数据

删除分两种，一种是逻辑删除，一种是物理删除。所谓逻辑删除即使我们可以添加一个标志令借阅的数据不再被展示，而实际上其仍然在硬盘中存在，但是用户看起来的感觉就像是删除了。而物理删除是真正删除硬盘中的文件，是真正意义上的删除

逻辑删除平时是有作用的，并不只是为了省事，有时候这些数据保存下来还是有用的，比如说我们要查找谁谁谁曾经借过书，此时我们就需要这些数据，而如果使用物理删除的话则无法达到这个功能

我们这里来实现物理删除，同样利用代码分层的思想，我们先构造Dao层的删除代码

```javascript
/**
 * 删除
 * @param id
 */
@Override
public void delete(String id) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.LEND_PATH));
        List<Lend> list = (List<Lend>) ois.readObject();
        if(list!=null){
            Lend originLend = list.stream().filter(r -> Objects.equals(id,r.getId())).findFirst().get();
            list.remove(originLend);
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.LEND_PATH));
            oos.writeObject(list);
            oos.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

接着实现service层的代码，在service层里，我们应该要进行图书以及用户状态修改功能的实现

```javascript
/**
 * 还书
 * @param lend
 * @return
 */
@Override
public List<Lend> returnBook(Lend lend) {
    //获取用户对象和图书对象
    Book book = lend.getBook();
    User user = lend.getUser();
    //修改状态
    book.setStatus(Constant.STATUS_STORAGE);
    user.setIslend(false);

    userDao.update(user);
    bookDao.update(book);

    //删除lend数据
    lendDao.delete(lend.getId());

    return lendDao.select(null);
}
```

可以看到上面的代码里，我们首先获取了用户对象和图书对象，然后修改了状态并更新了硬盘中的文件的状态，最后我们进行硬盘中借阅数据的物理删除，然后返回了当前界面的数据，之所以要返回，是因为我们删除之后借阅数据还需要一个新的展示状态，展示当前被删除掉之后借阅管理里面剩余的数据

最后我们实现controller层

```javascript
/*
    还书
 */
@FXML
private void returnBook(){
    Lend lend = this.lendTableView.getSelectionModel().getSelectedItem();
    if (lend == null){
        Alerts.warning("未选择","请先选择要归还的书籍");
        return;
    }
    List<Lend> lendList = lendService.returnBook(lend);
    lends = new ObservableListWrapper<Lend>(new ArrayList<>(lendList));
    lendTableView.setItems(lends);
}
```

controller层里的代码涉及界面代码，这里就不多提了，大概作用就是把新返回的集合传给界面令其展示而已



逾期扣款

接着我们来实现逾期扣款功能，我们实现逾期扣款功能，逾期扣款功能，其实最好还是使用定时器来进行，因为我们每天都要执行这个任务，看看要不要扣款，然后程序关闭也要能够运行，但是这里我们不搞这么高级的，来点简单的

我们直接将逾期扣款方法写到这个界面的方法里，这样我们每次初始化界面的时候都会执行一次逾期扣款方法，我们扣款的规则是逾期一天扣款一元，逾期两天扣两元，最多扣到30元/天

同样运用代码分层的思想，先实现Dao的修改方法

```javascript
/**
 * 修改
 * @param lend
 */
@Override
public void update(Lend lend) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.LEND_PATH));
        List<Lend> list = (List<Lend>) ois.readObject();
        if(list!=null){
            Lend originLend = list.stream().filter(u -> u.getId().equals(lend.getId())).findFirst().get();
            BeanUtil.populate(originLend,lend);
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.LEND_PATH));
            oos.writeObject(list);
            oos.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

在service层上做一个关联，然后我们实现controller层的方法

```javascript
@Override
public void initialize(URL location, ResourceBundle resources) {
    //最开始必然是要展示所有界面，因此直接传入null
    List<Lend> Lendlist = lendService.select(null);
    //计算书籍逾期后的余额，利用循环遍历每一个借阅对象
    Lendlist.forEach(d -> {
        LocalDate returnDate = d.getReturnDate();//获取归还日期
        LocalDate now = LocalDate.now();//获取当前日期
        //计算归还日期与当前日期的日期差
        Period period = Period.between(returnDate,now);

        User user = d.getUser();//获取借阅数据中的对象
        BigDecimal money = user.getMoney();//获取借阅对象中的当前金额
        BigDecimal delay = BigDecimal.ZERO;//定义扣款金额
        if(period.getDays()>=1){

            //计算滞纳金
            if(period.getDays() >= 30){
                delay = new BigDecimal("30");
            }else {
                delay = new BigDecimal(period.getDays());
            }
            //扣款
            user.setMoney(money.subtract(delay));
            //将归还日期设置为今日
            d.setLendDate(now);

            //判断是否需要冻结用户
            if(BigDecimal.ZERO.compareTo(user.getMoney()) > 0){
                user.setStatus(Constant.USER_FROZEN);
            }

            //更新对应的属性
            d.setUser(user);//更新lend中user对象的属性
            lendService.update(d);//更新lend对象
            userService.update(user);//更新集合中User对象的属性
        }
    });
```

这行代码就不做测试了，这里值得一提的是我猜测归还日期和逾期日期并不是同一个属性，否则代码里的if判断应该是总是为1的，但这里我又懒得测试了，所以就先这样吧

