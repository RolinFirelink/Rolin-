- 索引的介绍

首先介绍下什么是索引，索引本身是存储于数组或者是集合中的用于快速寻找某个数据的数据，在MySQL中，其实帮助MySQL高效获取数据的一种数据结构。

在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构之上实现某些高级查看的算法，这种数据结构就是索引

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE85345999c6869b6b892dc9d0355aa9f4.png)

我们在上图中可以看到当没有索引时，我们找到5的话，就需要持续对比五次，而有了索引的话，用类似于二叉树的结构，我们只需要对比三次，效率上就有所提升，当然实际上MySQL里不一定是通过上图的方式来保存索引的，这里只是用于理解

索引按照功能分类可以分为普通索引、唯一索引、主键索引、联合索引、外键索引和全文索引。按照结构分类可分为BTree索引（其底层基于B+Tree数据结构）和Hash索引。各种不同的所有的特点都在图上注明了，自己去看吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3f670b803dd429708984053abded7113.png)

在学习之前，我们要先进行一些数据上的准备，请看代码

```
-- 创建db9数据库
        CREATE DATABASE db9;

        -- 使用db9数据库
        USE db9;

        -- 创建student表
        CREATE TABLE student(
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(10),
        age INT,
        score INT
        );
        -- 添加数据
        INSERT INTO student VALUES (NULL,'张三',23,98),(NULL,'李四',24,95),
        (NULL,'王五',25,96),(NULL,'赵六',26,94),(NULL,'周七',27,99);
```

- 创建和查询索引

创建和查询索引的具体语法如下所示，其中UNIQUE代表唯一，写入其代表创建唯一索引，写入FULLTEXT代表创建全文索引，什么都不写代表创建普通索引

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd75c7b60d2bc3a9b71001739c357ccd7.png)

最后我们还有两点需要注意，一是主键列自带主键索引，二是外键列自带外键索引，什么是外键索引？其实就是指两个表被外键约束连接起来的那两个列，一个列是主键列，一个列是外键列，外键约束在谁哪里创建，谁的指定的列就是外键列，被指向的列就是主键列，简单记忆可以理解为主键列后面写，外键列前面写。请看代码

```
/*
   创建索引
   CREATE [UNIQUE|FULLTEXT] INDEX 索引名称
   [USING 索引类型]  -- 默认是BTREE
   ON 表名(列名...);
*/
-- 为student表中的name列创建一个普通索引
        CREATE INDEX idx_name ON student(NAME);

        -- 为student表中的age列创建一个唯一索引
        CREATE UNIQUE INDEX idx_age ON student(age);


/*
   查询索引
   SHOW INDEX FROM 表名;
*/
        -- 查询student表中的索引  (主键列自带主键索引)
        SHOW INDEX FROM student;

        -- 查询db4数据库中的product表 (外键列自带外键索引)
        SHOW INDEX FROM product;
```

最后我们查看对应的列，可以看到如下的结果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcbe6cf3887ba5315b01d06569d1e4ba5.png)

其中Table代表表名，Non_unique代表是否唯一，0代表必须唯一，1则反之。Key_name代表的是索引名称。Comlumn_name代表我们给表的哪一列添加的索引。Index_type代表索引类型。Null代表索引是否可以为空，YES代表可以，不写代表不可以。

- 添加和删除索引

除了用CREATE关键字来创建索引之外，我们还可以用修改表结构的方式来添加索引，其语法如下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE886e61f75d7e052403496efa4137455b.png)

上图已经按照分类写出了创建不同索引时所用的不同的语法，最后我们来看看演示代码

```
/*
   ALTER添加索引
   -- 普通索引
   ALTER TABLE 表名 ADD INDEX 索引名称(列名);

   -- 组合索引
   ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);

   -- 主键索引
   ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); 

   -- 外键索引(添加外键约束，就是外键索引)
   ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);

   -- 唯一索引
   ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);

   -- 全文索引
   ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);
*/
-- 为student表中score列添加唯一索引
        ALTER TABLE student ADD UNIQUE idx_score(score);


        -- 查询student表的索引
        SHOW INDEX FROM student;



/*
   删除索引
   DROP INDEX 索引名称 ON 表名;
*/
        -- 删除idx_score索引
        DROP INDEX idx_score ON student;
```

- 索引的原理之磁盘存储的特点

索引主要是在存储引擎中实现的，不同的存储引擎支持的索引也不同，我们这里主要介绍InnoDB的Btree索引。BTree索引是基于B+Tree数据结构的，而B+Tree数据结构是BTree数据结构的变种。通常使用在数据库和操作系统中的文件系统，能够保持数据的稳定有序

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE90565bc39f17d47294fc50c86a4f96bc.png)

我们需要理解的是磁盘存储和BTree以及B+Tree的数据结构，为此我们需要先理解磁盘存储，

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5aca3cc9f9434f9d9877d76bcd7c8fe5.png)

系统从磁盘读取数据到内存中时是以磁盘块（block）为基本单位的。位于同一块磁盘的数据会被一次性读取出来，不是需要什么取什么。在InnoDB存储引擎中，页（Page）是其磁盘管理的最小单位，每个页的大小为16KB。该引擎将若干个磁盘块地址连接成一个页，查询数据时，如果一个页中的每条数据都能定位数据记录的位置，这将减少磁盘I/O次数，提高查询效率。

- 索引原理之BTree数据结构

我们先来讲解BTree的数据结构，一个BTree结点由id，指针，数据三个共同组成，我们看下图可以看到该树的分步方式，当数据在17与35之间时，由c3指向一下层，当比17小时由c2指向下一层，大于则由c4指向下一层，我们是利用id来比较大小的，确定到对应的id之后就可以拿到该id下对应的数据，通过这与方式来提高我们的查询效率。

然而BTree有个问题， 就是只要其查询了任一结点，其就会将该结点的所有所有数据给读取到，比如我们要查询15的数据，其首先查找磁盘块1，然后进入磁盘块2，最后定位到磁盘块7，这三个动作里，其会将三个磁盘块的内容都读取进去，准确来说，当其用第一个磁盘块的id来比较时，就已经将整个磁盘块的内容给读取了。然而实际上，我们只需要磁盘块7的数据，BTree的这种特性就会导致其效率的降低，因此B+Tree的数据结构应运而生

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf0a03f59861fe1733b69824a4f2c5940.png)

- 索引的原理之B+Tree数据结构

B+Tree数据结构同样也是有id指针数据三部分组成，但是其只在叶子结点上保存数据和id，非叶子结点上只保存id和指针，这样我们的数据每次查询时就不用进行io操作了，只会在叶子结点上进行io操作，因为只有叶子结点上有数据。同时B+Tree还有一个特点，那就是其将叶子结点上的结点都连接在了一起，这样当用户需要一块数据时不需要多次查找，可以直接通过id范围返回一部分或者是自己所需要的指定数据，能有效提高效率

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE78ecabe70c3b108a24f9f166c7bad204.png)

最后我们可以对BTree和B+Tree数据结构做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7502ee83ef726a00857a2450d3d2081b.png)

- 索引的设计原则

索引的设计也是需要遵守一定的原则的，不可以随便创建。首先我们应该要对查询频次较高，且数据量比较大的表建立索引，因为不怎么查询或者数据量很小的表没有创建索引的比较。其次是我们建议使用唯一索引，因为索引的区分度越高，其使用效率就越高，而且唯一索引的区分度显然是最高的。最后是索引字段的选择，其最佳候选列应该从where的子句的条件中去提取，因为索引本来就是用于快速查询的，从where子句中去提取，能够确保我们的索引总是建立在需要被查询的列上。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0d362ad5d5ae3ab2000f0933fb480fe8.png)

当然，索引虽然很好，但并不是越多越好，因为维护索引也是需要占用我们的效率的，所以索引的创建要适当，而不是越多越好。

最后我们要学习最左匹配原则，其只适用于组合索引。加入我们给user表中的三个属性添加组合索引，那么实际上其实是建立了三个索引的不同组合的索引，而我们使用哪个组合的查询语句都可以命中语句，而且我们的索引出现的字段是可以是任意的，也就是说，即使我们创建索引时是name属性最先创建，我们仍然可以将其他属性放在前面，因为MySQL优化器会帮我们自动调整其条件顺序。然后最后的一点是，如果我们的创建的不同组合索引中最左边的列不在我们的查询条件中，那么就不会命中索引。比如在下图中明明我们的name在最左边，而最后的查询语句根本就没有name，那肯定是查不到的，因为其组合索引中最左边的列不再查询条件中。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE248665b2961fc27fc6e74e8d91249903.png)

