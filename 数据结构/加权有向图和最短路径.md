学习完加权无向图之后，接着我们来学习加权有向图，与加权无向图一样的，我们同样也要先构造表示加权有向图的加权边的代码

我们先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8f76c54b6bf7ff6187e10be6e80e5d17.png)

根据其API设计我们可以构造代码如下

```javascript
package algorithm.sort;

public class DirectedEdge {
    private final int v;//起点
    private final int w;//终点
    private final double weight;//当前边的权重

    //通过顶点v和w，以及权重weight值构造一个边对象
    public DirectedEdge(int v,int w,double weight){
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取有向边的起点
    public int from(){
        return v;
    }

    //获取有向边的终点
    public int to(){
        return w;
    }
}
```

细看发现这代码居然还比加权无向边的还简单了不少，可还行。注意加权无向边需要比较，所以代码多，有向边没有提供比较规则就是

那么现在，我们就来实现加权有向图的数据结构，先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4259dcaa712a1595d244f78cc6d5fc4b.png)

这里加权有向图的加权边就不能跟无向图一样令加权值出现在两个结点的邻接表中了，而是只能出现一个，这里我们规定所有权值都要放在起点的结点中

那么我们可以构造其代码如下

```javascript
package algorithm.sort;

public class EdgeWeightedDigraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<DirectedEdge>[] adj;

    //创建一个含有V个顶点的空加权有向图
    public EdgeWeightedDigraph(int V){
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<DirectedEdge>();
        }
    }

    //获取图中顶点的数量
    public int V() {
        return V;
    }

    //获取图中边的数量
    public int E() {
        return E;
    }

    //向加权有向图中添加一条边e
    public void addEdge(DirectedEdge e) {
        //边e是有方向的，因此不能两个结点都添加权值
        //我们将权值只添加到起点，表示边的权值同时表示方向
        int v = e.from();//获取起点
        adj[v].enqueue(e);//在对应结点的邻接表上添加权值
        E++;
    }

    //获取由顶点v指出的所有边
    public Queue<DirectedEdge> adj(int v) {
        return adj[v];
    }

    //获取加权有向图的所有边
    public Queue<DirectedEdge> edges() {
        //遍历图中的每一个顶点，再遍历其中的邻接表，将其添加到队列中，最后队列中会含有图的所有边
        Queue<DirectedEdge> allEdges = new Queue<>();
        for (int v = 0; v < V; v++) {
            for (Object edge: adj[v]) {
                allEdges.enqueue((DirectedEdge) edge);
            }
        }
        return allEdges;
    }
}
```



最短路径

刚才我们学习了加权有向图，那么现在基于加权有向图，我们来学习最短路径，最短路径也就是在一副加权有向图中找出从一个顶点到另外顶点的权重最小的路径，这里就回到我们最开始的路径最小的问题了，这里的加权不但可以表示路径，还可以表示时间，我想未来时候实际运动我们的路径上的权值不止一个，会有时间，距离等多个加权值，我们可以通过这些加权值利用最短路径找出最合理的一条路来

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE648aa1aaa7697e74746bb5d0fcb5b880.png)

比方说在上图的加权有向图中，从0到6的路径里，红色标记的路径是我们目标的最短路径，这里指的是路径上边的权值之和是最小的

接着我们来学习最短路径的性质

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE70c6f8f9d2ba71867d95b7f827a4eaa8.png)

首先，路径具有方向性，也就是说，上图中红色的路径我们能是说0-6的路径，不能说成是6-0的路径，其次是权重不是单指举例，也可以指距离，时间，花费等内容，权重最小指他们某一个总和最低。

这里我们为了简化问题因此只考虑连通图，最后最短路径不一定是唯一的，从一个顶点到另外到另外一个顶点的权重最小的路径可能有多条，这里我们只要求找出其中一条就可以了

接着我们再来学习下最短路径树，先看定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf5808f0a21c23f2a126aabcc5ac14ad2.png)

比方说我们定义0为根结点，那么0之后对应的结点都是及其边所构成的树会存在路径，而其路径里都是其最小权重的路径

接着我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE24308257144cbfef8090f1c96e427a4e.png)

我们看到我们这里有一个松弛概念，那到底什么是松弛呢？我们先来解决这个问题，先来看看其概念吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEddb3a8d40abb4586356b7fb4a083ae60.png)

这里v,w是两个顶点，而s是根结点，其实简单来说所谓松弛就是比较两个路径的总权重，看谁更小，谁更小就将其值更新到我们保存最小边的对应成员变量中，来看看图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE72c52c12878193545685ed6f68b08327.png)

这里我们先假设存放最短路径树的edgeTo[]成员变量先存储了下面的黑色路径为最短路径，然后我们的distTo[]存放对应结点到根结点的路径的总权重，此时左图中我们要松弛vw，那么就要比较从根结点s到v再到w的总权重与当前存储的总权重的大小，可以看到最短路径的总权重为3.3，之后我们要松弛的边的总权重为4.4，那么我们要松弛的边比最小路径的总权重还要大，那么我们就忽略vw，不更新数据

而在右图中要松弛的边的总权重仍然为4.4，但是最短路径的总权重却变成了7.2，此时我们的最小路径大于要松弛的边，因此就要进行松弛，那么就要更新edgeTo[]的数据和distTo[]的数据，将edgeTo[w]的数据从原来的最短路径的边对象改成从v到w的边对象，然后我们从将从s根结点到w结点的最小权重改为更新后的最短路径的总权重，即4.4，也就是distTo[w]=4.4

上面我们学习的是边的松弛，学习完了边的松弛之后我们来学习顶点的松弛，那么什么是顶点的松弛呢？其实顶点的松弛就是将一个顶点的所有边进行松弛，当一个顶点的所有边都松弛完了，我们就说顶点松弛完毕了，用代码语言来说就是如果我们要松弛某个顶点，那么只要将其邻接表中的所有边都松弛完，我们就算是将整个顶点给松弛完了

最后我们来看看假设我们设置起点为0，那么来看看其松弛的图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdcfab8e6ae163621c95e96634ef6335f.png)

假设我们设置0位根结点，那么此时也是要用到切分定理的，我们将0设置为根结点的同时默认此时我们的最小路径树了只有0，其他结点都为其他集合，我们从加权边中最小的值开始定位加权边，比如说我们的0结点有两个加权边，分别是0-2和0-4，最后我们发现0-2小，那么就对0-2的边进行松弛，松弛之后将0-2也加入最短路径树中，然后我们的最小生成树就有两个加权边，分别是0-4和2-7，此时同样选择最小的边进行松弛，这样不断周而复始，最终能够构造出一个最短路径树出来

假设我们要找6的最短路径，那么就用pathTo存放某一结点的上一个结点指向其的结点的数组，从中找到6的上一个结点为3，接着是7,2,0，然后定位到0是根结点，因此不用再继续定位，那么最后我们的起点0到6的最短路径就找到了，其为0-2-7-3-6

最终我们实现的这个算法叫Dijkstra算法

那么综上我们可以构造代码如下

```javascript
package algorithm.sort;

public class DijkstraSP {
    //索引代表顶点，值表示从根结点s到当前结点的最短路径上的最后一条边
    private DirectedEdge[] edgeTo;
    //索引代表顶点，值表示从根结点s到当前结点的最短路径的总权重
    private double[] distTo;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权有向图G和根结点s，创造一个计算根结点s的最短路径树对象
    public DijkstraSP(EdgeWeightedDigraph G,int s){
        //初始化edgeTo
        this.edgeTo = new DirectedEdge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化pq
        this.pq = new IndexMinPriorityQueue<>(G.V());

        //全部初始化完毕之后要执行查找以根结点s为起点的最短路径树

        //默认以顶点s进入到最短路径树中
        distTo[s] = 0.0;//起点到起点没有边，因此赋值0.0，代表没有权值
        pq.insert(s,0.0);

        //遍历pq，给全部结点进行松弛
        while (!pq.isEmpty()){
            relax(G,pq.delMin());
        }
    }

    //松弛图G的顶点v
    private void relax(EdgeWeightedDigraph G,int v){

        for (Object edge:G.adj(v)) {
            //获取到该边的终点w
            int w = ((DirectedEdge)edge).to();
            //如果指定顶点的总权重与边权重之和小于当前记录的到该结点的最小权重
            if(distTo(v)+((DirectedEdge) edge).weight()<distTo(w)){
                //则更新对应顶点的最小权重和的数据以及到该顶点的最小权重边
                distTo[w] = distTo[v]+((DirectedEdge) edge).weight();
                edgeTo[w] = (DirectedEdge) edge;

                //判断pq中是否已经存在另一个结点w
                if(pq.contains(w)){
                    //若存在则更新其当前最小路径树的有效横切边的数据，其现实动作可以理解为
                    //改变了该横切边，使该横切边变成总权重更小的横切边
                    pq.changeItem(w,distTo(w));
                }else {
                    //若不存在则直接将点和该最小横切边插入
                    pq.insert(w,distTo(w));
                }
            }
        }
    }

    //获取从顶点s到顶点v的最短路径的总权重
    public double distTo(int v){
        return distTo[v];
    }

    //判断从顶点s到顶点v是否可达
    public boolean hasPathTo(int v){
        return distTo[v]<Double.POSITIVE_INFINITY;
    }

    //查询从起点s到顶点v的最短路径中所有的边
    public Queue<DirectedEdge> pathTo(int v){
        //判断从顶点s到顶点v是否可达，如果不可达，直接返回null
        if(!hasPathTo(v)){
            return null;
        }
        //创建队列对象
        Queue<DirectedEdge> allEdges = new Queue<>();

        while (true){
            DirectedEdge e = edgeTo[v];
            //当e为起点时，没有任何边指向它，其edgeTo里存放的值是null
            //因此当我们的e为null时，说明已经到了根结点
            if(e==null){
                break;
            }
            allEdges.enqueue(e);

            v = e.from();
        }
        return allEdges;
    }
}
```

值得一提的是，作为最后的一个数据结构的代码，这个代码的解释并不多，这是因为，大部分解释和前面都是雷同的，很容易理解，我们都学习到最后一章了，不用注释看懂这个代码也得是我们的基本功了，因此这里不写注释，以后也好用来当做给自己的一个测试，让自己能够不看注释就搞懂这里面的si