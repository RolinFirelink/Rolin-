完善了登录功能之后，接着我们来开发我们的员工管理功能，也是我们的第一个大模块的功能。首先我们先来进行登录功能的需求分析

我们首先知道我们添加员工的方式就是直接添加一个员工，点击添加会往后端发送一个请求，该请求的地址是直接以employee结尾的POST请求，请求的内容里含有用户提交的数据，那么我们可以整理出我们的步骤如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3ed4d6566db3c0f22989a22bdd9564e0.png)

那么我们可以写入我们的新增员工的方法在控制层中如下，由于我们在类名中已经加入了统一的employee前缀，因此我们的自定义方法不需要在定义额外的映射了。我们方法里则设置了初始的密码，合并给员工设置了创建和更新的时间以及创建和更新人等数据，最后调用MybatisPlus生成的方法即可完成保存工作了

```
/**
 * 新增员工
 * @param request
 * @param employee
 * @return
 */
@PostMapping
public R<String> save(HttpServletRequest request,@RequestBody Employee employee) {
    log.info("新增员工，员工信息:{}",employee.toString());

    //设置初始密码为123456，要进行md5加密处理
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));

    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());

    //获得当前登录用户的id
    Long empId = (Long) request.getSession().getAttribute("employee");

    employee.setCreateUser(empId);
    employee.setUpdateUser(empId);

    employeeService.save(employee);

    return R.success("新增员工成功");
}
```

但是我们这个代码还存在问题，那就是在我们的数据库里，我们的用户名是唯一的，如果我们保存的时候保存了一样的名字，那么就会从数据库中抛出异常，我们要解决这个问题，有两种方法，一种是通过trycatch来捕获处理异常，但这个方法太low了，我们要用统一异常处理类来解决这个问题

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb6dabaeff0ba4cc42bd78ecf79d3fdca.png)

那么我们定义全局处理类，写入对应的注解，然后定义一个专门用于处理该类异常的方法，这里的if进行的判断是确定数据库抛出的异常是不是用户名重复异常，课程里用的方法是看异常信息是否包含某个单词来判断，但是我们这里的异常信息就只是一个意义不明的符号，所以我们这里就用符号代替了

最后我们要提的是，ResponseBody这个注解的作用是为了让我们返回的数据自动转换成JSON的格式

```
package com.itheima.reggie.common;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理
 */
@ControllerAdvice(annotations = {RestController.class, Controller.class})
@ResponseBody
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex){
        log.error(ex.getMessage());
        
        if(ex.getMessage().contains("#23000")){
            return R.error("用户名已存在");
        }

        return R.error("未知错误");
    }
}

```

最后我们来做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdf85c312b6e1961ef60ab2bbfda285f1.png)

- 员工信息分页查询

接着我们来学习如进行员工信息的分页查询，我们首先已经知道员工的信息会在我们进入首页的时候就自动向服务器发送请求获得数据并展示，我们可以看到其地址是employee连接page，后面还有一些拼接的传送数据，分别代表当前页和最大页数，在我们的页面展示中，还有姓名查询的选项，使用该查询会再拼接一个name的数据在请求中，了解了这些事请之后，那么我们可以总结出我们的写代码的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8efb870fd7d61dc006804e52e1e9e088.png)

要实现分页，首先我们要配置一个MP的分页插件，那么我们可以写入其代码如下

```
package com.itheima.reggie.config;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 配置MP的分页插件
 */
@Configuration
public class MybatisPlusConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```

接着我们分析前端的代码可以知道，我们响应的数据里是要包括数据数量和数据内容本身的，也就是说，我们的R的data内容里就应该包括这些内容，我们当然可以自己创建一个这样的内容，但是在MP中，已经提供了这样一个Page对象供我们使用了，我们可以直接用

那么我们可以写入我们的代码如下，由于查询的是姓名，所以我们这里使用模糊查询

```
/**
 * 员工信息分页查询
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public R<Page> page(int page,int pageSize,String name) {
    log.info("page = {},pageSize = {},name = {}",page,pageSize,name);

    //构造分页构造器
    Page pageInfo = new Page(page,pageSize);

    //构造条件构造器
    LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();

    //添加过滤条件
    queryWrapper.like(!StringUtils.isEmpty(name),Employee::getName,name);

    //添加排序条件
    queryWrapper.orderByDesc(Employee::getUpdateTime);

    //执行查询
    employeeService.page(pageInfo,queryWrapper);

    return R.success(pageInfo);
}
```

- 禁启用员工账号

首先我们先来看看页面中是如何做到只有管理员admin才能够看到启用禁用的按钮的，其实逻辑非常简单，就是直接判断当前的用户名是不是admin，是的话就展示按钮，否则就不展示

然后我们来正式开发我们的代码，我们首先来看看前端发送的请求，其发送的是一个PUT请求，映射为employee，其下有状态数据以及要修改列的id，我们可以根据该id来修改对应的数据的状态值

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8583e10e085028d8bf5da1cb89804bb0.png)

那么我们可以写入修改代码如下，我们这里利用员工id进行修改，为了防止修改时出现错误，所以我们还一并修改了修改人以及修改时间，这种记录也符合我们的日常模式，我们最好就将修改的信息也一并记录下来

```
/**
 * 根据id修改员工信息
 * @param request
 * @param employee
 * @return
 */
@PutMapping
public R<String> update(HttpServletRequest request,@RequestBody Employee employee){
    log.info(employee.toString());

    Long empId = (Long) request.getSession().getAttribute("employee");
    employee.setUpdateTime(LocalDateTime.now());
    employee.setUpdateUser(empId);
    employeeService.updateById(employee);

    return R.success("员工信息修改成功");
}
```

但是实际上我们这份代码是无法生效的，这是因为我们数据库中的id是long类型的，其有19位，而在网页中最多保存16位，会出现精度丢失的问题，我们解决这个问题的方式是将我们的long类型的值改为String类型的值，这样就不会出现丢失精度的问题了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE75ead0196d9d39264952c1b70fdb07fa.png)

我们的转换步骤要依赖于我们的转换器，转换器类课件中提供给我们了，我们只需要将其配置好就可以了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEde4dcfdb7a4ce7b96973cba50a552bb7.png)

我们首先来看看我们的转换器类，其本质是利用了java里的反射机制

```
package com.itheima.reggie.common;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}

```

然后我们在配置类中创建这个类型转换器并手动将其追加到我们的MVC框架的转换器集合的第一位中，这样我们的转换器就能够被正确使用了

```
/**
 * 扩展mvc框架的消息转换器
 * @param converters
 */
@Override
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
    log.info("扩展消息转换器...");

    //创建消息转换器对象
    MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();

    //设置对象转换器，底层使用Jackson将Java对象转为json
    messageConverter.setObjectMapper(new JacksonObjectMapper());

    //将上面的消息转换器对象追加到MVC框架的转换器集合中，要添加到第一位，否则其不会优先使用我们定义的转换器
    converters.add(0,messageConverter);
}
```

- 编辑员工信息

接着我们来做编辑员工信息的开发，我们先来看看步骤，这个步骤就比较多，我们先要查询到到对应的数据并展示在我们的修改页面上，接着再进行修改的操作。注意我们这里的add.html是公共页面，新增员工和编辑员工都跳到这个页面，只不过他们触发的命令不同，实际上在他们的代码里也有做对应的不同处理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEed1e95b87562364d2df3900f365a9fa4.png)

这里值得一提的是，我们之前是做好了一个通用的更新的方法，我们编辑选择保存时会调用这个方法，那么我们就只需要做展示的部分就可以了，我们可以看到其是使用Get请求，并且会传用户id过来，那么我们后面的代码里就要将这个id接住然后查询到对应的用户信息并响应

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeb9d045391824b409c64b6e7b02407bf.png)

最终我们可以写入我们的查询的代码如下，由于我们这里要接收到id信息，因此我们这里使用PathVariable注解帮助我们接收

```
/**
 * 根据id查询员工信息
 * @param id
 * @return
 */
@GetMapping("/{id}")
public R<Employee> getById(@PathVariable Long id) {
    log.info("根据id查询员工信息...");
    Employee employee = employeeService.getById(id);
    if(employee==null){
        return R.error("没有查询到员工信息");
    }
    return R.success(employee);
}
```

- 公共字段自动填充

接着我们来学习公共字段自动填充，之前我们无论是添加用户还是更新用户，都需要花费进行一个重复的给对应的用户更新创建时间和创建人的代码，这样重复的代码当然不好，而且还臃肿，因此我们这里要使用MP提供给我们的公共字段自动填充的功能，可以让我们需要执行这些代码的时候这些代码会在统一的一个地方自动执行，而不需要我们在对应的位置手动写入这些重复的代码

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE002fca0c6296f833a4da064b350bf7d1.png)

这非常类似于我们的SB里的AOP，那么问题在于，我们为什么不使用AOP来实现这个功能呢？这其实是因为AOP的本质是利用了反射机制，而反射的效率都比较低，如果我们啥都用AOP去完成，那我们的项目就直接烂完了，效率会慢的不行，所以我要使用MP提供的方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE31960c096aedbc1a8606937d35e7d209.png)

我们首先要往实体类型提供加入对应的TableField注解并指定自动填充的策略，对应的不同字段就是采用不同的填充策略，有些是插入是填充，有些是插入和更新时都填充

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc0c41aa666692220bf5e934745256d5c.png)

按照上面的内容，我们可以将我们的员工实体类改变如下

```
package com.itheima.reggie.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import lombok.Data;
import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * 员工实体
 */
@Data
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;//身份证号码

    private Integer status;

    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private Long createUser;

    @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
    private Long updateUser;

}

```

其实就是往对应的属性下指定了填充的字段而已

然后我们要创建一个类，令这个类实现MetaObjectHandler接口，实现该接口要求你实现两个方法，这两个方法分别就是更新时要执行的方法和插入时要执行的方法，我们就往内部放入我们要令其执行的代码即可，其参数内会有一个MetaObject对象，我们只要往里写入对应的set后面的方法的字符串，然后再指定要设置的数据，其就会自动帮我们调用该方法完成设置了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcbf8c5d19bba2305b3ff11a3db8493c7.png)

我们要写入的公共代码必然是往对应的对象设置我们的对应创建更新时间以及创建和更新的id，时间好说，可以直接从本地上调出来，但是id怎么办？我们之前获得id的方法都是通过request中的共享域来获取登陆者的id的，但是在这个类中，我们却无法获取到request中的共享域对象，那么我们要怎么办呢？

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd6edcdc067e3596d56e2fb371d430fdb.png)

我们可以使用ThreadLocal来解决这个问题，客户端每次发送的请求，在服务器端都会分配一个新的线程来处理，而在同一个线程里执行的各种的方法，他们都是在一个线程中的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd382058394fa9c55566fa797988972e9.png)

而ThrealLocal是Thread的一个局部变量，简单来说，我们可以通过这个变量往对应的线程中存储信息，只要还在同一个线程中，就可以往这个线程中将信息取出来。我们就利用这种方法来获得我们的id

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE049572a1e01ea4b3e37587396b154e15.png)

来看看我们的实现步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE91b1796bb6b11b9c0cf93db7ceb6ee38.png)

首先我们要创建BaseContext类，令其拥有ThreadLocal对象并提供设置和获取该线程对象的方法，当然这个方法应该要是静态的，因为我们这个类是工具类，我们希望其他使用者可以直接使用该方法而不用进行实例化

```
package com.itheima.reggie.common;

/**
 * 基于ThreadLocal封装的工具类，用于保存和获取当前登录用户id
 */
public class BaseContext {

    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    /**
     * 设置值
     * @param id
     */
    public static void setCurrentId(Long id){
        threadLocal.set(id);
    }

    /**
     * 获取值
     * @return
     */
    public static Long getCurrentId(){
        return threadLocal.get();
    }
}

```

最后我们可以在我们的自动填充字段的类中写入代码如下，在这里我们的设置的id是通过线程共享的信息得到的，当然，能获取当然有写入，我们在之前插入时就写入了对应的代码将id信息写入了，这里我们就不展示这一部分的代码了

```
package com.itheima.reggie.common;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * 自定义元数据对象处理器
 */
@Component
@Slf4j
public class MyMetaObjecthandler implements MetaObjectHandler {

    /**
     * 插入操作，自动填充
     * @param metaObject
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段自动填充insert...");
        log.info(metaObject.toString());
        metaObject.setValue("createTime",LocalDateTime.now());
        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("createUser",BaseContext.getCurrentId());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }

    /**
     * 更新操作，自动填充
     * @param metaObject
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("公共字段自动填充update...");
        log.info(metaObject.toString());

        long id = Thread.currentThread().getId();
        log.info("线程id为:{}",id);

        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
}

```

