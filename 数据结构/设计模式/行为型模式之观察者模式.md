现在我们来学习观察者模式，先来看看其定义以及结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf956ba66674597c8d2f53666843ac9fd.png)

我们可以通过观察者模式实现广播的功能或者是监听某个对象的功能，与这种设计模式最相似现实例子就是公众号订阅更新功能，一旦订阅号更新，则会以广播的形式通知其下的所有用户对象更新的新文章，那么接下来我们就要来完成这么一个公众号更新的例子，先来看看其需求和类图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE777e7f67f2efe7ccb212823233b81f03.png)

首先我们创建抽象观察者类，其只定义一个更新接口

```
//抽象观察者类
public interface Observer {
    void update(String message);
}
```

接着我们定义抽象主题角色类，其下含有观察者对象，而且具有添加删除更新的方法，我们可以直接将其理解为是公众号对象，不过我们这里提供的是一个接口

```
//抽象主题角色类
public interface Subject {

    //添加订阅者（添加观察者对象）
    void attach(Observer observer);

    //删除订阅者
    void detach(Observer observer);

    //通知订阅者更新消息
    void notify(String message);
}
```

然后我们定义抽象具体的主题角色类，我们这里定义一个集合来存储多个观察者对象，这是当然的，因为一个公众号可以有多个微信用户，其下对应的增加用户，删除用户和更新的方法，更新使用foreach循环调用方法实现

```
public class SubscriptionSubject implements Subject{

    //定义一个集合，用来存储多个观察者对象
    private List<Observer> weiXinUserList = new ArrayList<>();

    @Override
    public void attach(Observer observer) {
        weiXinUserList.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        weiXinUserList.remove(observer);
    }

    @Override
    public void notify(String message) {
        //遍历集合
        for (Observer observer : weiXinUserList) {
            //调用观察者中的update方法
            observer.update(message);
        }
    }
}

```

最后我们定义具体观察者类，其就是实现一个更新的方法，当然，我们这里的观察者类其实一个微信用户类，因此我们这里提供保存用户名的属性并且提供构造方法

```
public class WeiXinUser implements Observer{

    private String name;

    public WeiXinUser(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name+"---"+message);
    }
}

```

最后我们写入我们的测试类的代码如下，可以得到我们想要的结果，三个用户都调用了更新方法

```
public class Client {
    public static void main(String[] args) {
        //1.创建公众号对象
        SubscriptionSubject subject = new SubscriptionSubject();

        //2.订阅公众号
        subject.attach(new WeiXinUser("孙悟空"));
        subject.attach(new WeiXinUser("猪八戒"));
        subject.attach(new WeiXinUser("沙悟净"));

        //3.公众号更新，发出消息给订阅者(观察者对象)
        subject.notify("黑马更新了");
    }
}
```

然后我们来看看观察者模式的优缺点和使用场景

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE841c97b0ab5e63eb103efb8cfe6647fe.png)

- JDK中提供的实现

在Java中提供了两个接口（分别是抽象目标类和抽象观察者类）用于实现观察者模式，用户只需要实现这两个就可以实现观察者模式，即可以实现监听器或者是广播的效果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE21c7b30b0753199b1de2892917302e8f.png)

首先我们来介绍抽象目标类Observable

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe00722fb409087fc60760db79b834bc7.png)

其下有一个Vector的集合成员变量，我们直接把它当List集合对象来看待就行了其实，其第一个添加方法会判断集合中是否存在对应的对象，若存在再添加，具体请看源码

```
public synchronized void addObserver(Observer o) {
    if (o == null)
        throw new NullPointerException();
    if (!obs.contains(o)) {
        obs.addElement(o);
    }
}
```

第二个更新的方法本质还是使用for循环来遍历所有对象并调用其下的更新方法，之所以越晚加入就越快得到通知，是因为遍历时其是从后往前遍历的

```
public void notifyObservers(Object arg) {

    Object[] arrLocal;

    synchronized (this) {
        if (!changed)
            return;
        arrLocal = obs.toArray();
        clearChanged();
    }

    for (int i = arrLocal.length-1; i>=0; i--)
        ((Observer)arrLocal[i]).update(this, arg);
}
```

第三个方法简单来说就是一个布尔类型的变量，该变量的主要作用就是用于判断我们的最初的对象是否进行了更新，若更新则将其赋值为true，然后调用我们的第二个方法，自然会通知，同时通知完之后再调用clearChanged()方法将对应的布尔类型的值设置为false，即是未更新

```
protected synchronized void setChanged() {
    changed = true;
}
```

然后是抽象观察者类的接口，这个没什么值得说的，直接用就行

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1f78a358f3cdd9743920d15c34b4b889.png)

然后我们可以做一个警察抓小偷的简单例子来加深理解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1cc741f423cffb134d67639fbb59e23a.png)

首先我们创建小偷对象，其需要继承Obsevable类，其下我们提供名字属性，一旦偷东西我们就调用其父类的标记更新方法和状态更新方法

```
public class Thief extends Observable {

    private String name;

    public Thief(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void steal() {
        System.out.println("小偷：我偷东西了，有没有人来抓我！！！");
        super.setChanged(); //changed  = true
        super.notifyObservers();
    }
}
```

然后我们创建观察者类，令其实现Observer接口，其下提供警察的名字属性，同时我们重写父类接口的更新方法

```
public class Policemen implements Observer {

    private String name;

    public Policemen(String name) {
        this.name = name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public void update(Observable o, Object arg) {
        System.out.println("警察：" + ((Thief) o).getName() + "，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！");
    }
}
```

最后我们可以写入我们的测试类的代码如下，我们这里第8行的代码相当于是让警察盯住小偷，也相当于是用户订阅了某个公众号（当然，这里小偷是公众号），一旦小偷的状态更新，我们就调用其下的更新方法，让警察抓小偷，这很好理解，就类似于公众号，功能几乎一样的，只不过我们这里提供了一个实现方式而已，我们可以通过这个接口直接实现它

```
public class Client {
    public static void main(String[] args) {
        //创建小偷对象
        Thief t = new Thief("隔壁老王");
        //创建警察对象
        Policemen p = new Policemen("小李");
        //让警察盯着小偷
        t.addObserver(p);
        //小偷偷东西
        t.steal();
    }
}
```

