本章节我们来实现借阅功能，实现借阅功能之前，我们要先实现分析下借阅功能，借阅功能是在图书管理里放置的添加窗口，用户想要借阅书籍，首先要选中要借阅的书籍，然后会弹出借阅窗口

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE97205d3206eccea23575ce1a46a4b92b.png)

窗口内选择查询，会弹出另外一个窗口

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7a9988545e6278d1140504de68b3212d.png)

这个窗口内要求选择要进行借阅的用户进行借阅，然后就会在借阅管理中生成一条借阅数据

那么我们现在的窗口内可以选择的用户必然满足两个条件，用户的状态正常以及没有借其他书，我们这里规定一人只能借一本书，那么接下来我们要实现的就是在这个用户选择界面里展示符合条件的用户



查询可以借书的用户

同样的，我们先来分析代码本身，首先来看看点击借阅之后弹出的第一个界面的界面代码，进入BookLendView.fxml就可以看到对应的界面代码

```javascript
<children>
    <Label GridPane.columnIndex="0" GridPane.rowIndex="8" prefHeight="30.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" />
    <TextField fx:id="bookIdField" GridPane.columnIndex="1" GridPane.rowIndex="9"  visible="false" layoutX="739.0" layoutY="18.0" prefHeight="30.0" prefWidth="151.0" styleClass="rectangle" />
    <Label GridPane.columnIndex="0" GridPane.rowIndex="0" prefHeight="40.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" text="书名:" />
    <TextField fx:id="bookNameField"  GridPane.columnIndex="1" GridPane.rowIndex="0" layoutX="739.0" layoutY="18.0" prefHeight="40.0" disable="true" prefWidth="151.0"  styleClass="rectangle" />
    <Label GridPane.columnIndex="0" GridPane.rowIndex="7" prefHeight="30.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" />
    <TextField fx:id="userIdField" GridPane.columnIndex="1" GridPane.rowIndex="7" visible="false"  prefHeight="30.0" prefWidth="151.0"  styleClass="rectangle" />
    <Label GridPane.columnIndex="0" GridPane.rowIndex="2" prefHeight="40.0" prefWidth="60.0" style="-fx-text-fill: -text-color;" text="借阅者:" />
    <TextField fx:id="userNameField" GridPane.columnIndex="1" GridPane.rowIndex="2" prefHeight="40.0" disable="true" prefWidth="151.0" styleClass="rectangle" />
    <Button layoutX="516.0" GridPane.columnIndex="2" GridPane.rowIndex="2" layoutY="10.0" mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0" onMouseClicked="#initSelectUserStage" styleClass="btn-success" text="查询" />
</children>
```

上面就是对应的第一个界面的代码，可以看到界面里实际有四个框，分别对应书名，书的编号，用户名，用户的编号，只不过书的编号和用户的编号都是隐藏的，用户看不到，用户借阅的时候只要比较书名和用户名就可以了，而至于书的编号和用户编号，其存在的意义主要是给后面用于寻找要借阅的书和用户的，我们实际去找对应的书籍和用户的时候，是通过其编号来找的，而不是书名和用户名，因为用后者可能存在姓名或者是用户名重复的情况，因此我们不使用书名来进行查找

我们上面的代码是第一个窗口的界面代码，在这个代码里点击查询，可以查找到第二个窗口的代码

```javascript
<Button layoutX="516.0" GridPane.columnIndex="2" GridPane.rowIndex="2" layoutY="10.0" mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0" onMouseClicked="#initSelectUserStage" styleClass="btn-success" text="查询" />
```

进入其对应的鼠标事件，可以看到下面的代码

```javascript
/*
    初始化借阅用户选择的stage
*/
@FXML
private void initSelectUserStage() throws IOException {
    FXMLLoader loader = new FXMLLoader();
    loader.setLocation(App.class.getResource("/com/bjpowernode/module/user/UserSelectView.fxml"));
    StackPane target = (StackPane) loader.load();
    Scene scene = new Scene(target);

    Stage stage = new Stage();//创建舞台；
    UserSelectViewCtrl controller = (UserSelectViewCtrl)loader.getController();
    controller.setStage(stage);
    controller.setBookLendViewCtrl(this);
    stage.setHeight(800);
    stage.setWidth(700);
    //设置窗口图标
    stage.getIcons().add(new Image("icon.png"));
    stage.initModality(Modality.APPLICATION_MODAL);
    stage.setScene(scene); //将场景载入舞台；
    stage.show(); //显示窗口；
}
```

可以看到这个代码的作用是新创建了一个窗口，第7行先载入了对应的窗口，我们可以看到这个窗口是在用户之下的，这也是当然的，因为本来这个窗口就是在用户模块下产生的，最后我们根据这个界面文件可以找到展示对应的controller层，其就在UserSelectViewCtrl类下

```javascript
@Override
public void initialize(URL location, ResourceBundle resources) {

    users.add(new User(1, "张三", "正常", new BigDecimal(("100"))));
    users.add(new User(2, "李四", "正常", new BigDecimal(("100"))));
    users.add(new User(3, "王五", "正常", new BigDecimal(("100"))));
    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    c2.setCellValueFactory(new PropertyValueFactory<>("name"));
    userTableView.setItems(users);

}
```

可以看到目前我们的代码还是直接产生的，而不是从硬盘文件中查询到的，那么接着我们就要实现查找符合条件的用户对象的方法

那么现在就有一个问题，那就是我们如何来判断用户是否已经借过书呢？一个简单想法就是取出拿要用户选中的User类与借阅管理中的User数据进行比较，若发现其的确有该方法，那么我们就判断该用户已经结果书了，但是这样有些麻烦，我们有一个简单想法就是给User类中多添加一个布尔类型的属性，用于判断其是否已经借过书，然后重新改造其对应的构造方法就可以了

理清楚思路之后，我们就来实现这个方法

由于是在用户管理模块下的，因此我们再UserDao接口中添加方法

```javascript
List<User> selectUserToLend();
```

实现方法

```javascript
/**
 * 查询可以借书的用户
 * @return
 */
@Override
public List<User> selectUserToLend() {
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        List<User> list = (List<User>) ois.readObject();
        if(list!=null){
            //查询出用户状态是正常且是没借书的，利用stream流查找，返回符合条件的对象至集合中
            List<User> collect = list.stream().filter(u -> Constant.USER_OK.equals(u.getStatus()) && false == u.isIslend()).collect(Collectors.toList());
            return collect;
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }
    return new ArrayList<>();
}
```

实现service层的接口方法

```javascript
List<User> selectUserToLend();
```

实现方法

```javascript
@Override
public List<User> selectUserToLend() {
    return userDao.selectUserToLend();
}
```

最后实现controller层

```javascript
private UserService userService = new UserServiceImpl();

@Override
public void initialize(URL location, ResourceBundle resources) {
    //查询出符合条件的用户数据
    List<User> list = userService.selectUserToLend();
    users.addAll(list);
```



借阅功能的实现

那么接着我们就来正式去实现借阅功能，借阅功能其实无非就是添加功能，我们点击借阅时，可以简单理解为往借阅管理中添加了一项数据，那么这个添加功能和我们之前的添加功能其实大差不差，同样利用分层思想，先来实现Dao层，添加方法

```javascript
void add(Lend lend);
```

实现方法

```javascript
/**
 * 借阅
 * @param lend
 */
@Override
public void add(Lend lend) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.LEND_PATH));
        List<Lend> list = (List<Lend>) ois.readObject();
        list.add(lend);//往集合中添加需要添加的对象
        oos = new ObjectOutputStream(new FileOutputStream(PathConstant.LEND_PATH));
        oos.writeObject(list);
        oos.flush();
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

接着我们要实现service层，在service层里我们应该构建出一个符合需求的Lend对象然后传给Dao层，Dao层就能执行对应的增加操作，这个时候可能有同学会说，那我们直接在Dao层里做这一部分的行为不行吗？不行！我们在Dao层里就只做纯粹的增删改查的工作，这就是代码分层的思想，各个不同的层次做各个不同的工作，明确分工

那么接着我们在Service层里增加方法

```javascript
void add(int bookId,int userId);
```

为什么我们这里你传入的是图书id和用户id而不是直接传入一个Lend对象？因为我们的界面窗口里传入的就是图书id和用户id，所以我们这里接收的就是这两个类型的数据，然后我们在方法里自己创建一个对象的Lend对象并传入就好了，这里方法的参数是跟窗口的传入的数据保持一致

这个其实也告诉我们，service的方法并不是简单的和Dao层保持一直的，对于比较复杂的业务，Service层里会有不同的方法

还有一点是，我们可以再service层里调用其他的service，也可以在service层里调用其他的Dao，但是我们不可以在Dao层里调用别的Dao

在我们实现Service层的方法之前，我们要知道我们查找图书和用户是通过id来查找的，但是我们的图书查找方法里并没有通过id查找的代码，因此我们首先要对图书查找的代码进行改造，先创造一个根据图书ID查找的代码，那么我们进入对应的BookDao，添加代码如下

```javascript
//根据编号查询
if(!(0== book.getId())){
    conditionList = list.stream().filter(b -> b.getId() == book.getId()).collect(Collectors.toList());
    return conditionList;
}
```

那么实现了我们的图书编号查询之后，我们还得实现用户编号查询，因为我们之前实现的用户查询里，是没有实现带条件的查询的，现在我们来实现下带条件的查询，也就是编号查询，由于我们原先的方法被许许多多的其他代码所调用，修改的话就太麻烦了，因此我们这里直接增加一个重载方法并实现，这里直接放实现类了

```javascript
/**
 * 条件查询
 * @param user
 * @return
 */
@Override
public List<User> select(User user) {
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH));
        List<User> list = (List<User>) ois.readObject();
        List<User> collect = list.stream().filter(u -> u.getId() == user.getId()).collect(Collectors.toList());
        return collect;
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

添加Service接口的方法并实现这个方法

```javascript
/**
 * 添加借阅数据
 * @param bookId
 * @param userId
 */
@Override
public void add(int bookId, int userId) {
    //查询图书数据
    Book paramBook = new Book();//创建新的图书对象
    paramBook.setId(bookId);//将图书id赋值到图书对象中
    //调用图书对象返回集合，集合内存储符合条件的图书对象，理论上只有一个
    List<Book> bookList = bookDao.select(paramBook);

    //根据编号查询用户对象，同理
    User paramUser = new User();
    paramUser.setId(userId);
    List<User> userList = userDao.select(paramUser);

    //创建Lend对象
    Lend lend = new Lend();
    //给lend赋予编号
    lend.setId(UUID.randomUUID().toString());

    //获取集合中符合条件的图书对象并添加到Lend中
    Book book = bookList.get(0);
    book.setStatus(Constant.STATUS_LEND);//将图书状态改成出借状态
    lend.setBook(book);

    //同理
    User user = userList.get(0);
    user.setIslend(true);//将用户设置为已借书状态
    lend.setUser(user);

    lend.setStatus(Constant.LEND_LEND);//设置出借信息的状态
    //设置出借日期和归还日期
    LocalDate begin = LocalDate.now();
    lend.setLendDate(begin);
    lend.setReturnDate(begin.plusDays(30));

    //修改存储于硬盘文件中的图书状态
    bookDao.update(book);
    //修改存储于硬盘文件中的用户状态
    userDao.update(user);
    //在借阅管理模块里添加出借的数据
    lendDao.add(lend);
}
```

那么service层的方法也实现完毕了，最后我们来实现Dao层的方法，首先我们要找到controller层，进入对应的界面代码，找到添加界面代码并进入鼠标事件

```javascript
@FXML
private void add() {
    Lend lend = new Lend();
    LocalDate now = LocalDate.now();
    lend.setId("5");
    lend.setLendDate(now);
    lend.setReturnDate(now.plusDays(30));
    lend.setStatus(Constant.LEND_LEND);

    stage.close();
}
```

接着我们就要修改代码了，但是在修改之前，我们要知道我们不只是调用Service的方法就可以了的，因为我们修改之后还要在当前界面上立刻更新我们设置之后的状态，因此这里还涉及到界面的刷新，但是这部分代码不重要，因此就不多提了，直接放代码

```javascript
@FXML
private void add() {
    lendService.add(Integer.parseInt(bookIdField.getText()),Integer.parseInt(userIdField.getText()));
    book.setStatus(Constant.STATUS_LEND);
    user.setIslend(true);
    //刷新图书查询界面的数据
    bookTableView.refresh();
    stage.close();
}
```

这样我们出借功能就实现完毕了，但是我们的程序还有一个小bug，那就是我们的对已经被借阅的图书还是能够再次借阅，我们应该要设置已经借阅的图书不允许借阅才对，因此我们要修改下我们的代码

先找到借书选择窗口的底层代码

```javascript
/*
    借书
 */
@FXML
private void lendBook() {
    try {
        Book book = this.bookTableView.getSelectionModel().getSelectedItem();
        if (book == null){
            Alerts.warning("未选择","请先选择要借阅的书籍");
            return;
        }

        initLendStage(book);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

若选择已经出借的图书则结束方法并弹出提示