学完了Comparable接口之后，我们来学习冒泡排序法

冒泡排序法的原理在JavaSe里就已经讲解过了，这里不多赘述

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE397f6cf30242ae8048291f4e6de39885.png)

简单原理就是拿右边的值与左边的一一比较，谁大就放右边，比完之后比倒数第二个，这样直到全部比完为止

接着我们来看看冒泡排序的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE90b7d35ce530d35ff78c7d21b5afd0e7.png)

在冒泡排序的的Bubble类里有三个静态方法，分别是对数组内的元素进行排序的sort方法，然后是用于判断v是否大于w的greater方法，最后是用于交换两处索引值的exch方法

现在让我们来去分别实现这三个办法，可以写出代码如下

```javascript
package algorithm.sort;

public class Bubble {
    public static void sort(Comparable[] a){
        for (int i = a.length-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if(greater(a[j],a[j+1])){
                    exch(a,j,j+1);
                }
            }
        }
    }

    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w)>0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```

然后我们再写一个测试类来测试该方法

```javascript
package algorithm.sort;

import java.util.Arrays;

public class test {
    public static void main(String[] args) {
        Integer[] arr = {4,5,6,3,2,1};
        Bubble.sort(arr);

        System.out.println(Arrays.toString(arr));
        //[1, 2, 3, 4, 5, 6]
    }
}


```

这里我们之所以传入了一个Integer类型，是因为我们写的Bubble类是规定了我们要Comparable数据类型的数组，而在Integer类里是实现了Comparable接口的，因此这里可以利用多态机制

接着我猜想之所以我们没有对CompareTo方法进行重写而又可以正确比较，是因为这里的CompareTo方法其实是调用了Integer里的CompareTo方法



冒泡排序的时间复杂度分析

这里我们要用最坏的情况来进行判断，对于这个算法而言，最坏的情况就是数组逆序的情况，逆序的数组要求每一次都进行比较

通过分析我们不难知道本算法的核心代码在于7，8行的比较与交换这两行代码，确认了方法内的函数没有循环之后，我么就可以只比较这两个方法执行的次数了

首先通过分析我们易知比较的次数为(n-1)+(n-2)+(n-3)....3+2+1=n^2/2-n/2次，而交换的次数也是这么多次，所以总执行次数为n^2-n次

用大O记法表示为O(n^2)，显然，这种算法是需要优化的



选择排序法

显然，我们需要另外一种更加好的方法来对数组进行排序，所以现在我们就来学习选择排序。它的原理同样在JavaSe里已经讲过了，所以这里就不再赘述，直接贴结论

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9cd3076705bf9c106691eb51b3fe3d0f.png)

看看用图进行的演示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE35d096ba3fe95a94b2f20d2e9beefde3.png)

简单来说就是先假定第一个索引处的值为最小值，然后拿着第一个索引和其他索引进行比较，如果对面更小，那么就将最小值的索引更改位置，接着到结束再把最小值放到第一个位置，然后从第二个位置开始重复执行上述过程

接着我们来看看选择排序法的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfe13fb025a1d3066991d20be86299794.png)

我们通过API的指引，可以实现选择排序的方法如下

```javascript
package algorithm.sort;

public class Selection {
    public static void sort(Comparable[] a){
        for (int i = 0; i <= a.length-2; i++) {
            int minIndex = i;
            for (int j = i+1; j < a.length; j++) {
                if(greater(a[minIndex],a[j])){
                    minIndex=j;
                }
            }
            exch(a,i,minIndex);
        }
    }

    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w)>0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```

同样的我们要对其进行时间复杂度的分析，这里外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据交换次数与数据比较次数

如图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE76a3c60cad31312ae488478018978ca8.png)

其时间复杂度用大O阶表示仍为O(N^2);仍然是需要改进的算法，因此我们接下来要学习新的排序算法，因为前两个都不适用



插入排序

接下来我们来学习插入排序，先来看插入排序的理论原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe7c5e9ddc1fe685cb766af18f314d74d.png)

简单来说就类似于扑克牌，我们拿到一张牌之后先将该牌从右边往左边比较，一旦我找到一张牌比我们要插入的牌还要小，那么我们就算是找到正确的插入位置了，将其插入就可以了。这里是默认了我们的牌已经是排序好了的，所以我们可以用使用这种插入排序，我们实际运用插入排序的时候，也是要将数据分成已排序和未排序两组并进行比较的

现在我们来看看其原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEeff46428878f9a0be0a95d9858ef882d.png)

现在让我们来分析其图示实现

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7e09393b20db3b4f13dcff1eb0f70357.png)

在这里我们将所有的元素分为两组，已排序的和未排序的，这里我们先将下标0的数值为4的数据默认为已排序的，然后将往右的剩余数据全部视为未排序的，接着我们拿未排序的下标为1数值为3的未排序数组里的第一个来进行比较，发现它的确比4小，于是我们将3与4交换位置，用于后续已经没有数据了，所以此时第一轮的交换就完成了

第二轮交换我们去下标为2数值为2的数据作为待插入数据，然后我们与4进行比较，比较完之后发现2比4小，于是2和4交换位置，接着我们拿下标为2数值为2的数据与3进行比较，然后再次交换位置，同理交换完成

接着到第三轮循环，第三轮循环我们拿下标为3，数值为10的数据与已排序的数据进行比较，我们发现10与4大，那显然对于已排序的数据而言，后面肯定比4还小了，于是我们不用比了，直接把10放在原位就完了

这样不断循环往复一下子就到了第六轮循环了，此时我们拿下标为6，数值为5的的数据与前面的数据进行比较，比12小，于是和12交换位置，在拿此时下标为5数据为5的数值与10进行比较，同理再次交换位置，然后拿下标为4数值为5的数据与4进行比较，发现5比4大，那就直接保持原位

到最后下标为7数值为6的数据排序完之后，数组里就只剩下排序完的数据了，此时就是排序完成了

学习完原理及图示实现之后，我们来看看插入排序的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6bd277b673b757443c5e9462755f7c69.png)

接着我们用算法来实现其方法

```javascript
package algorithm.sort;

public class Insertion {
    public static void sort(Comparable[] a){
        //i=1是未排序数组的初始下标，未排序数组最大能到达数组最后一个数组，因此是<a.length
        for (int i = 1; i < a.length; i++) {
            //定义j=i，代表要未排序数组的第一位，用于后续比较，且该指针总指向这个待插入数据
            for (int j = i; j > 0 ; j--) {
                //将待插入数据与已排序数据进行比较，若小于则交换
                if(greater(a[j-1],a[j])){
                    exch(a,j-1,j);
                    //若大于直接结束循环
                }else {
                    break;
                }
            }
        }
    }

    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w)>0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```

其实综上我们也不难看出对于插入排序而言就是拿未排序数组的第一位对未排序数组里的一个个数据进行冒泡排序，不同的是我们每一次冒泡排序的结束条件有两个，一个是要比较的值已经无了，另一个是要比较的值比待插入的值还要小

现在我们来分析下插入排序的时间复杂度，显而易见的，我们要找到其核心代码比较和更换值的代码的运行次数，当然，这里建立在最坏情况下的分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaefb25460e2746056a3673d408cb947b.png)

最后我们根据大O推导法则，保留最高阶项，去除常数因子，其时间复杂度为O(N^2);这样的排序方法仍然不符合我们的需求，因为当输入规模很大时，其需要的时间还是太久了，因此我们还要学习其他的排序方法

我们之前所学习的排序都是简单排序，他们的时间复杂度都是O(N^2);当输入规模增大时其耗费时长都会特别长，没什么意义，因此我们接下来要学习高级排序，用于高效率的解决输入规模较大时的排序问题

