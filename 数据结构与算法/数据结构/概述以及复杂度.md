# 数据结构与算法概述

什么是数据结构？

## 数据结构介绍

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEbaae13c0460176a3fb16be1c53ac0869.png)

简而言之，数据结构就是把数据元素按照一定关系组织起来的集合，用于组织和存储数据

数据结构总分为逻辑结构和物理结构两大类



逻辑结构

逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系进行分类的

逻辑结构又分为集合结构，线性结构，树形结构以及图形结构



集合结构

集合结构中的元素除了同属于一个集合之外，他们之间没有任何联系

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEecd97e469c09e0c18b63bbb04deb14a0.png)



线性结构

线性结构中的数据元素存在一对一的关系，具体到下图的例子里是一对应着二，二对应着三，三对应着四

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE31926789e6678aa76f1b8df065a99317.png)

树形结构

树形结构中的数据元素存在着一对多的层次关系，具体到下图的例子是A对于B,C,D，而B对应E,F,G

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE92c0d040708cb38f1242d944845d4d18.png)



图形结构

图形结构的数据元素存在着多对多的关系，具体到下图的例子是5对应7,9,3,2

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEec25c19dc8f50d504dc4dce5289f4696.png)

上面的结构都是逻辑结构

接着我们来讲物理结构



物理结构

物理结构是逻辑结构在计算机里的真正表达方式(又被成为映像)，也可以叫存储结构。

常见的物理结构分为顺序存储结构与链式存储结构



顺序存储结构

把数据元素放到地址连续的存储单元里，其逻辑结构和物理关系式一致的，也就是说其存储的地址都是按一定量增加的，比如数组，其优缺点之前的笔记里有些，这里不再赘述



链式存储结构

把数据元素存放到任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。此时，数据元素并不能反映元素间的逻辑关系，因此我们在链式结构里引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联元素的位置

我觉得这很类似于java里的链表，而指针就是java里的引用，当然这只是一个猜测，不保证对



现在我们学习完了数据结构的大体概述，现在我们来学习下算法

## 算法介绍

首先，什么是算法？

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEcb718a7d121cd2ef1e1c5e18d3995f71.png)

简单来说咱们写的代码啊，里面我们设置的条件那些就是算法

算法要很多种，但是一个优秀的算法应该追求以下两点

这两点分别是花最少的时间完成需求以及占最少的内存空间完成需求

值得一提的是，我们这里学习的数据结构是Java的数据结构

# 算法复杂度分析

我们研究算法的最终目的是如何花更少的时间，如何占用更少的内存去完成相同的需求

有关算法的时间耗费分析，我们称之为算法的时间复杂度分析

有关算法的空间损耗分析，我们称之为是算法的空间复杂度分析

现在我们先来研究下算法的时间复杂度分析

## 时间复杂度分析

算法的时间复杂度分析

算法的时间复杂度分析方法有两种，一种是事前分析估算方法，另一种是事后分析估算方法

### 事后分析估算法

事后分析估算方法

先来讲讲事后分析估算方法，请看代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE3f58ae0cf8dfe7b3f8117d369f280a88.png)

简而言之事前分析估算方法就是方法执行前获取一个当前时间，执行后获取一个当前时间，然后打印时间差，这样来获得方法运行需要的时间

这个方法很简单，但是这种方法缺陷很大，需要耗费大量时间去做一个测试程序，耗费时间高，因此一般不用

### 事前分析估算法

事前分析估算方法

事前分析估算方法是指在计算机编写程序前依据统计方法对算法进行估算，我们已知影响算法的运行时间的有以下原因

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE158a96c4c440150151fc42abbab05100.png)

其中2和4是我们程序员所无法决定的，是无法改变的东西，因此我们不予理会，只用1和3进行分析

这样一个程序的运行时间就只依赖于算法的好坏和问题的输入规模了，如果算法还固定了，那么就只和输入规模有关系了

那么我们再次回到我们之前的求和案例，进行分析

先看第一种解法的代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEe6a49735d93548fe358a25ee3e0adf62.png)

我们不难发现，这个代码真正执行的次数的总和为2n+3次，而用于计算结果的代码执行的次数则为n次

在看第二种解法的代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE1dbce3c6ce79bb721ba8c95e4bcc6923.png)

而这个代码发真正执行次数的总和为3次，用于计算结果的代码执行了1次

由于n次执行显然比1次执行要慢，所以我们肯定会采用1次执行的代码好

这里我们不用总和来进行比较，而用核心的用于计算的代码进行比较，这是因为如果我们关注总和，用总和来进行比较的话，那光是分析总和到底有几次都有够折磨了，为了我们算法分析的渐变和统一，我们只关注其核心代码的执行次数，这里是进行了一个简化分析

我们分析一个算法的运行时间，最重要的是把核心操作的次数和输入规模关联起来

接下来我们来看下图

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEf5afb559454c2027aeeada4c7d0c1be2.png)

在本图里，n是我们的输入规模，f(n)是我们的运行时间，而f则是我们的代码核心运行次数

在这里，显然黄函数要优于红函数优于紫函数，我们写代码时，也要尽量追求我们的代码达到红函数和黄函数的函数关系，而不是紫函数

接下来我们来研究函数的渐变增长

先来看看概念

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEcb31e76faf46379265060cf61f18c4ec.png)

其实也不难

比方说当A1(2n+3)与B1(3n+1)时，易知当n>2时，y1恒大于y，此时我们就可以说当n>2时，算法A1的渐进增长小于算法B1的渐进增长，其中n是输入规模

我们由分析易知当N极大时，A1与B1几乎的曲线几乎一致

因此我们可以得出结论，随着输入规模的增大，算法的常数操作可以忽略不计

我们可以再举一个例子，比方说当A2(n^2)与B2(2*(n^2)+1)，当我们的n很大很大时，最终他们的曲线都会十分接近，而他们不止是有着常数的不同，还有着还有着与最高次数项相乘的常数的不同

由此我们可以得出结论，随和输入规模的增大，与最高次项相乘的常数可以忽略

我们再举一个例子，比方说当A3(2n^2+3n+1),B3(2n^3+3n+1)，我们不难发现当n大于2之后，B3的增长速率远高于A3

由此我们可以得出结论，最高次项指数大的，随着n的增长，结果也会变得增长特别快

再经过一些其他图像的分析和推导，我们得出一个结论是算法函数中n的最高次幂越小，算法效率越高

最后我们总结一下规则

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE77f71d5d9f7bb6211a1357c24165edf4.png)

### 大O记法

我们先来看看它的定义

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE8bc0c34b98fb35ccaf9efcc5b4d2d711.png)

或许你看不懂，但没关系，我也看不懂，看不懂就先放着，反正影响不大

在这里我们先记住两点就行了

第一点是，我们在大O记法里，明确了执行次数=执行时间

其次是，一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优解

我们先来看看下面三个代码

首先是第一个代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEc0b42682b29482a5b27409f2c44803f2.png)

这个代码的总执行次数为3次

接着是第二个代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9416e658a90013dcd60e2f4f00073017.png)

第二个代码的总执行次数为n+3次

最后是第三个代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE9819fcd42c4a3cb2a1636b4de1df3d60.png)

第三个代码的总执行次数是n^2+2次

那么我们要如何用大O记法来表示上面三个算法的时间复杂度呢？

首先基于我们之前学习过的对函数渐进增长的分析，我们有以下三条规则可以使用

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE0f29c248d6027b2e334f1d2bac303cf1.png)

这样，第一个算法的总执行次数是3，由于只有一个常数，运用规则1，所以用大O记法表示为O(1)

第二个代码的总执行次数是(n+3)次，由于3是常数，因此3先改为1，又因此规则2，所以最终表示为O(n)

第三个代码的总执行次数是n^2+2次，同理其表示为O(n^2)

常见的大O阶

O(1)为常数阶，一般不涉及循环操作的都是常数阶

O(n)为线性阶，一般含有非嵌套循环涉及线性阶

O(n^2)为平方阶，一般嵌套循环属于这种时间复杂度

O(n^3)为立方阶，一般三重嵌套循环属于这种时间复杂度

来看看下面的代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEb78b79f0b92efeb9e533a22e39883c12.png)

在这个代码里，我们可以设程序执行次数为x，即是假设有x个2相乘之后会跳出循环，则可得式子2^x=n;则可得x=log(2)，其中x为程序执行的次数，即是我们平时用大O阶表示的n

则这个算法的时间复杂度是O(logn)，之所以我们这里直接写log，是因为log的底数无论是多少，随着输入规模的增大，到最后都是趋于一致的，因此可以省略，这种大O阶叫对数阶

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEcf7f0e0656dcb50dfec9afdc77504767.png)

上述大O阶的复杂度从低到高分别为

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEc8ee30e5e07617005c507fcc22ca13ff.png)

一旦我们的复杂度倒数两位甚至更高，比如说平方阶或者立方阶时，即说明我们的算法效率很低，需要优化

### 函数调用的时间复杂度分析

实际我们写的算法里，我们常常会运用到函数，我们计算其时间复杂度时，肯定会不可避免的要对函数调用时进行分析，因此我们接下来学习函数调用的时间复杂度分析

请看代码

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEa29fb0708822ad3cdab8ac589117296f.png)

在上面的代码里我们的核心代码，第四行代码执行了n次，在方法里的代码都会执行一次，那么总和为n，而在方法里没有循环，则其为线性阶O(n)

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE2df9be3ebe4f0bac24954f1b61c7ae67.png)

上面的算法里，调用了n次方法，而在方法里又进行了n次循环，则代码的执行总次数为n^2，则其为平方阶O(n^2)

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE1353a3b70d0c6af31e4715b980db9dde.png)

在上面的算法里，我们先调用了一次方法，在方法里的代码执行了n次，然后们调用了n次方法，在方法里的代码又执行了n次，接着我们跳出了方法之后又执行了一个嵌套循环，又执行n^2次，所以我们的方法总共执行2(n^2)+n

则其为平方阶O(n^2)

我们的算法总是有最好情况与最坏情况的，好的情况下第一次就找出来了，坏的情况下查找到最后还能查找出来，我们要写的算法必须要保证其在最坏情况下也能够高效率的运行，而不能整出只有在特定情况下才能运行良好的程序来

以后我们研究的算法的时间复杂度时，一般也是以最坏情况来分析的

## 空间复杂度分析

算法的空间复杂度分析

由于这里我们学习的Java的数据结构，因此这里我们主要先来讲讲Java内存占用情况

### 内存占用情况

首先是一些基本数据类型的内存占用

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE0fccd780359fc7fe1e3c273d3f6e66a0.png)

其次我们要知道，计算机访问内存的方式都是一次一个字节

字节，称之为Byte，简称为B，一个字节由8个无符号的二进制数组成，存储数值的范围为0-255，0指一个字节的二进制数全为零时，255则是指全为1时

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE452af26ad1425c605ede2ded930c4a44.png)

一个引用，即是内存地址，需要8个字节表示

例如 Date date = new Date();，其中date作为引用需要8个字节

创建一个对象，对象本身需要16个字节用来保存对象的头信息

例如 new Date();需要占用16个字节

对于一般内存的使用，如果不够8个字节，都会被自动填充为8字节，简而言之就是创建的内存必须是8的倍数

请看下面的分析

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEda00cbfc9eb503234992c9896e65cbf4.png)

但是对于java中的数组而言，由于被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24个字节的头信息(16用于对象的开销，4字节用于保存长度，以及4个填充字节(即不满足8的倍数所进行的扩容的字节))

那么现在知道了上面的知识之后，我们正式来学习算法的空间复杂度分析

算法的空间复杂度分析

值得一提的是，算法的空间复杂度分析也是按照大O记法的规则来的

假设我们现在需要设计一个对指定数组进行反转并返回反转的内容的算法，那么请看我们设计的第一个算法

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCEb64386dd3c7e25c6e19f01b244a01636.png)

在这个算法里，我们一共申请了8个字节，循环内部的代码直接无视，那么用大O记法其空间复杂度为O(1);

![](https://rolin-typora.oss-cn-guangzhou.aliyuncs.com/WEBRESOURCE3ed48da6245698b4a934dd9a723b5673.png)

在上图里，我们先申请了四个字节，然后再申请了n*4个字节+数组需要的24字节，共申请了n*4+28字节

则用大O记法为O(n);

那显然是第一个算法用空间少，那当然第一个算法好些是吧

但是其实对于java的开发而言，除非我们是做java的嵌入式开发的，否则我们很多时候都需要管空间复杂度的，因为现在计算机的空间都已经足够大了，这些多少影响真心不大

以后我们说算法的复杂度分析时，如果没有特别指出是空间的复杂度分析，默认都是时间的复杂度分析



