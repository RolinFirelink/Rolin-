- 新增套餐

首先我们现在完成我们的新增套餐的功能的代码开发，还是先来看看我们的需求吧，我们首先需要导入我们的实体类，以及实现一些必须要实现的接口，这些事情我们就不演示了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc7c6d21db19e2e38f72bc448ea1c0058.png)

然后我们来梳理下我们的交互过程，我们这里首先会发送一个请求来获取套餐分类的数据并展示到我们的下拉框中。有个好消息，那就是我们的这个方法在我们之前已经实现好了，我们这里重复会重复调用这个方法并展示，所以就不用再自己构造这个方法了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf2a1eae87215cad7b6350835fc2f3de4.png)

然后我们要完善的功能是向服务端获取请求，并在页面中回显各式菜品的方法，从前端发送的请求中我们可以知道该方法请求的地址是dish/list，因此我们要到我们的dishcontroller中去添加我们的方法，该地址发送的请求是一个long型的id，我们可以用long型参数来承接，也可以用一个对象来承接，用对象的时候不需要加任何注解，我们的SpringMVC会自动将该类封装为一个对象，我们这里选择后者，因为其扩展性更强（其运作逻辑是当我们选择任何一个菜类的时候，就发送一个对应的id，然后我们可以用这个id查出所有的对应的分类的菜品）

然后我们要查询并返回的结果就是我们们的菜品id，这里我们做一个过滤条件，所有停售的菜品，我们都不收集他们的结果，这也符合逻辑，都停售了我收集来干嘛

那么最终我们可以写入我们的代码如下

```
/**
 * 根据条件查询菜品数据
 * @param dish
 * @return
 */
@GetMapping("/list")
public R<List<Dish>> list(Dish dish){

    //构造查询条件
    LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId());
    //添加条件，查询状态为1（启售状态）的菜品
    queryWrapper.eq(Dish::getStatus,1);
    //添加排序条件
    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);

    List<Dish> list = dishService.list(queryWrapper);

    return R.success(list);
}
```

接着我们来学习如何新增套餐，这个过程其实和新增菜品几乎一模一样，首先我们的上传图片这个功能我们之前已经实现过了，所以我们这里不需要实现这个功能了

然后我们进行我们的前端代码的分析，我们会发现，我们前端发送的数据里，包含一个json数据，json数据中含有我们所选择的菜品对象，那么我们原来的菜品对象中没有这个属性，那么我们就无法承接，此时我们要就需要使用我们的自造对象dto了，请看代码

可以看到我们这里继承原对象，并添加了新的承接的属性，然后我们还设置了一个字符串类型的参数，该参数的作用我们先按下不表

```
package com.itheima.reggie.dto;

import com.itheima.reggie.entity.Setmeal;
import com.itheima.reggie.entity.SetmealDish;
import lombok.Data;
import java.util.List;

@Data
public class SetmealDto extends Setmeal {

    private List<SetmealDish> setmealDishes;

    private String categoryName;
}

```

然后我们在对应的接口中创建一个新的保存方法

```
public interface SetmealService extends IService<Setmeal> {

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     * @param setmealDto
     */
    public void saveWithDish(SetmealDto setmealDto);

}
```

然后我们在对应的实现类中实现这个方法

```
package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.dto.SetmealDto;
import com.itheima.reggie.entity.Setmeal;
import com.itheima.reggie.entity.SetmealDish;
import com.itheima.reggie.mapper.SetmealMapper;
import com.itheima.reggie.service.SetmealDishService;
import com.itheima.reggie.service.SetmealService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class SetmealServiceImpl extends ServiceImpl<SetmealMapper, Setmeal> implements SetmealService {

    @Autowired
    private SetmealDishService setmealDishService;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     * @param setmealDto
     */
    @Override
    @Transactional
    public void saveWithDish(SetmealDto setmealDto) {

        //保存套餐的基本信息，操作setmeal，执行insert操作
        this.save(setmealDto);

        List<SetmealDish> setmealDishes = setmealDto.getSetmealDishes();

        setmealDishes.stream().map((item) -> {
            item.setSetmealId(setmealDto.getId());
            return item;
        }).collect(Collectors.toList());

        //保存套餐和菜品的关联信息，操作setmeal_dish,执行insert操作
        setmealDishService.saveBatch(setmealDishes);

    }
}

```

这里我们要保存套餐的基本信息，还要保存其关联信息，这个讲过一遍了，这里就不赘述了

然后我们在对应的控制层中调用该方法即可

```
/**
 * 新增套餐
 * @param setmealDto
 * @return
 */
@PostMapping
public R<String> save(@RequestBody SetmealDto setmealDto) {
    log.info("套餐信息：{}",setmealDto);

    setmealService.saveWithDish(setmealDto);

    return R.success("新增套餐成功");
}
```

- 套餐管理分页查询

接着我们来学习如何开发套餐管理分页查询，其实这个很简单，跟我们之前搞菜品的分页查询那一套不能说十分相像，只能说是一模一样，来做一下吧

我们直接来看代码吧，其实也没啥值得说的，这里做的事情无非就是复制新的分页对象，然后创建我们的新的对象的集合，利用复制工具类而且从数据库中执行二次查找，都是以前的老东西了，不多提了

```
/**
 * 套餐管理分页查询并展示
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public R<Page> page(int page,int pageSize,String name) {
    //分页构造器对象
    Page<Setmeal> pageInfo = new Page<>(page,pageSize);
    Page<SetmealDto> dtoPage = new Page<>();

    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
    //添加查询条件，根据name进行like模糊查询
    queryWrapper.like(name !=null,Setmeal::getName,name);
    //添加排序条件，根据更新时间降序排序
    queryWrapper.orderByDesc(Setmeal::getUpdateTime);

    setmealService.page(pageInfo,queryWrapper);

    //对象拷贝
    BeanUtils.copyProperties(pageInfo,dtoPage,"records");
    List<Setmeal> records = pageInfo.getRecords();

    List<SetmealDto> list = records.stream().map((item) -> {
        SetmealDto setmealDto = new SetmealDto();
        //对象拷贝
        BeanUtils.copyProperties(item,setmealDto);
        //分类id
        Long categoryId = item.getCategoryId();
        //根据分类id查询分类对象
        Category category = categoryService.getById(categoryId);
        if(category != null){
            //分类名称
            String categoryName = category.getName();
            setmealDto.setCategoryName(categoryName);
        }
        return setmealDto;
    }).collect(Collectors.toList());

    dtoPage.setRecords(list);
    return R.success(dtoPage);
}
```

- 套餐删除功能代码开发

首先我们还是来看看我们的套餐删除的前端的并发过程吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbaeeba288df67b0dd413de4805fdeca2.png)

然后我们容易知道该删除过程是要操作多表的，不但如此，而且我们的批量删除和删除都是在一个方法下的，因此我们要在一个方法下完成这两个功能，首先我们要在对应的服务层中创建对应的方法

```
/**
 * 批量删除套餐
 * @param ids
 */
public void deleteWithDish(List<Long> ids);
```

接着我们来实现我们的方法，写入其具体代码如下，我们这里值得一提的是，要注意我们的泛型规定的实体类和我们调用的方法所需要的对应的实体类，如果不同的话，会报错的，具体的错误说实话我现在也不好说，总之是会有的。

我们是真的有必要做完这个项目之后自己一个人盲做一次，把错误总结总结，否则我们的基础是不牢固的。

```
/**
 * 删除或批量删除套餐
 * @param list
 */
@Override
@Transactional
public void deleteWithDish(List<Long> list) {
    //查询套餐状态，确定是否可用删除
    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.in(Setmeal::getId,list);
    queryWrapper.eq(Setmeal::getStatus,1);

    int count = this.count(queryWrapper);
    if(count > 0){
        //如果不能删除，抛出异常业务异常
        throw new CustomException("套餐正在售卖中，不能删除");
    }

    //如果可以删除，先删除套餐表中的数据---setmeal
    this.removeByIds(list);

    LambdaQueryWrapper<SetmealDish> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.in(SetmealDish::getSetmealId,list);

    //删除关系表中的数据----setmeal_dish
    setmealDishService.remove(lambdaQueryWrapper);
}
```

然后我们的控制层中我们调用该方法即可

```
/**
 * 根据id删除或者批量删除套餐
 * @param ids
 * @return
 */
@DeleteMapping
public R<String> deleteByIds(@RequestParam("ids") List<Long> ids){
    log.info("ids:{}",ids);

    setmealService.deleteWithDish(ids);

    return R.success("套餐数据删除成功");
}
```

接下来的内容就是我们自主开发的了，首先我们来讲解我们的修改功能，首先我们要做的事情是读取到数据库中的数据并回显到我们的页面上，因此我们首先需要开发的方法是根据id的查询方法，因为点击修改前端就会发出这个含有id数据附在地址上的请求

我们首先在对应的接口上创建方法

```
/**
 * 根据id查询套餐信息
 * @param ids
 * @return
 */
public SetmealDto getByIdWithDish(Long ids);
```

然后我们实现该方法，我们这里由于我们的对象还含有分类的数据，因此我们这里要做的事情是先查出普通的菜品对象，然后复制到dto对象中，接着查出对应套餐的具体菜品，封装到我们的dto对象中并返回该dto对象

```
/**
 * 根据id查询套餐内容并回显
 * @param ids
 * @return
 */
@Override
public SetmealDto getByIdWithDish(Long ids) {
    //查询套餐的基本信息，从数据表中查询
    Setmeal setmeal = this.getById(ids);
    SetmealDto setmealDto = new SetmealDto();

    BeanUtils.copyProperties(setmeal,setmealDto);

    //查询当前套餐下的具体菜品
    LambdaQueryWrapper<SetmealDish> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(SetmealDish::getSetmealId,ids);
    List<SetmealDish> list = setmealDishService.list(queryWrapper);
    setmealDto.setSetmealDishes(list);

    return setmealDto;
}
```

最后要做的事情就是去控制层中调用该方法即可，注意我们的返回值里就要返回该对象，这样我们的前端才可以取出这些数据并使用，然后我们取出连接中的代码的方法是通过PathVariable注解获取

```
/**
 * 根据id查询对应的套餐信息
 * @param id
 * @return
 */
@GetMapping("/{id}")
public R<SetmealDto> get(@PathVariable Long id) {

    SetmealDto setmealDto = setmealService.getByIdWithDish(id);

    return R.success(setmealDto);
}
```

接着我们来实现修改功能的保存，其实也是依葫芦画瓢，先删除再添加即可，这里的有意思的一点在于，我发现直接调用修改和增添的方法也可以实现我们的目的，而不需要我们再去做其他更多的工作，但是老师这里总是再写一份代码，我们也是配合一下老师的写法吧，所以我们这里来个梅开二度

首先创建新的修改方法

```
/**
 * 修改套餐信息
 * @param setmealDto
 */
public void updateWithDish(SetmealDto setmealDto);
```

然后我们实现该方法

```
/**
 * 修改套餐信息
 * @param setmealDto
 */
@Override
public void updateWithDish(SetmealDto setmealDto) {
    //查询套餐状态，确定是否可以修改
    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();

    List<Long> list = new ArrayList<>();
    list.add(setmealDto.getId());
    queryWrapper.in(Setmeal::getId,list);
    queryWrapper.eq(Setmeal::getStatus,1);

    int count = this.count(queryWrapper);

    if(count > 0){
        //如果不能修改，抛出业务运行异常
        throw new CustomException("套餐正在售卖中，不能修改");
    }

    //如果可以修改，则先删除表中的对应数据
    this.removeByIds(list);

    LambdaQueryWrapper<SetmealDish> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.in(SetmealDish::getSetmealId,list);

    //删除记录套餐中具体餐品的表中的指定数据
    setmealDishService.remove(lambdaQueryWrapper);


    //saveWithDish(setmealDto);

    //保存套餐的基本信息，操作setmeal，执行insert操作
    this.save(setmealDto);

    List<SetmealDish> setmealDishes = setmealDto.getSetmealDishes();

    setmealDishes.stream().map((item) -> {
        item.setSetmealId(setmealDto.getId());
        return item;
    }).collect(Collectors.toList());

    //保存套餐和菜品的关联信息，操作setmeal_dish,执行insert操作
    setmealDishService.saveBatch(setmealDishes);
}
```

接着在控制层中调用我们的方法即可

```
/**
 * 修改套餐内容的方法
 * @param setmealDto
 * @return
 */
@PutMapping
public R<String> update(@RequestBody SetmealDto setmealDto){
    log.info(setmealDto.toString());

    setmealService.updateWithDish(setmealDto);

    return R.success("套餐修改成功");
}
```

- 停售启售功能

然后我们来实现我们的最后一个功能，就是停售和启售功能的代码的开发这个说实话真的是非常简单了，获取对应的值然后直接修改套餐的对应数据即可，请看代码

```
/**
 * 修改或批量修改套餐的停售启售状态
 * @param stu
 * @param list
 * @return
 */
@PostMapping("status/{stu}")
public R<String> modify(@PathVariable Integer stu,@RequestParam("ids") List<Long> list){

    for (Long ids:list) {
        Setmeal setmeal = setmealService.getById(ids);
        setmeal.setStatus(stu);
        setmealService.updateById(setmeal);
    }

    return R.success("套餐状态修改成功");
}
```

