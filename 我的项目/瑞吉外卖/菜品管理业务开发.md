- 文件的上传与下载

首先我们来实现文件的上传与下载的代码，这里我们完成我们的菜品管理业务开发的第一步，先来看看步骤

首先我们来看看文件上传时对前端的表单的格式的要求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5f5797f2bc398a5ddca8dbcd7ecac17c.png)

然后是文件上传时前端组件库提供了相应的上传组件，但是其底层原理还是基于form表单的文件上传

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE421927f57e0f041f5954f9b479e61ac1.png)

在Spring框架中封装了文件上传，我们可以调用MultipartFile对象来进行文件上传，但是我们要记住其本质还是调用Apache的上传的两个组件的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE77b0316d9797b8798e1dc6754d7ef0be.png)

最后我们来看看文件下载，我们这里的文件下载是将文件从服务器传输到本地计算机的过程，我们直接在浏览器中下载，这样好直接将数据在浏览器中展示，具体请看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1ee2591846f8889e8d6971304a89981d.png)

我们文件上传的页面就直接使用ElementUI提供的上传组件即可，对应的页面在我们的课程资料里有，直接复制到我们的项目中即可使用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEaba2d69cad9472c0e2b15d268c7d6944.png)

这里我们要提一下的是，我们测试时会发现我们无法进入该上传页面，这是由于我们的页面少了这么一行内容，在head中加入即可使用

```
<link rel="shortcut icon" href="../../favicon.ico" />
```

然后是我们的页面每次测试都要重新登录一次，这太麻烦了，所以我们干脆在过滤类中不用进行过滤的页面路径中加入我们的上传页面路径

```
"/common/**"
```

我们分析前端的代码容易发现我们的上传其实也是往服务器里发送一个请求，这个请求的映射路径还是以common起始的，因此我们要创建一个新的类用于处理该请求类，同时我们要知道我们Spring中提供的MultipartFile对象是一个临时文件的保存对象，该对象如果不保存到本地的话，就会自然消失，因此我们要将其保存到本地，保存到本地自然需要一个地址，我们在yml中配置这个地址（千万不要忘记冒号后要加一个空格哦）

```
reggie:
  path: D:\pain\
```

然后我们写入我们的该类的上传文件的代码如下

```
package com.itheima.reggie.controller;

import com.itheima.reggie.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

/**
 * 文件上传与下载
 */
@RestController
@RequestMapping("/common")
@Slf4j
public class CommonController {

    @Value("${reggie.path}")
    private String basePath;

    /**
     * 文件上传
     * @param file
     * @return
     */
    @PostMapping("upload")
    public R<String> upload(MultipartFile file) {
        //file是一个临时文件，需要转存到指定位置，否则本次请求完成后file会被删除
        log.info(file.toString());

        //原始文件名
        String originalFilename = file.getOriginalFilename();//abc.jpg
        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));

        //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖
        String fileName = UUID.randomUUID().toString() + suffix;

        //创建一个目录对象
        File dir = new File(basePath);
        //判断当前目录是否存在
        if(!dir.exists()){
            //目录不存在，需要创建
            dir.mkdirs();
        }

        try {
            file.transferTo(new File(basePath+fileName));
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        return R.success(fileName);
    }
}

```

我们这里首先通过对应的注解获取我们yml中定义的数据，然后我们使用UUID生成文件名，同时获得原来的文件名获得其文件格式名，接着将其进行拼接形成新的文件名，最后我们要对我们要保持的文件目录进行判断，如果存在我们则执行存入，不存在我们就创建之后存入，最后我们返回一个成功信息结合文件名即可

接着我们来开发与文件下载相关的代码，由于我们只是将对应的数据写会到我们的浏览器即可，因此我们这里不需要返回值，同时get请求的方式即可完成我们的目标，我们首先获取到对应的文件，然后写回到浏览器中即可，同时中间我们设置了我们相应的文件的类型，这里指定为图片类型

```
@GetMapping("/download")
public void download(String name, HttpServletResponse response) {

    try {
        //输入流，通过输入流读取文件内容
        FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));

        //输出流，通过输出流将文件写回浏览器，在浏览器中展示图片
        ServletOutputStream outputStream = response.getOutputStream();

        response.setContentType("image/jpeg");

        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fileInputStream.read(bytes)) != -1){
            outputStream.write(bytes,0,len);
            outputStream.flush();
        }

        outputStream.close();
        fileInputStream.close();

    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

- 菜品管理业务开发

我们首先来看看我们的业务要达到的效果

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9b307feb4085e79a363dafd913f2d4ba.png)

然后是我们的数据模型，涉及到两个表，想看具体的内容就自己去数据库中看吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5dd3071885f8844bd814c67755d015b4.png)

然后我们要做一些代码开发的准备工作，这里照旧是三次架构的构建，依葫芦画瓢即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6247156ef97e703cf2588bf41dca047f.png)

然后我们来梳理下我们的交互过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1180b0b0ea0addc69fd1aa3094a764ee.png)

然后我们先来实现我们的新增菜品中的菜品分类的下拉框的内容，分析前端代码，我们容易知道其向服务器发送的请求是在category路径中的，因此我们要往category中添加方法，同时菜品分类下拉框的原理是从数据库中读取所有的菜品，获取其所有分类保存到集合中再返回给浏览器，浏览器则用该集合进行回显

那么我们可以写入我们的代码如下

```
/**
 * 根据条件查询分类数据
 * @param category
 * @return
 */
@GetMapping("/list")
public R<List<Category>> list(Category category) {
    //条件构造器
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
    //添加条件
    queryWrapper.eq(category.getType() != null,Category::getType,category.getType());
    //添加排序条件
    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);

    List<Category> list = categoryService.list(queryWrapper);

    return R.success(list);
}
```

我们这里通过菜品对象直接获得传入的属性数据，其会自动封装到我们的菜品对象中，然后我们创建对应的构造器，利用该菜品对象构建构造器最终获得一个集合，并将该集合返回。

最后值得一提的是，由于前端提交的路径里传送的数据并不是json类型的，因此我们这里的参数不需要使用RequestBody注解

接着我们来讲解我们如何开发我们的新增菜品功能，我们首先分析前端点击新建菜品功能之后传送过来的数据，我们会发现起其下不但有菜品本身的各种属性，甚至还有一些额外的菜品口味属性，此时我们如果只用菜品对象，那么是无法承接这一份数据的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7d0adbc341187d24a7cd5d93c18d1450.png)

那么我们应该要如何解决这个问题呢？其实非常简单，我们只要创建一个全新的类用于展示层和服务层的数据传输即可，将该类继承原类，然后在其下定义我们所需要的承接其他数据的属性即可，具体代码如下

```
package com.itheima.reggie.dto;

import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.entity.DishFlavor;
import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDto extends Dish {

    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;

    private Integer copies;
}

```

上面的代码里还多了两个属性，这些是我们以后要用的属性，这里我们先按下不表

然后我们要注意的是，我们保存菜品时，其实是保存了两个内容的，一是我们菜品本身，二是和菜品关联的口味，因此我们的保存方法实际是要保存菜品和口味两个内容的，而MP提供给我们的方法就只有保存菜品和保存口味，因此我们要创建一个新方法让我们能够一起保存。首先我们在DishService的接口中创建该方法

```
public interface DishService extends IService<Dish> {

    //新增菜品，同时插入菜品对应的口味数据，需要操作两张表：dish、dish_flavor
    public void saveWithFlavor(DishDto dishDto);

}
```

然后我们去具体的实现类中重写该方法，我们这里首先给我们的类中注入对应的要调用方法的菜品口味对象

```
package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.dto.DishDto;
import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.entity.DishFlavor;
import com.itheima.reggie.mapper.DishMapper;
import com.itheima.reggie.service.DishFlavorService;
import com.itheima.reggie.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class DishServiceImpl extends ServiceImpl<DishMapper, Dish> implements DishService {

    @Autowired
    private DishFlavorService dishFlavorService;

    /**
     * 新增菜品，同时保存对应的口味数据
     * @param dishDto
     */
    @Override
    @Transactional
    public void saveWithFlavor(DishDto dishDto) {
        //保存菜品的基本信息到菜品表dish
        this.save(dishDto);

        Long dishId = dishDto.getId();//菜品id

        //菜品口味
        List<DishFlavor> flavors = dishDto.getFlavors();
        flavors = flavors.stream().map((item) -> {
            item.setDishId(dishId);
            return item;
        }).collect(Collectors.toList());

        //保存菜品口味数据到菜品口味表dish_flavor
        dishFlavorService.saveBatch(flavors);
    }
}

```

然后我们先调用菜品自身的保存方法，将菜品保存，然后我们获得菜品的id，然后用输入流的方式将菜品id注入到我们的菜品口味对象中，我们的菜品口味是必须要先经过这个处理的，否则谁知道这个口味是对应哪个菜品的啊，最后我们再调用MP提供给我们的保存菜品口味数据的方法即可

而上面的方法整个都在我们的菜品服务层中，我们只要保存的时候调用该方法即可，那么我们可以构造如下代码

```
package com.itheima.reggie.controller;

import com.itheima.reggie.common.R;
import com.itheima.reggie.dto.DishDto;
import com.itheima.reggie.service.DishFlavorService;
import com.itheima.reggie.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 菜品管理
 */
@RestController
@RequestMapping("/dish")
@Slf4j
public class DishController {

    @Autowired
    private DishService dishService;

    @Autowired
    private DishFlavorService dishFlavorService;

    @PostMapping
    public R<String> save(@RequestBody DishDto dishDto) {
        log.info(dishDto.toString());

        dishService.saveWithFlavor(dishDto);

        return R.success("新增菜品成功");
    }
}
```

- 菜品分页查询

接着我们来实现菜品的分页查询

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2b6e109ef807e7c7589b4a10fd26699f.png)

这里我们要注意的是，我们的菜品的分页查询和我们之前员工的分页查询并不同，那就是我们菜品的分页查询中是有菜品分类这一栏的，而我们的实体类的菜品中是没有这个属性的，具体我们从前端代码中就可以看出，前端代码会从传回数据中寻找categoryName的属性，这个属性能够用于让前端判断展示菜品分类的内容，而由于我们原来的菜品中压根没有这玩意，那么就会让我们的菜品分页查询中的这一栏直接失效

那么我们要如何解决这个问题呢？我们的一个简单想法就是用另外一个类来代替我们原来的菜品类，没错，就是我们之前拷贝进来的Dishdto类。我们创建对应的方法，然后构造分页构造器的Dish和DishDto对象，前者我们要传入指定的页数和最大页数，而后者不用，然后用一系列的查询排序语句得到我们所需要的pageInfo的对象，但是这个对象不是我们所需要的，因此我们要将这个对象的内容拷贝到我们的dishDtoPage中，注意我们这里拷贝的是属性，而非其下的内容，这里第一次拷贝的属性是分页的各种数据，而保存分页查询的结果的数据我们则跳过拷贝，我们拷贝使用工具类拷贝

```
/**
 * 菜品管理分页查询
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public R<Page> page(int page,int pageSize,String name) {

    //构造分页构造器对象
    Page<Dish> pageInfo = new Page<>(page,pageSize);
    Page<DishDto> dishDtoPage = new Page<>();

    //条件构造器
    LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();

    //添加过滤条件
    queryWrapper.like(name != null,Dish::getName,name);

    //添加排序条件
    queryWrapper.orderByDesc(Dish::getUpdateTime);

    //执行分页查询
    dishService.page(pageInfo,queryWrapper);

    //对象拷贝
    BeanUtils.copyProperties(pageInfo,dishDtoPage,"records");

    List<Dish> records = pageInfo.getRecords();

    List<DishDto> list = records.stream().map((item) -> {
        DishDto dishDto = new DishDto();

        BeanUtils.copyProperties(item,dishDto);

        Long categoryId = item.getCategoryId();//分类id

        //根据id查询分类对象
        Category category = categoryService.getById(categoryId);

        if(category != null){
            String categoryName = category.getName();
            dishDto.setCategoryName(categoryName);
        }

        return dishDto;
    }).collect(Collectors.toList());

    dishDtoPage.setRecords(list);

    return R.success(dishDtoPage);
}
```

然后获取到内容的集合，然后每次用流的形式将集合内的内容取出，拷贝其所有内容到我们的新对象中，然后取出其id在数据库里查询其分类，得到分类数据之后再设置到我们的新对象中，最后返回这个集合，然后将这个集合设置到我们的分页数据中，最后返回这个分页对象就行了

- 菜品修改功能开发

接着我们来开发菜品修改的功能，首先我们来梳理下我们的菜品开发的交互过程，我们首先要完成的当然是数据的回显

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEee787b587f776dfd30f12f59c75de2a3.png)

我们点击修改之后，页面会获取到对应的id然后向服务器发送这个id，服务器接收到这个id之后应该要响应对应的数据回来，我们注意到这里我们不但要响应菜品本身的数据，还要显示菜品的口味数据，因此我们最好就返回DishDto的对象，这个对象正好就有我们所需要的两个属性

我们先去对应的接口中创建对应的查询方法

```
//根据id查询菜品信息和对应的口味信息
public DishDto getByIdWithFlavor(Long id);

```

然后我们实现这个方法，我们这里实现方法的方式无非也就是拷贝和转换对象以及调用原来的查询方法等过程，这里就不赘述了

```
/**
 * 根据id查询菜品信息和对应的口味信息
 * @param id
 * @return
 */
@Override
public DishDto getByIdWithFlavor(Long id) {
    //查询菜品基本信息，从dish表查询
    Dish dish = this.getById(id);

    DishDto dishDto = new DishDto();
    BeanUtils.copyProperties(dish,dishDto);

    //查询当前菜品对应的口味信息，从dish_flavor表查询
    LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(DishFlavor::getDishId,dish.getId());
    List<DishFlavor> flavors = dishFlavorService.list(queryWrapper);
    dishDto.setFlavors(flavors);

    return dishDto;
}
```

然后我们在对应的查询方法中调用我们新创建的方法即可

```
/**
 * 根据id查询菜品信息以及对应的口味信息
 * @param id
 * @return
 */
@GetMapping("/{id}")
public R<DishDto> get(@PathVariable Long id) {

    DishDto dishDto = dishService.getByIdWithFlavor(id);

    return R.success(dishDto);
}
```

最后我们来讲解我们的保存的方法，我们的更新保存方法和我们的之前的新创建的方法非常像，我们也是依葫芦画瓢，我们首先在对应的接口中创建一个新方法

```
//保存修改的菜品信息
public void updateWithFlavor(DishDto dishDto);
```

然后我们具体实现其代码，我们这里怎么实现我们的更新呢？想当然的事情当然是往里面查找对应的id并修改，但是这样的话，我们要处理的情况可就多了去了，因为我们修改的内容可能是更多，或者更少，还有不变，这样我们分情况讨论一个个处理能把我们麻烦死。其实我们的有一个简单的想法就是一旦进行了提交修改，我们就我先将数据库的对应内容给删除掉，然后再直接执行原来的保存的内容，这样我们就不必去区分什么情况了

根据这想法，我们容易写入我们的代码如下，我们这里先更新dish表中的信息（这里可以直接更新是因为MP给我们预先提供好了这些东西），然后我们对口味的数据则是直接删除所有数据，接着再填入新的数据

```
/**
 * 修改菜品信息
 * @param dishDto
 */
@Override
@Transactional
public void updateWithFlavor(DishDto dishDto) {
    //更新dish表基本信息
    this.updateById(dishDto);

    //清理当前菜品对应口味数据---dish_flavor表的delete操作
    LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());

    dishFlavorService.remove(queryWrapper);

    //添加当前提交过来的口味数据---dish_flavor表的inset操作
    List<DishFlavor> flavors = dishDto.getFlavors();

    flavors = flavors.stream().map((item) -> {
        item.setDishId(dishDto.getId());
        return item;
    }).collect(Collectors.toList());

    dishFlavorService.saveBatch(flavors);
}
```

最后我们再修改菜品的方法上调用该方法即可

```
/**
 * 修改菜品
 * @param dishDto
 * @return
 */
@PutMapping
public R<String> update(@RequestBody DishDto dishDto) {
    log.info(dishDto.toString());

    dishService.updateWithFlavor(dishDto);

    return R.success("修改菜品成功");
}
```

- 菜品批量删除以及菜品批量停售启售功能的开发

下面的功能就属于是自己实战开发的功能了，可以说是极具挑战性，还就是突出一个起飞我只能说，首先我们先来实现菜品删除和批量删除的功能，首先我们通过分析我们很容易能够得知，其实删除和批量删除请求的都是一个方法，所以我们要将这个两个方法开发到一出去，而我们从前端的F12页面分析其请求，我们会发现前端发送批量与否的内容主要区别在于后面跟的id是一个还是多个，所以我们这里可以用RequestParam注解来接受ids属性后面的所有id，并令其自动封装到一个List集合中

接着我们要知道，我们的菜品删除不只是要删除菜品，还需要删除与菜品关联的菜品口味，因此我们这里需要新创建一个删除方法，利用该删除方法来实现我们的需求。首先在对应的业务层接口中创建该方法如下

```
//删除菜品信息
public void deleteWithFlavor(List<Long> ids);
```

然后我们具体实现该方法，我们这里取出该集合，用foreach循环一个个进行单独的菜品以及菜品风格的删除处理，这里要注意由于我们这里涉及到了多表操作，因此别忘了加上Transactional注解

```
/**
 * 删除或批量删除菜品
 * @param list
 */
@Override
@Transactional
public void deleteWithFlavor(List<Long> list) {
    for (Long ids:list) {
        this.removeById(ids);

        //清理当前菜品对应口味数据---dish_flavor表的delete操作
        LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(DishFlavor::getDishId,ids);

        dishFlavorService.remove(queryWrapper);
    }
}
```

最后我们在控制层中调用该方法即可

```
/**
 * 根据id删除或者批量删除数据
 * @param ids
 * @return
 */
@DeleteMapping
public R<String> deleteByIds(@RequestParam("ids") List<Long> ids){
    log.info(ids.toString());

    dishService.deleteWithFlavor(ids);

    return R.success("删除菜品成功");
}
```

然后我们再来讲讲批量改变状态的方法，这个其实也依葫芦画瓢了，不过我们这里要注意的是，其传入的地址不仅有id，其会在id前先拼接上status的地址以及一个/要改变的状态，其中0代表启售状态，其他数字代表非启售状态，因此我们开发的方法里应该要承接这个前面的启售停售的数据之后我们再来承接后面的id内容

同样的我们先添加一个抽象方法

```
//改变菜品状态
public void modifyStatus(Integer stu,List<Long> ids);
```

然后实现该方法，我们这里实现该方法的方式是提取出对应id的对象，然后改变其状态之后再执行新对象对就对象的修改

```
/**
 * 改变或批量改变菜品状态
 * @param list
 */
@Override
public void modifyStatus(Integer stu,List<Long> list) {
    for (Long ids:list) {
        Dish dish = this.getById(ids);
        dish.setStatus(stu);
        this.updateById(dish);
    }
}
```

然后在控制层中调用我们造的方法即可

```
/**
 * 根据id改变或批量改变菜品状态
 * @param ids
 * @return
 */
@PostMapping("/status/{stu}")
public R<String> modifyStatusByIds(@PathVariable Integer stu,@RequestParam("ids") List<Long> ids){
    log.info(ids.toString());

    dishService.modifyStatus(stu,ids);

    return R.success("更改状态成功");
}
```

到此为止，我们的菜品管理的所有业务就开发完毕了