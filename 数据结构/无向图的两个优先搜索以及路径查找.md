在正式讲解图之前，我们要先了解下图的相关概念，这个其实在离散里就已经学习过了，所以图的相关概念我们随便讲讲就差不多得了，重点是如何在代码里实现图

首先图分为有向图和无向图，有向图就是指两个结点之间的线有方向，而无向图是没有方向的，有向图只能够按照其方向来说谁连接谁，而无向图正说反说都是允许的

图还有自环和平行边的特殊情况，但是这些情况我们数据结构里不讲，那我们就不学，离散里有讲就是，当时折磨我老久了

最后我们来看看关于图的定义的解释图吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE350e3f2cca15c79660ef2266c6e2aa3a.png)



图的相关术语

在正式学习图之前，我们要学习关于图的相关术语，大多都已经在离散里学过了，所以这里简单过过就差不多得了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9d160ef19e7a66ed6a3173486dd638eb.png)

接着是关于连通图的相关术语

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEade7f6a766e58b3dd495aed98b4a8e82.png)



图的存储结构

接着我们来说说我们在计算机里如何表示图，在计算机里图的存储结构有两种，分别是邻接矩阵和邻接表

先来讲讲邻接矩阵吧，由于离散数学里学过了，这里随便讲讲

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb0b59c2961079c6443454ce33f7f7769.png)

邻接矩阵聊表示无向图的方式的问题在于其空间复杂度是O(N^2);，当数据量很大时要占用太多的空间，因此我们一般不采用这种方式来表达邻接矩阵

接着来说说邻接表的方式，邻接表是使用一个数组和队列结合的方式来表示无向图的，首先创造一个大小为V的队列数组，数组里的每一个对象都是一个队列，数组的索引表示对应的结点，而每个索引里存放的就是与该结点连通的其他结点，由于这里表示的是无向图，因此队列里存放的顺序无关紧要

其空间需求就比邻接矩阵的方式要小得多，因此我们以后都采用邻接表的存储形式来表示图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc293aebc93afba51407a98504753d4da.png)

值得一提的是，用邻接表的形式来计算边时会导致边多计算一遍，因此我们通常如果用邻接矩阵来计算边的个数，是要将其除去一半的



无向图实现

首先明确一点我们这里实现的是无向图而不是有向图，有向图我们以后再实现，先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7e1d5439080f1371132b41afb5dbf1ba.png)

这里我们创建一个数组，数组里存放队列，队列里存放Integer类型的对象，根据API我们可以实现其代码如下（注意这里用的队列数据结构是我们之前创建好的数据结构，不是java中自带的）

那么根据API我们可以实现其代码如下

```javascript
package algorithm.sort;

public class Graph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;
    public Graph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量,最开始没有边，只有顶点，因此赋予0
        this.E = 0;
        //初始化邻接表，创建对应大小的队列数组
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }

    //获取顶点数目
    public int V(){
        return V;
    }

    //获取边的数目
    public int E(){
        return E;
    }

    //向图中添加一条边v-w
    public void addEdge(int v,int w){
        //无向图的边没有方向，一条边既可以说是从A到B也可以说是从B到A
        //因此我们要令A出现在B的邻接表中，也要让B出现在A的邻接表中
        //这样才能算是将一条边成功添加，所谓邻接表其实就是队列
        adj[v].enqueue(w);//将w添加到v的队列中
        adj[w].enqueue(v);//将v添加到w的队列中
    }

    //获取和顶点V相邻的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];//返回顶点V的队列，其队列中存放与其相邻的所有结点
    }

}
```



深度优先搜索

我们在实现完图之后，我们如果想要找到任意一个图中的一个结点的所有相邻结点，那我们应该怎么办呢？这时我们就需要给我们的程序提供搜索方法，有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索

深度优先搜索指的是我们的算法在搜索时如果遇到一个结点既有子节点又有兄弟结点，那么其会优先找子节点，然后找兄弟结点。这样讲可能不好理解，请看演示图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9b694750581960f424711daf8c5d73a8.png)

比如说我们想要查找和顶点0的所有邻接节点，那么首先进入0的队列中搜索，第一个搜索到6，发现6自身有子节点0,4，而且又有兄弟结点2,1,5，由于我们是深度优先搜索，因此我们先进入6的子节点中搜索，搜索到0，因为0已经搜索过了，所以不用再次搜索，因此跳过0搜索4，此时4又有子节点，5,6,3，按照深度优先搜索先进入5搜索，而5中又有.........最后全部搜索到最后一个结点的子节点之后就不断返回

显然，这应该要使用递归来去实现，事实上，经常出现在力扣上的题目都是以深度优先搜索为思路的题目都是运动到了递归的



深度优先搜索的实现

接着我们就来实现深度优先搜索的代码，先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1b2642208a8b7f86be6d08f05621ec92.png)

由于在无向图中边时没有方向的，因此结点是可能互相出现在不同结点的相邻结点里的，在我们的存储方式里的体现就是两个队列中的结点可能会互相出现，比如说5出现在4中，4出现在5中，但是我们进行搜索时肯定是不要进行重复搜索的，因此我们要提供一个方法来让我们程序来确定这个节点还有没有必要进行搜索

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbb13f5ed36a5581b3852bc08a3a89a4c.png)

我们这里用一个布尔类型的数组boolean[V] marked，所以代表顶点，对应的值若为true说明该顶点已经被搜索，无需再搜索，反之则标记为false

那么根据其API设计我们可以构造深度优先搜索的代码如下

```javascript
package algorithm.sort;

public class DepthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;

    /*
     * 由于我们在构造方法里调用了找出图中所有结点的dfs方法，所以在测试
     * 类里我们一旦创建了深度优先搜索对象，那么我们就会立刻在对象中产生
     * 我们传入的要查找结点的连通结点数量
     */
    //构建深度优先搜索对象并使用深度优先搜索找出G图中s顶点的所有相邻顶点
    public DepthFirstSearch(Graph G,int s){
        //初始化marked数组,由于该数组索引代表结点的值,因此其长度与结点
        //数量一致,所以此处将无向图的结点数量传入
        this.marked = new boolean[G.V()];
        //初始化跟顶点s相通的顶点数量,默认为0
        this.count=0;
        //this.count=0;
        //调用找出指定顶点所有相邻顶点的方法
        dfs(G,s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相通顶点
    private void dfs(Graph G,int v){
        //先将传入的v顶点标记为已搜索
        marked[v] = true;

        for (Object w:G.adj(v)) {
            //判断当前w顶点有没有被搜索过，若没有被搜索过
            //则递归调用dfs方法进入其子节点中进行深度搜索
            if(!marked[(int) w]){
                dfs(G, (Integer) w);
                //count++;
            }
        }

        /*
         * 代码能执行到此，说明对于起码对于一个相邻结点的判断已经完成了
         * 而且其必然为v的相同顶点，因此相通顶点数量要+1，但说实话我个人
         * 觉得应该要放到if那里才对，然后将初始化的连通数量改为1就行了。
         * 之所以改为1没问题是任何结点都必然和他自己连通，不过放在外面
         * 即使一开始初始化为0最终也没问题，但我觉得不好理解，这里为了
         * 和它的课件保持同步就不做修改了
         */
        //相通顶点数量+1
        count++;
    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w){
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return count;
    }
}

```



广度优先搜索

所谓广度优先搜索，其实和深度优先搜索反过来，如果一个搜索一个结点时既有兄弟结点，又有子节点，那么就先找兄弟结点，再找子节点，请看图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6c514053b1f5eed09859fcd3f2fe9741.png)

同样我们要找0结点的所有相通结点，那么此时按照广度优先搜索的话就先进入记录0结点的队列寻找其子节点6,2,1,5，找完之后进入队列中的子节点中去寻找其结点，此时就是进入6结点的队列寻找0,4,0已经搜索过了因此跳过，然后找到4，接着进入4里寻找.......

其实我们之前学习过的二叉树的层序遍历其实就是利用广度优先搜索进行的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE87490cd5916332db2393376c82dae963.png)

还记得我们之前说过广度优先搜索的特点吗？就是有兄弟结点就先去搜索兄弟结点，之后再去搜索子节点，那么在层序遍历里，我们最开始的E结点只有子节点BG，那么就将BG压入到队列中，然后进入B中寻找，到了B发现B既有子节点AD，又有兄弟结点G，所以先找到B，将子节点AD压入之后，因为队列遵从先进先出原则，因此G先弹出，同样压入FH，由于没有兄弟结点了，所以进入A中寻找，然后又是重复过程。但在这个过程中我们能够明显看到就是我们是先遍历其兄弟结点，接着再遍历其子节点的

那么我们在无向图里实现广度优先搜索的算法时，也可以参照层序遍历



广度优先搜索的实现

同样我们先来看看广度优先搜索的方法的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4ed7bd8854ee4e6203eee5b56f1fb86a.png)

同样，我们这里也创造一个辅助队列用于完成广度优先搜索，那么我们就可以构造代码如下

```javascript
package algorithm.sort;

import java.util.WeakHashMap;

public class BreadthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;
    //用来存储待搜索邻接表的结点的队列
    private Queue<Integer> waitSearch;

    /*
     * 由于我们在构造方法里调用了找出图中所有结点的dfs方法，所以在测试
     * 类里我们一旦创建了深度优先搜索对象，那么我们就会立刻在对象中产生
     * 我们传入的要查找结点的连通结点数量
     */
    //初始化深度优先搜索对象并使用深度优先搜索找出G图中s顶点的所有相邻顶点
    public BreadthFirstSearch(Graph G, int s){
        //初始化marked数组,由于该数组索引代表结点的值,因此其长度与结点
        //数量一致,所以此处将无向图的结点数量传入
        this.marked = new boolean[G.V()];
        //初始化跟顶点s相通的顶点数量,默认为0
        this.count=0;//this.count=0;
        //初始化队列
        this.waitSearch = new Queue<Integer>();
        //调用找出指定顶点所有相邻顶点的方法
        bfs(G,s);
    }

    /*
     * 说实话，我觉得这个方法这样设计其实是没有体现出广度优先搜索的特性的，但是其也能
     * 完成需求，如果要广度优先搜索应该是先对兄弟结点进行遍历再遍历子节点，而这里采用
     * 递归的方式完成，那实际上代码会进入先进入到子节点中遍历，我认为这是不合理的。
     */
    //使用深度优先搜索找出G图中v顶点的所有相通顶点
    private void bfs(Graph G,int v){
        //先将传入的v顶点标记为已搜索
        marked[v] = true;
        //让顶点v压入队列并,此时顶点v处于待搜索状态
        waitSearch.enqueue(v);
        //构建循环，如果队列不为空，则从队列中弹出待搜索元素进行搜索
        while (!waitSearch.isEmpty()){
            //弹出一个待搜索的顶点
            Integer wait = waitSearch.dequeue();
            //遍历wait顶点的邻接表
            for (Object w:G.adj(wait)) {
                if(!marked((Integer) w)){
                    bfs(G, (Integer) w);
                    //count++;
                }
            }
        }

        /*
         * 代码能执行到此，说明对于起码对于一个相邻结点的判断已经完成了
         * 而且其必然为v的相同顶点，因此相通顶点数量要+1，但说实话我个人
         * 觉得应该要放到if那里才对，然后将初始化的连通数量改为1就行了。
         * 之所以改为1没问题是任何结点都必然和他自己连通，不过放在外面
         * 即使一开始初始化为0最终也没问题，但我觉得不好理解，这里为了
         * 和它的课件保持同步就不做修改了
         */
        //相通顶点数量+1
        count++;
    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w){
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return count;
    }
}
```



畅通工程2

那么学习完了图的内容之后，我们接下来来讲一个案例的解决来加深印象，请看题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2561a8949946927a1664a5cf42177ac5.png)

那我们的思路其实很简单，我们先按照题目构建一个对应的图，然后再创建一个搜索对象，接着调用搜索对象里的判断结点之间是否联通的方法就完了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8b571900b21b07fd83560eabf5f1da2a.png)

那么我们可以构建其代码如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE896054c41ffebd228225f28414f5e6ff.png)

没什么特别需要解释的，这个代码，并查集那里已经说过一遍了，我就不多提了



路径查找

上一节里我们实现了无向图的数据结构以及深度优先搜索和广度优先搜索的代码，那么这一节里，我们来实现无向图的路径查找，就是让我们能够在一个指定的无向图里寻找到任意两个结点的一个相通的路径的方法

那么要完成这个需求，我们首先得相出一个表示两个结点间的相对路径的方法

比方说在下图中

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE854f48c0bfb655c5e3bd57b424145f64.png)

如果我们想表示出0到4之间的结点路径，那么我们就可以用0-2-3-4，这样用结点来表示它。这个时候有同学可能会问，但是这个路径不止一条啊，我们要找哪条啊？其实在当前的学习阶段，我们不要求找出最小的那条，只要找出来了就行了，以后学习了加权图时候我们再来讲找出最小路径的方法

接下来我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfbfa583c1ca4109047d17e01515c29c4.png)

那么在API设计中我们的这个edgeTo数组究竟是用来干什么的呢？其实其本身会按照规则存储图中的结点，而我们可以通过这个数组来查找到我们所需要的路径。这样说可能不好理解，请看下图演示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7263c3c4bd4b667943fd1d225a3eff6a.png)

比方说我们这里以0点为起点，那么我们就先搜索0的相邻结点2，搜索到2之后，由于该数组中索引表示对应结点，其值表示对应结点的上一个结点的值，因此我们在该数组的索引2中存储0，0索引什么都不储存，因为0是起点。接着我们再通过2定位到1，在索引1处存入2，此时我们发现0索引处已经遍历过了，因此停止，接着搜索2的子节点3，将索引3处的值改为2

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe5e122da4dd4c22ef41e60797b135df5.png)

接着我们在3中定位到5和4，这里两个步骤一起做，所以索引4,5都存储3。那么到此为止所有的结点都便利完了，这样我们就成功得到了我们想要的数组，我们可以通过这个数组来得到两个任意顶点到起点之间的路径，比方说我们想要找5到起点之间的路径，我们就先定位到数组的索引5，然后发现其上一个结点是3，那么定位到索引3，发现其上一个结点是2，在定位到索引2，发现其上一个结点是0，定位到索引0发现啥也没有，就说明到起点了。那么最终我们就能得到我们的路径，该路径为0-2-3-5

还有就是这里我们是利用深度优先搜索来实现路径查找的，有兴趣的可以自己用广度优先搜索试试

那么根据设计我们可以构造代码如下

```javascript
package algorithm.sort;

public class DepthFirstPaths {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //用值来代表起点
    private int s;
    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点
    private int[] edgeTo;

    //初始化深度优先搜索对象，调用深度优先搜索找出G图中起点为s的所有路径
    public DepthFirstPaths(Graph G,int s){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化起点
        this.s = s;
        //初始化edgeTo数组,长度也为结点数量
        this.edgeTo = new int[G.V()];
        //调用方法找出G图中起点能到达的顶点
        dfs(G,s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相邻顶点
    private void dfs(Graph G,int v){
        //把v表示为已搜索
        marked[v] = true;

        //遍历顶点v的邻接表，拿到每个相邻的顶点，继续递归搜索
        for (Object w:G.adj(v)) {
            //如果顶点w没有被搜索才继续进行递归搜索
            if(!marked[(int) w]){
                edgeTo[(int) w] = v;//将到达w顶点的上一个顶点记录在数组中
                dfs(G, (Integer) w);
            }
        }
    }

    //判断w顶点和s顶点是否存在路径
    public boolean hasPathTo(int v){
        //这里我们直接通过有没有被搜索过来判断其有没有路径，所以代码不用改动
        //这个其实也很好理解，因为只要一被搜索，就说明能从起点到该结点，就说明
        //有路径，如果起点都无法到达该结点，那肯定没有路径啊
        return marked[v];
    }

    //找出从起点s到顶点v的路径(就是该路径经过的顶点)
    public Stack<Integer> pathTo(int v){
        if(!hasPathTo(v)){
            //如果该点与起点不存在路径，那就没必要寻找路径
            return null;
        }
        //创造栈对象用于保存路径中的所有顶点
        Stack<Integer> path = new Stack<>();

        //通过循环，从顶点v开始一直往前找，直到起点为止，此处是从终点往起点遍历
        //这个for循环的构造非常妙，可以的话就记起来
        for (int x = v; x != s; x = edgeTo[x]) {
            //每次循环将x结点的值压栈
            path.push(x);
        }
        //将起点压入栈中，因为遍历到最后我们没有遍历起点
        path.push(s);
        return path;//返回存储路径的栈对象，相当于返回路径
    }
}
```



