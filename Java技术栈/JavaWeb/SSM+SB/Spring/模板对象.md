现在我们来学习我们本章的最后一个内容，也就是模板对象。我们本章节主要讲两个模板对象，分别是JdbcTemplate和RedisTemplate。

- JdbcTemplate

首先，模板是什么呢？简单来说模板就是一个半成品的东西，类似于框架，有了模板我们开发时只需要关注个性化的功能就可以了，而其他的共性功能我们可以不做修改。spring有许多模板对象，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0df5462ced7c2977639210bfe745f390.png)

以后新技术出现了，这个模板也会更新，我们这里就挑几个演示演示，主要让大家知道这是什么玩意，又到底该怎么上手，本身还是一个了解内容，我们快速过一遍。

首先我们要学习的模板是JdbcTemplate，该模板提供了标准的sql语句用于操作API，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8f05cfa6a26b33838e94b90b7d0e40f1.png)

首先来介绍下我们的案例环境，我们这里提供对应的业务层接口和方法，业务层转调数据层，这没什么好说的，提供对应的JDBC的注解获取连接类，这些就不再赘述了，我们接下来讲讲这个项目里的特殊的地方

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc00e69f84809cee2c6544bf2f6ef37c4.png)

我们在JDBCConfig里，不但有将数据源获取到并注入到spring容器中，我们还获得JdbcTemplate的模板对象bean，我们获得的方式很简答，就是直接new，只需要传入一个数据源对象就完了。第二个jdbcTemplate2是具名参数的模板，其也有对应的使用和测试案例，其和前者只有格式上的差别，我们这里就不讲了，有兴趣的自己去课件里去测试

```
//注册JdbcTemplate模块对象bean
@Bean("jdbcTemplate")
public JdbcTemplate getJdbcTemplate(@Autowired DataSource dataSource){
    return new JdbcTemplate(dataSource);
}

@Bean("jdbcTemplate2")
public NamedParameterJdbcTemplate getJdbcTemplate2(@Autowired DataSource dataSource){
    return new NamedParameterJdbcTemplate(dataSource);
}
```

然后我们将该模板类对象jdbcTemplate注入到spring容器中之后，我们就将其注入到我们的数据层实现类中，然后调用其对应的方法。

```
package com.itheima.dao.impl;

import com.itheima.dao.AccountDao;
import com.itheima.domain.Account;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
//dao注册为bean
@Repository("accountDao")
public class AccountDaoImpl implements AccountDao {

    //注入模板对象
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //调用增加方法，只需要传入对应的sql语句，并传入对应的用于查询的值，用于查询的值通过对象传入
    public void save(Account account) {
        String sql = "insert into account(name,money)values(?,?)";
        jdbcTemplate.update(sql,account.getName(),account.getMoney());
    }

    //删除方法同理
    public void delete(Integer id) {
        String sql = "delete from account where id = ?";
        jdbcTemplate.update(sql,id);
    }

    //更新方法同理，注意传入参数的顺序要保持一致
    public void update(Account account) {
        String sql = "update account set name = ? , money = ? where id = ?";
        jdbcTemplate.update(sql, account.getName(),account.getMoney(),account.getId());
    }

    //单个查询方法调用其queryForObject语句，由于其不知道其要给我们的对象是什么好，因此同时要需要传入我们需要其返回的对象
    public String findNameById(Integer id) {
        String sql = "select name from account where id = ? ";
        //单字段查询可以使用专用的查询方法，必须制定查询出的数据类型，例如name为String类型
        return jdbcTemplate.queryForObject(sql,String.class,id );
    }

    //同样是单个查询方法，但是返回值要求是一个账户对象。由于其需要创建一个用户对象并返回给我们，因此其需要一个将数据映射到对应对象的属性的规则
    //因此我们对其进行了映射解析器的设置，最后将该映射解析器传入即可，其就会按照映射解析器的规则将数据映射上去并返回我们所需要的对象
    public Account findById(Integer id) {
        String sql = "select * from account where id = ? ";
        //支持自定义行映射解析器
        RowMapper<Account> rm = new RowMapper<Account>() {
            public Account mapRow(ResultSet rs, int rowNum) throws SQLException {
                Account account = new Account();
                account.setId(rs.getInt("id"));
                account.setName(rs.getString("name"));
                account.setMoney(rs.getDouble("money"));
                return account;
            }
        };
        return jdbcTemplate.queryForObject(sql,rm,id);
    }

    //实际上我们还可以使用spring自带的映射解析器，直接传入想要的进行映射的对象，其就会自动帮我们完成映射规则的配置
    //能使用的前提是我们的对象按照我们的开发标准的顺序进行了属性的放置
    public List<Account> findAll() {
        String sql = "select * from account";
        //使用spring自带的行映射解析器，要求必须是标准封装
        return jdbcTemplate.query(sql,new BeanPropertyRowMapper<Account>(Account.class));
    }

    //同理
    public List<Account> findAll(int pageNum, int preNum) {
        String sql = "select * from account limit ?,?";
        //分页数据通过查询参数赋值
        return jdbcTemplate.query(sql,new BeanPropertyRowMapper<Account>(Account.class),(pageNum-1)*preNum,preNum);
    }

    //同理
    public Long getCount() {
        String sql = "select count(id) from account ";
        //单字段查询可以使用专用的查询方法，必须制定查询出的数据类型，例如数据总量为Long类型
        return jdbcTemplate.queryForObject(sql,Long.class);
    }
}

```

对应的解释都已经写在了注释上了，有需要就自己去看吧，这里就不再赘述了

最后我们拉看看我们测试程序的代码

```
package com.itheima.service;

import com.itheima.config.SpringConfig;
import com.itheima.domain.Account;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

import static org.junit.Assert.*;
//设定spring专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
//设定加载的spring上下文对应的配置
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {
    @Autowired
    private AccountService accountService;

    @Test
    public void testSave() {
        Account account = new Account();
        account.setName("阿尔萨斯");
        account.setMoney(999.99d);
        accountService.save(account);
    }

    @Test
    public void testDelete() {
        accountService.delete(6);
    }

    @Test
    public void testUpdate() {
        Account account = new Account();
        account.setId(7);
        account.setName("itheima");
        account.setMoney(6666666666.66d);
        accountService.update(account);
    }

    @Test
    public void testFindNameById() {
        String name = accountService.findNameById(2);
        System.out.println(name);
    }

    @Test
    public void testFindById() {
        Account account = accountService.findById(2);
        System.out.println(account);
    }

    @Test
    public void testFindAll() {
        List<Account> list = accountService.findAll();
        System.out.println(list);
    }

    @Test
    public void testFindAll1() {
        List<Account> list = accountService.findAll(1, 2);
        System.out.println(list);
    }

    @Test
    public void testGetCount() {
        Long count = accountService.getCount();
        System.out.println(count);
    }
}
```

实际经过测试会发现这些代码都是可以正确使用，就说明的我们的案例已经成功实现了

- RedisTemplate的环境准备

本节的内容其实就是将怎么在java中连接上我们的Reids，我们的Redis因为会被人攻击的问题已经寄了，所以这里就不搞了，我们看看就差不多得了。

这里要解决的问题是需要关闭放在我们Linux中的Redis的保护模式，然后还要绑定对应的ip地址，然后测试下可以成功连接并加入对应的值，那就成功了。

- RedisTemplate

虽然我们花了很多力气将我们的Redis重新设置了一遍且令其终于能被Jedis连接了，但是很不幸的是，由于导入配置的问题，我们仍然无法实际去完成这个案例，尽管我们尝试了许多方法去解决这个问题，但仍然无济于事，只能说我尽力了，这都没法那就实在是没法了，我们接下来直接来讲对应的知识点吧。

首先我们来介绍下我们的案例环境

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa907ce04f057eae415d603d29cccb98d.png)

能注意到我们这里没有dao层，也就是数据层，因为我们的业务代码是直接做到业务层上的。为什么我们这里是直接做到业务层上的，这是因为在redis中，我们的数据不需要进行什么额外的封装，换言之即是数据层本身没什么内容要写了，因此我们这里直接将业务做到我们的业务层上，数据层就给省略掉了。

然后我们来看看我们的RedisConfig配置文件

```
package com.itheima.config;

import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.PropertySource;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.jedis.JedisClientConfiguration;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@PropertySource("redis.properties")
public class RedisConfig {

    @Value("${redis.host}")
    private String hostName;

    @Value("${redis.port}")
    private Integer port;

    @Value("${redis.password}")
    private String password;

    @Value("${redis.maxActive}")
    private Integer maxActive;
    @Value("${redis.minIdle}")
    private Integer minIdle;
    @Value("${redis.maxIdle}")
    private Integer maxIdle;
    @Value("${redis.maxWait}")
    private Integer maxWait;



    @Bean
    //配置RedisTemplate
    public RedisTemplate createRedisTemplate(RedisConnectionFactory redisConnectionFactory){
        //1.创建对象
        RedisTemplate redisTemplate = new RedisTemplate();
        //2.设置连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //3.设置redis生成的key的序列化器，对key编码进行处理
        RedisSerializer stringSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringSerializer);
        redisTemplate.setHashKeySerializer(stringSerializer);
        //4.返回
        return redisTemplate;
    }

    @Bean
    //配置Redis连接工厂
    public RedisConnectionFactory createRedisConnectionFactory(RedisStandaloneConfiguration redisStandaloneConfiguration,GenericObjectPoolConfig genericObjectPoolConfig){
        //1.创建配置构建器，它是基于池的思想管理Jedis连接的
        JedisClientConfiguration.JedisPoolingClientConfigurationBuilder builder = (JedisClientConfiguration.JedisPoolingClientConfigurationBuilder)JedisClientConfiguration.builder();
        //2.设置池的配置信息对象
        builder.poolConfig(genericObjectPoolConfig);
        //3.创建Jedis连接工厂
        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(redisStandaloneConfiguration,builder.build());
        //4.返回
        return jedisConnectionFactory;
    }

    @Bean
    //配置spring提供的Redis连接池信息
    public GenericObjectPoolConfig createGenericObjectPoolConfig(){
        //1.创建Jedis连接池的配置对象
        GenericObjectPoolConfig genericObjectPoolConfig = new GenericObjectPoolConfig();
        //2.设置连接池信息
        genericObjectPoolConfig.setMaxTotal(maxActive);
        genericObjectPoolConfig.setMinIdle(minIdle);
        genericObjectPoolConfig.setMaxIdle(maxIdle);
        genericObjectPoolConfig.setMaxWaitMillis(maxWait);
        //3.返回
        return genericObjectPoolConfig;
    }


    @Bean
    //配置Redis标准连接配置对象
    public RedisStandaloneConfiguration createRedisStandaloneConfiguration(){
        //1.创建Redis服务器配置信息对象
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        //2.设置Redis服务器地址，端口和密码（如果有密码的话）
        redisStandaloneConfiguration.setHostName(hostName);
        redisStandaloneConfiguration.setPort(port);
//        redisStandaloneConfiguration.setPassword(RedisPassword.of(password));
        //3.返回
        return redisStandaloneConfiguration;
    }

}
```

我们这里搞这么多@Bean都是为了给我们的创建对应的redisTemplate注入其所需的对象，这里就不一一解释了。最后值得一提的是，其实我们可以用其对应的Factory工厂对象来简化我们的代码，不过我们这样做也是可以的。

不要忘记了，我们同时还要提供对应的properties文件用于提供对应的设置数据

```
# redis服务器主机地址
redis.host=175.178.114.158
#redis服务器主机端口
redis.port=6379

#redis服务器登录密码
#redis.password=feigeA.5200....

#最大活动连接
redis.maxActive=20
#最大空闲连接
redis.maxIdle=10
#最小空闲连接
redis.minIdle=0
#最大等待时间
redis.maxWait=-1
```

然后我们就在讲其下所有的方法了，我们通过图片来演示吧，代码上的演示就不做了，我们只要知道其在代码上可以调用这些对应的方法就可以了。

首先我们的RedisTemplate对象结构内部提供了四个操作，分别是客户端基本操作、*Operations、Bound*Operations、以及其他操作。

我们先来看看客户端基本操作都有什么方法，其下的方法大多是做一些改动或者得到某些信息

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3f6b9e46f35163248c0bbb2a55a37a72.png)

而*Operations则可以得到我们的具体的数据结构的设置方法，在其后在可以继续通过点的形式来调用对应的数据结构内部的方法进行数据的设置

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdead10fe3e8cd80d33ba25f0d13d7f21.png)

剩下两个自己看吧，本身就用得少，了解下就得了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa4d9375acf3400477ff4a0b2994e70d9.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8503acbaefdf15b5c687e8560b7cf17f.png)

看完了上面的图之后，我们也容易知道其实我们的redisTemplate就是一个比较方便的工具类，我们可以利用快捷地做到通过java程序连接我们的Linux中的Redis，从而实现对数据的修改

那么我们就可以在对应的业务层中写入其对应的设置代码如下

```
package com.itheima.service.impl;


import com.itheima.domain.Account;
import com.itheima.service.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private RedisTemplate redisTemplate;

    public void save(Account account) {
    }

    public void changeMoney(Integer id, Double money) {
        //等同于redis中set account:id:1 100
        redisTemplate.opsForValue().set("account:id:"+id,money);
    }

    public Double findMondyById(Integer id) {
        //等同于redis中get account:id:1
        Object money = redisTemplate.opsForValue().get("account:id:" + id);
        return new Double(money.toString());
    }
}
//        redisTemplate.type()
//        redisTemplate.persist()
//        redisTemplate.move()
//        redisTemplate.hasKey()
//        redisTemplate.getExpire()
//        redisTemplate.expire()
//        redisTemplate.delete()
//        redisTemplate.rename();
//
//        redisTemplate.opsForValue().;
//        redisTemplate.opsForHash().;
//        redisTemplate.opsForList().;
//        redisTemplate.opsForSet().;
//        redisTemplate.opsForZSet();
//
//
//        redisTemplate.boundValueOps().;
//
//        redisTemplate.slaveOf();
//        redisTemplate.slaveOfNoOne();
//
//        redisTemplate.opsForCluster()
```

在这里我们试下了最基本的设置set数据和查找set数据的业务代码，然后我们写入测试代码如下

```
package com.itheima.service;

import com.itheima.config.SpringConfig;
import com.itheima.domain.Account;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import redis.clients.jedis.Jedis;

import java.util.List;

import static org.junit.Assert.*;
//设定spring专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
//设定加载的spring上下文对应的配置
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {
    @Autowired
    private AccountService accountService;

    @Test
    public void test(){
        Jedis jedis = new Jedis("175.178.114.158",6379);
        jedis.set("name","itheima");
        jedis.close();
    }

    @Test
    public void save(){
        Account account = new Account();
        account.setName("Jock");
        account.setMoney(666.66);

    }

    @Test
    public void changeMoney() {
        accountService.changeMoney(1,200D);
    }

    @Test
    public void findMondyById() {
        Double money = accountService.findMondyById(1);
        System.out.println(money);
    }
}
```

接着我们运行对应的代码，可以看到我们的用例的确成功了。那么就说明我们的案例完成了

- 设计模式

策略模式有很多种，我们可以使用不同的策略对象来实现不同的行为方式。比如在说在我们的第一个JdbcTemplate模板中，我们可以使用自定义的映射解析器，也可以使用spring自带的映射解析器，这两种方式就是两种策略。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEddbbe03bf12cc738bd4a2b2fd4f4a828.png)

再比如我们的传参中，我们要不要使用具名参数也是一种策略

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEac4b5c571985a7129a01f48f215e6a9d.png)

在后面的springMVC的学习中，我们还会讲解更多的策略模式，这里我们先了解下。