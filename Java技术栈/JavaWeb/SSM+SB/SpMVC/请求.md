本章节我们来学习springmvc的请求的内容，首先我们要学习的是在springmvc中如果要接收传入过来的参数我们应该怎么做

- 普通类型参数传参

首先我们来学习普通类型的参数传参的接收方法，如果我们想要接受对应的参数的话，只需要在对应方法内填入对应的传入参数，然后指定用户在地址栏里传入的参数名为当前的方法的参数的传入名即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE690e5b1a68a8bc42cb82d57e5f7cda35.png)

那么我们可以构造其代码如下

```
//方法传递普通类型参数，数量任意，类型必须匹配
//http://localhost/requestParam1?name=itheima
//http://localhost/requestParam1?name=itheima&age=14
@RequestMapping("/requestParam1")
public String requestParam1(String name,int age){
    System.out.println(name+","+age);
    return "page.jsp";
}
```

最上面还有该处理类的类名和设置其为spring的控制类的注解，这里为了版面省略掉了。

如果我们希望我们的参数即使在用户传入的参数名不同的情况下，我们设置的参数名仍然能正确获得对应的值，此时就可以使用RequestParam注解来完成目的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd9408778fe5b6f96e19452e21740317b.png)

那么我们根据上图，可以将我们的代码改造如下

```
@RequestMapping("/requestParam1")
public String requestParam1(@RequestParam(value = "userName",required = true) String name, int age){
    System.out.println(name+","+age);
    return "page.jsp";
}
```

这里我们在对应的参数参数中使用@RequestParam参数，我们可以设置value值为我们另外指定的参数名字，这样我们的名字即使不同，只要其和我们指定的另一个名字相同，其也会正确赋值，同时其下还有一个require值，该值默认为真，为真时则说明该参数不能为空，否则就报错

- POJO类型参数传参

所谓POJO类型参数，其实就是引用类型参数。我们要传入引用类型的参数的方式也很简单，我们只需要创建对应的实体类，当然我们的参数顺序要保持一致，然后传入给类就完了，当用户往里面传入指定的数据其会自动将这些数据封装成一个数据对象，我们只需要打印该对象即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4cdc1e43f16215c989928182c7c9ab92.png)

那么我们可以写入其代码如下

```
//方法传递POJO类型参数，URL地址中的参数作为POJO的属性直接传入对象
//http://localhost/requestParam3?name=Jock&age=39
@RequestMapping("/requestParam3")
public String requestParam3(User user){
    System.out.println(user);
    return "page.jsp";
}
```

利用该代码传入对应的参数就可以直接接收到我们所需要的User的数据对象了。

然后值得一提的是，如果我们的参数发生了冲突，即是当我们的传入参数中又有对应的属性同时有对应的引用数据类型且他们还重名的时候，引用数据类型和其他同名属性将会被同时赋值

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0f2b14bd43c74fd1cba45f01e758d2c5.png)

具体的解决方法就是使用RequestParam注解来进行区分，这种情况一般比较少出现，而即使出现了，一般也能通过对应的注解来进行解决

还有一种情况是当我们的POJO类型参数为复杂POJO类型参数时的处理，也就是当我们的POJO类型参数中还引用了其他的POJO类型参数时我们的赋值方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6203def9d6c6a457a17e8dd2f400b028.png)

其实这个也很简单，在传值只需要直接通过给其对应的POJO类型参数通过.的形式进行赋值就可以了，原类型中的引用数据类型里的成员变量需要通过.的形式（也就是Address），而第一个引用数据类型的变量则不需要（也就是User），直接传就完了

```
//使用对象属性名.属性名的对象层次结构可以为POJO中的POJO类型参数属性赋值
//http://localhost/requestParam5?address.city=beijing
@RequestMapping("/requestParam5")
public String requestParam5(User user){
    System.out.println(user.getAddress().getCity());
    return "page.jsp";
}
```

当然，这里不能忘了，我们对应的实体类里也要做对应的修改，比如我们应该要新创建一个地址类并将该地址类成为用户类的一个成员变量，并且要提供对应的构造方法和set和get方法（这个后续就不再赘述了）

接着我们来演示POJO类型参数的集合形式，这个最简单的应用场景就在于一个人可能有多个外号，我们可以用一个集合去承载这些外号，对应的修改就是我们可以在对应的类中添加一个List保存字符串的集合，然后传值时这个值可以承载其所有的其他名字就可以了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2c2b4109922257515d079a2bbd84068c.png)

那么我们可以写入其代码如下

```
//通过URL地址中同名参数，可以为POJO中的集合属性进行赋值，集合属性要求保存简单数据
//http://localhost/requestParam6?nick=Jock1&nick=Jockme&nick=zahc
@RequestMapping("/requestParam6")
public String requestParam6(User user){
    System.out.println(user);
    return "page.jsp";
}
```

上面的代码里，我们打印之后会发现User其他的类型都是默认的初始值，但只有代表list集合的nick，是有我们插入的值的

接着我们还要讲另外一种集合形式，就是我们的集合内部本身可能是存放另一个POJO类型参数的，最简单的例子是外卖送餐时，可能要存放多个地址，此时一个外卖员下就应该一个存放地址的集合，其集合内有多个要送餐的人员的地址。此时我们需要对该集合进行赋值，就要使用对应的坐标.的形式来进行赋值，具体请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5fa8f8e3ce34559a330398940737a22d.png)

那么根据上图，我们可以构造我们的代码如下

```
//POJO中List对象保存POJO的对象属性赋值，使用[数字]的格式指定为集合中第几个对象的属性赋值
//http://localhost/requestParam7?addresses[0].city=beijing&addresses[1].province=hebei
@RequestMapping("/requestParam7")
public String requestParam7(User user){
    System.out.println(user.getAddresses());
    return "page.jsp";
}
```

最后还有一个Map集合的传入方式，使用该方式可以保证我们的输入对应的地址名就可以得到我们需要的具体地址，比如说输入home就只要家庭的地址。那么需要对其进行传值的话，我们修改的方式也就只是将[0]里的内容改为对应的字符串罢了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa1c9a3a08f1e50604c39fe160987d2d3.png)

那么我们可以构造其代码如下

```
//POJO中Map对象保存POJO的对象属性赋值，使用[key]的格式指定为Map中的对象属性赋值
//http://localhost/requestParam8?addressMap['job'].city=beijing&addressMap['home'].province=henan
@RequestMapping("/requestParam8")
public String requestParam8(User user){
    System.out.println(user.getAddressMap());
    return "page.jsp";
}
```

- 数组与集合类型传参

如果我们要给数组类型参数传参，那么我们就只需要传入一个数组类型就可以了，地址栏上就用类似于集合的方式继续传就可以了，同时我们这里不需要在对象中特别声明一个成员变量

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe3586be42c2c8bdf866c4a62b2471de7.png)

那么我们可以构造其代码如下

```
//方法传递普通类型的数组参数，URL地址中使用同名变量为数组赋值
//http://localhost/requestParam9?nick=Jockme&nick=zahc
@RequestMapping("/requestParam9")
public String requestParam9(String[] nick){
    System.out.println(nick[0]+","+nick[1]);
    return "page.jsp";
}
```

接着我们要将集合类型参数的内容，如果我们往参数里传入一个集合参数内容，如果我们传入的是接口，那么其报初始化错误，如果传入的是集合的实现类，那么就无法得到任何结果。之所以会如此是因为springMVC是默认将集合当做对象的属性处理的，因此其会先创建属性对象，因为接口无法创建对象，所以会报初始化异常。其次是我们传入实现类时即使不报出初始化异常，然而其仍然会将集合当做对象的属性进行处理，进行一个赋值操作，然而我们这里没有对应的属性，因此什么都不会有。如果我们希望告知springmvc我们现在要处理的内容是数据而不是属性，就需要使用@RequestParam注解并指定其名字为我们的传入参数名，此时其会通过该注解将大于一个的参数打包成参数数组给springMVC识别，然后springmvc才能做对应的相关动作

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd749e1bf26e696661909f7f7c02c04c8.png)

那么我们可以构造其代码如下

```
//方法传递保存普通类型的List集合时，无法直接为其赋值，需要使用@RequestParam参数对参数名称进行转换
//http://localhost/requestParam10?nick=Jockme&nick=zahc
@RequestMapping("/requestParam10")
public String requestParam10(@RequestParam("nick") List<String> nick){
    System.out.println(nick);
    return "page.jsp";
}
```

- 类型转换器

本节我们来讲解我们的类型转换器，回顾我们的上一节内容，我们有说我们要给我们的指定的格式传入指定的内容，如果我们传入的内容是不合乎规范的，比如往int类型里传字符串，那么就会报出类型转换异常。实际上内部的众多的类型转换的工作，是由springMVC中的Converter接口来帮助实现的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE85bcfa856cc275380c48c26dc6fcb2a0.png)

其下有许多转换器的实现类，这个我们知道就可以了。

假设我们现在要使用Date的数据类型，那么我们可以写入其代码如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd7fbdd72ce58a9e9c6b9b81bbd52123c.png)

然而使用这一份代码，我们就只能按照其规定的格式输入日期，否则会报类型转换异常。规定的格式就是使用/来进行对日期字符串的分割，实际上我们还可以用自己定义的转换类来进行对某一个对应的类型的转换，我们要实现这个目的，就要到springmvc的配置文件中去，写入代码如下

```
<mvc:annotation-driven conversion-service="conversionService" />

<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
    <property name="formatters">
        <set>
            <bean class="org.springframework.format.datetime.DateFormatter">
                <property name="pattern" value="yyyy-MM-dd"/>
            </bean>
        </set>
    </property>
</bean>
```

我们这里指定了对应的工厂对应然后给其日期格式转换的属性赋值，赋值要采用set标签，因此我们使用set标签，赋值需要一个对应的日期转换类，因此我们在其下再使用bean标签生成一个日期转换类，然后给对应的日期转换类下的属性赋值，其实就是指定其格式。其他的还有许许多多的属性可以赋值，但是我们这里不做改动，好让他能按照默认值以继续使用。然后在上面开启注解驱动，使用我们的自定义的类型转换器，其名称就是我们下面的所指定的id

不过值得一提的是，一旦我们使用了自己定义的格式，那么之前的/的格式就不能再使用了，使用的话同样会报类型转换异常。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE624927926a00455b49bcbcbba00f8642.png)



![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6cd0bfc1b5d3ca63de31b526a384c288.png)

当然，每次使用这种方式来进行日期格式的转换也太麻烦了，我们可以使用注解来让这件事情变得简单，这个注解就是@DateTimeFormat，在对应的date传入参数前直接接上这个注解然后在括号内指定其日期格式就可以了，具体的格式如下图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd9babc765e56b491d243ab44f541337e.png)

但是需要在配置文件里开启注解驱动支持，这一点不要忘了，最后我们可以写入其代码如下

```
//数据类型转换，使用自定义格式化器或@DateTimeFormat注解设定日期格式
//两种方式都依赖springmvc的注解启动才能运行
//http://localhost/requestParam11?date=1999-09-09
@RequestMapping("/requestParam11")
public String requestParam11(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){
    System.out.println(date);
    return "page.jsp";
}
```

其效果和我们之前是一模一样的，以后我们使用这个就可以了，之前配置文件的就不用使用了，那些是原理性的东西来的，我们了解就好。

- 自定义类型转换器

本节我们来学习如何自定义类型转换器，我们仍然是以日期类型转换器来举例，同时本节内容只做了解，并非我们学习的重点。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE72530fe511c6ae1ca25a0c694c89956e.png)

首先我们要创建一个实现类，令其继承Converter接口，该接口使用泛型，左边是传入的数据类型，右边是要转换的数据类型，我们在里面做的处理是通过调用其他的方法令其转换为我们想要的日期格式，注意这里我们绝不可将异常抛出，必须自己处理，这是我们的规范，因为我们的类型转换器是不监控异常也不处理的，因此有异常我们要自己处理

那么我们可以写入其代码如下

```
package com.itheima.converter;



import org.springframework.core.convert.converter.Converter;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter<String,Date>{


    @Override
    public Date convert(String source) {
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        Date date = null;
        try {
            date = df.parse(source);
        }catch (ParseException e){
            e.printStackTrace();
        }
        return date;
    }
}

```

然后我们要对我们的自定义转换器进行一个注册，这个过程其实和我们上一节的差不多这里就不赘述了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEad2002be7122f5dd0885a1b46a353e31.png)

具体的代码如下图所示

```
<mvc:annotation-driven conversion-service="conversionService"/>
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <set>
            <bean class="com.itheima.converter.MyDateConverter"/>
        </set>
    </property>
</bean>
```

最后我们经过测试会发现我们的自定义转换器类是可以正常工作的，是没有问题的

- 请求映射

最后我们来讲讲我们一开始最先使用的RequestMapping的映射注解，我们目前位置都是将其使用在我们的方法上，但实际上，这个注解还可以用于类上

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5d34aab8d318174d40c206b5bc89bb09.png)

但是这里值得注意的是如果我们用于类上的话，那么我们都在访问对应的映射路径时，要在访问路径上先加上对应的类注解上写入的路径。同时我们的页面，也就是jsp文件，也要放在对应的文件夹下，具体表现在我们需要在web目录下新创建一个类注解上指定的路径的包，然后将页面放到里面，然后其才能通过对应的字符串寻找到对应的响应页面

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe3fa979a5f548a902b4833090e9ac416.png)

最后值得一提的是，如果我们的方法路径上不加/的话，那么其仍然是从根路径下开始访问的，而不是从我们类中的文件夹开始访问的

