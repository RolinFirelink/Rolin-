本文档存放了学习数据结构里我们构造的代码，都放这里了，便于我们以后要用的时候的查找



加权有向图

```javascript
package algorithm.sort;

public class EdgeWeightedDigraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<DirectedEdge>[] adj;

    //创建一个含有V个顶点的空加权有向图
    public EdgeWeightedDigraph(int V){
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<DirectedEdge>();
        }
    }

    //获取图中顶点的数量
    public int V() {
        return V;
    }

    //获取图中边的数量
    public int E() {
        return E;
    }

    //向加权有向图中添加一条边e
    public void addEdge(DirectedEdge e) {
        //边e是有方向的，因此不能两个结点都添加权值
        //我们将权值只添加到起点，表示边的权值同时表示方向
        int v = e.from();//获取起点
        adj[v].enqueue(e);//在对应结点的邻接表上添加权值
        E++;
    }

    //获取由顶点v指出的所有边
    public Queue<DirectedEdge> adj(int v) {
        return adj[v];
    }

    //获取加权有向图的所有边
    public Queue<DirectedEdge> edges() {
        //遍历图中的每一个顶点，再遍历其中的邻接表，将其添加到队列中，最后队列中会含有图的所有边
        Queue<DirectedEdge> allEdges = new Queue<>();
        for (int v = 0; v < V; v++) {
            for (Object edge: adj[v]) {
                allEdges.enqueue((DirectedEdge) edge);
            }
        }
        return allEdges;
    }
}
```





Dijkstra算法

```javascript
package algorithm.sort;

public class DijkstraSP {
    //索引代表顶点，值表示从根结点s到当前结点的最短路径上的最后一条边
    private DirectedEdge[] edgeTo;
    //索引代表顶点，值表示从根结点s到当前结点的最短路径的总权重
    private double[] distTo;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权有向图G和根结点s，创造一个计算根结点s的最短路径树对象
    public DijkstraSP(EdgeWeightedDigraph G,int s){
        //初始化edgeTo
        this.edgeTo = new DirectedEdge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化pq
        this.pq = new IndexMinPriorityQueue<>(G.V());

        //全部初始化完毕之后要执行查找以根结点s为起点的最短路径树

        //默认以顶点s进入到最短路径树中
        distTo[s] = 0.0;//起点到起点没有边，因此赋值0.0，代表没有权值
        pq.insert(s,0.0);

        //遍历pq，给全部结点进行松弛
        while (!pq.isEmpty()){
            relax(G,pq.delMin());
        }
    }

    //松弛图G的顶点v
    private void relax(EdgeWeightedDigraph G,int v){

        for (Object edge:G.adj(v)) {
            //获取到该边的终点w
            int w = ((DirectedEdge)edge).to();
            //如果指定顶点的总权重与边权重之和小于当前记录的到该结点的最小权重
            if(distTo(v)+((DirectedEdge) edge).weight()<distTo(w)){
                //则更新对应顶点的最小权重和的数据以及到该顶点的最小权重边
                distTo[w] = distTo[v]+((DirectedEdge) edge).weight();
                edgeTo[w] = (DirectedEdge) edge;

                //判断pq中是否已经存在另一个结点w
                if(pq.contains(w)){
                    //若存在则更新其当前最小路径树的有效横切边的数据，其现实动作可以理解为
                    //改变了该横切边，使该横切边变成总权重更小的横切边
                    pq.changeItem(w,distTo(w));
                }else {
                    //若不存在则直接将点和该最小横切边插入
                    pq.insert(w,distTo(w));
                }
            }
        }
    }

    //获取从顶点s到顶点v的最短路径的总权重
    public double distTo(int v){
        return distTo[v];
    }

    //判断从顶点s到顶点v是否可达
    public boolean hasPathTo(int v){
        return distTo[v]<Double.POSITIVE_INFINITY;
    }

    //查询从起点s到顶点v的最短路径中所有的边
    public Queue<DirectedEdge> pathTo(int v){
        //判断从顶点s到顶点v是否可达，如果不可达，直接返回null
        if(!hasPathTo(v)){
            return null;
        }
        //创建队列对象
        Queue<DirectedEdge> allEdges = new Queue<>();

        while (true){
            DirectedEdge e = edgeTo[v];
            //当e为起点时，没有任何边指向它，其edgeTo里存放的值是null
            //因此当我们的e为null时，说明已经到了根结点
            if(e==null){
                break;
            }
            allEdges.enqueue(e);

            v = e.from();
        }
        return allEdges;
    }
}

```



加权有向边

```javascript
package algorithm.sort;

public class DirectedEdge {
    private final int v;//起点
    private final int w;//终点
    private final double weight;//当前边的权重

    //通过顶点v和w，以及权重weight值构造一个边对象
    public DirectedEdge(int v,int w,double weight){
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取有向边的起点
    public int from(){
        return v;
    }

    //获取有向边的终点
    public int to(){
        return w;
    }
}
```



最小生成树kruskal算法

```javascript
package algorithm.sort;

public class KruskalMST {
    //保存最小生成树的所有边
    private Queue<Edge> mst;
    //索引代表顶点，使用uf.connect(v,w)来判断两结点是否在同一棵树中
    //若不在则调用uf.union(v,w)将顶点v所在的树与w所在的树合并
    private UF_Tree_Weighted uf;
    //存储图中所有的边，使用最小优先队列，按照权重进行排序
    private MinPriorityQueue<Edge> pq;

    //根据一副加权无向图，创造最小生成树计算对象
    public KruskalMST(EdgeWeightedGraph G){
        //初始化mst
        this.mst = new Queue<Edge>();
        //初始化uf,由于uf存储的是边，因此这里指定的大小是无向图中边的数量
        this.uf = new UF_Tree_Weighted(G.V());
        //初始化pq,注意我们的最小优先队列是利用堆实现的，而堆中是把数组的第一个位置舍弃不用了
        //因此理论上我们应该要在指定的空间上+1的，但是这里不加也可以，因为我们最小优先队列的
        //源码里就已经先进行过+1的操作了
        this.pq = new MinPriorityQueue<>(G.E());
        //将图中的所有边存储到pq中,这里的添加操作也是后续while能够持续运作的前提
        for (Object e:G.edges()) {
            pq.insert((Edge) e);
        }

        //遍历pq队列，每次拿到权重最小的边并进行添加动作

        //pq不为空时继续循环很好理解，但是为什么这里要求mst存放的最小生成树的边不大于其结点数
        //-1呢？这是因为对于任何一个加权无向图而言，如果其有最小生成树，那么其最小生成树的边的
        //数量就正好等于其结点的数量-1，因此这里加上这个条件，可以提高我们程序的运行效率，避免
        //重复无意义的运算
        while (!pq.isEmpty()&&mst.size()<G.V()-1){
            //找到权重最小的边
            Edge e = pq.delMin();
            //找到改变的两个顶点
            int v = e.either();
            int w = e.other(v);

            //若两个顶点已经在同一个树中则跳过添加动作
            if (uf.connect(v,w)){
                continue;
            }

            //代码执行到此说明两顶点不在同一颗树中，执行添加动作
            uf.union(v,w);//执行将两棵树合并的动作

            //令添加的边e进入到mst的队列中
            mst.enqueue(e);
        }
    }

    //获取最小生成树的所有边
    public Queue<Edge> edges() {
        return mst;
    }
}

```





最小生成树prim算法

```javascript
package algorithm.sort;

public class PrimMST {
    //索引代表顶点，值表示当前顶点和最小生成树的最短边
    //该成员变量有后面用于获取最小生成树的重要作用
    private Edge[] edgeTo;
    //索引代表顶点，值表示当前顶点和最小生成树的最短边的权重
    private double[] distTo;
    //索引代表顶点，如果当前顶点已在最小生成树中则标记为true，反之则为false
    private boolean[] marked;
    //存放树中顶点与非树中顶点的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权无向图，创造最小生成树创建计算对象(构造方法)
    public PrimMST(EdgeWeightedGraph G){
        //初始化edgeTo
        this.edgeTo = new Edge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            //赋予结点的权值为最大，便于后面不断去更新最小的权值
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化marked，成员变量默认全部赋值为false
        this.marked = new boolean[G.V()];
        //初始化pq
        pq = new IndexMinPriorityQueue<Double>(G.V());

        //默认让0进入到最小生成树中，此时0结点不关联任何边，因此其权值赋值为0.0
        distTo[0]=0.0;
        pq.insert(0,0.0);
        /*
         * 遍历索引最小优先队列,拿到最小横切边对应的顶点并将该顶点加入到最小生成树中
         * 这里调用delMin()方法会自动删除最小的索引并且返回被删除的索引，而索引代表
         * 结点，因此visit();方法这样构造代码可以理解为队列里执行了出队列的动作，并
         * 且同时将弹出的元素，也就是结点，和我们要寻找最小生成树的加权无向图一并传给
         * 了visit方法
         */
        while (!pq.isEmpty()){
            visit(G, pq.delMin());
        }
    }

    /*
     * 这里上面构建了while循环所以可以重复调用visit方法，每调用一次就会从队列中删除掉最小的结点
     * 但是在visit方法中，又会往pq中添加最小生成树的对应点和横切边，因此其能够实现不断调用，最后
     * 成功生成了最小生成子树时，不断调用visit方法的结果都不会再执行往pq中增添新结点和新边的代码
     * 最后其能够成功结束这个循环，然后此时保存在edgeTo中的边就是我们所需要的最小生成树的边，索引
     * 代表对应的结点
     */
    //将顶点v添加到最小生成树中，并且更新数据
    private void visit(EdgeWeightedGraph G,int v){
        //将该顶点标记为已加入最小生成树中的状态
        marked[v] = true;
        //将该顶点加入最小生成树，此处的e表示是对应的v结点的边，随着遍历的进行，其所代表的边也在不断变化
        for (Object e: G.adj(v)) {
            //获取e边上的另外一个顶点w(当前顶点是v)
            int w = ((Edge)e).other(v);
            //判断另外一个顶点是否已经在树中，若已经在树中则跳过添加
            if(marked[w]){
                continue;
            }
            //代码执行到此说明不在树中
            //判断边e的权重是否小于从w顶点到树中已经存在的最短边的权重，之所以用w，是因为这里的w就是
            //e边所对应的结点，对于第一次添加的结点而言distTo[w]自然是最大的，但是如果是第二次添加
            //就可能存在distTo[w]比起更大或更小的情况，这里你如果更小，那么就说明有必要更新最小权值
            //以及最小边
            if(((Edge) e).weight()<distTo[w]){
                //小于则更新最短边为该边
                edgeTo[w] = (Edge) e;
                //更新最小权值为该权值
                distTo[w] = ((Edge) e).weight();
                //判断pq中是否已经存放了该点的横切边
                if(pq.contains(w)){
                    //若已经存放则改变对应横切边的权值
                    pq.changeItem(w,((Edge) e).weight());
                }else {
                    //没有则添加新点到pq中
                    pq.insert(w,((Edge) e).weight());
                }
            }
        }
    }

    //获取最小生成树的所有边
    public Queue<Edge> edges() {
        //创建队列对象
        Queue<Edge> allEdges = new Queue<>();
        //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中，edgeTo里存放的是edge对象
        //是程序员自己定义的对象，如果没有赋值的话，调用构造方法时默认赋值为null，因此我们这里可以
        //采用这种方式进行边的添加
        for (int i = 0; i < edgeTo.length; i++) {
            if(edgeTo[i]!=null){
                allEdges.enqueue(edgeTo[i]);
            }
        }
        return allEdges;
    }
}

```



加权无向图

```javascript
package algorithm.sort;

public class EdgeWeightedGraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表，这里存储的对象是Edge，这里邻接表内不再存储另一个结点的值，而是存储边的权重
    //同样的，相同的权重也会出现在边所连接的两个顶点上
    private Queue<Edge>[] adj;

    //创造一个含有V个顶点的空加权无向图
    public EdgeWeightedGraph(int V){
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Edge>();
        }
    }

    //获取图中顶点的数量
    public int V() {
        return V;
    }

    //获取图中边的数量
    public int E() {
        return E;
    }

    /*
     * 这里我们创造加权无向边的方式是先创建Edge对象边，一条边里有两个结点
     * 然后在这个方法里获取到这两个结点，再将这两个结点分别加入到其邻接表
     * 中，相当于我们是先创建了两个结点和属性，然后这里是将结点连起来并
     * 赋予其属性值
     */
    //向加权无向图中添加一条边e
    public void addEdge(Edge e) {
        //加权无向图还是无向图，因此添加方式区别不大
        int v = e.either();//获得一个点
        int w = e.other(v);//获得另一个点

        adj[v].enqueue(e);
        adj[w].enqueue(e);

        //边的数量+1
        E++;
    }

    //获取和顶点v关联的所有边
    public Queue<Edge> adj(int v) {
        return adj[v];
    }

    /*
     * 此处我们令边只添加一次的方法是比较两个结点的值，如果一个结点值小于另一个则添加
     * 如果不小于则不添加。这个方法的实现前提是每一个结点的值都必不相同且按照顺序递增
     * 我猜测我们这里把<改成>也是可以实现我们的需求的
     */
    //获取加权无向图的所有边
    public Queue<Edge> edges() {
        //创建一个队列对象用于存储所有加权边
        Queue<Edge> allEdges = new Queue<>();

        //遍历图中每一个顶点的邻接表，每一个顶点的邻接表中存储了该顶点关联的每一条边
        //因为这是无向图，所以同一条边会出现在它关联的两个顶点中，而我们只需要让一条
        //边记录一次就可以了
        for (int v = 0; v < V; v++) {
            //遍历v顶点的邻接表，找到每一条和v关联的边
            for (Object e: adj(v)) {
                Edge E = (Edge) e;
                if(E.other(v)<v){
                    allEdges.enqueue(E);
                }
            }
        }
        return allEdges;
    }
}

```



加权边

```javascript
package algorithm.sort;
//加权边需要比较，因此要实现Comparable接口并提供比较方法
public class Edge implements Comparable<Edge>{
    private final int v;//顶点一
    private final int w;//顶点二
    private final double weight;//当前边的权重

    //通过顶点v和w以及权重weight构造一个边对象(构造方法)
    public Edge(int v,int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight(){
        return weight;
    }

    //获取边上的一个点
    public int either(){
        return v;
    }

    //获取边上除了顶点vertex外的另外一个顶点
    public int other(int vertex){
        //如果是v顶点则返回w，不是则返回v
        if(vertex==v){
            return w;
        }else {
            return v;
        }
    }

    //重写父类方法提供比较规则
    @Override
    public int compareTo(Edge that) {
        int cmp;//记录比较的结果
        if(this.weight()>that.weight()){
            //如果当前边的权重大，则让cmp=1
            cmp = 1;
        }else if(this.weight()<that.weight()){
            //如果当前边的权重大，则让cmp=-1
            cmp = -1;
        }else {
            //一样大则令cmp=0
            cmp = 0;
        }
        return cmp;
    }
}

```



判断有向图是否有环

```javascript
package algorithm.sort;

public class DirectedCycle {
    //索引代表顶点，值代表当前顶点是否已经被搜索
    private boolean[] marked;
    //记录图中是否有环
    private boolean hasCycle;
    //索引代表顶点，使用栈的思想，记录当前顶点是否已经处于正在搜索的有向路径上
    private boolean[] onStack;

    /*
     * 这里之所以要传入每一个顶点作为入口是因为我们的有向图可能是一个非联通图
     * 此时不传入所有顶点作为入口查找的话可能会查找不到有向环，而每次都要进行
     * 当前顶点是否已经被搜索的判断是为了避免重复搜索的情况，可以提升我们的程
     * 序的运行效率
     */
    //创建一个检测环对象，检测图G中是否有环
    public DirectedCycle(Digraph G){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化hasCycle
        this.hasCycle = false;
        //初始化onStack数组
        this.onStack = new boolean[G.V()];

        //找到图中每一个顶点，让每一个顶点都作为入口调用dfs方法进行搜索
        for (int v = 0; v < G.V(); v++) {
            //如果当前顶点没有被搜索过则调用dfs进行搜索
            if(!marked[v]){
                dfs(G,v);
            }
        }
    }

    /*
     * 这个方法我不理解的是为什么最后要将顶点出栈，在我的演示里我认为即使不出栈
     * 也是没有任何问题的，但是在视频里又没有测试环节，所以我也不能够测试最后的
     * 这个出栈代码有什么必要性，所以先这样的，以后时间我自己再构造测试代码试试
     */
    //利用深度优先搜索检测图G中是否有环
    private void dfs(Digraph G, int v){
        //把顶点v标记为已搜索
        marked[v] = true;
        //把当前顶点进栈
        onStack[v] = true;
        //进行深度搜索
        for (Object w: G.adj(v)) {
            //若当前顶点w没有被搜索过，则递归调用dfs方法进行深度优先搜索
            if(!marked[(int) w]){
                dfs(G, (Integer) w);
            }

            //若当前顶点已经在栈中，证明之前已经搜索过了，现在又要再搜索一次，说明有环
            if(onStack[(int) w]){
                hasCycle = true;
                return;//检测到环就立刻结束方法
            }
        }
        //把当前顶点出栈
        onStack[v] = false;
    }

    //判断有向图中是否有环
    public boolean hasCycle(){
        return hasCycle;
    }
}

```



有向图

```javascript
package algorithm.sort;

public class Digraph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;

    //构造方法
    public Digraph(int V){
         //初始化顶点数量
        this.V = V;
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }

    }

    //获取顶点数目
    public int V(){
        return V;
    }

    //获取边的数目
    public int E(){
        return E;
    }

    //向有向图中添加一条边v->w
    public void addEdge(int v, int w){
         //只让顶点w出现在顶点v邻接表中
        adj[v].enqueue(w);
        //边数+1
        E++;
    }

    //获取由v指出的边所链接的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];
    }

    /*
     * 获取该图的反向图无非要做两点，第一点是将创造一个有向图对象用于
     * 记录该反向图，第二点是实现边的反向指向。实现反向指向的方法很简
     * 单，遍历原有向图的每一个顶点的邻接表，每找到一个顶点在该顶点里
     * 就说明该顶点对邻接表里的顶点有指向，我们在反向图里只要让邻接表
     * 里的顶点指向该代表该邻接表的顶点就可以了
     */
    //该图的反向图
    private Digraph reverse(){
        //创建和原图有相同顶点的有向图对象
        Digraph r = new Digraph(V);
        //遍历所有顶点
        for (int v = 0; v < V; v++) {
            //遍历所有顶点的邻接表
            for (Object w: adj[v]) {
                //令邻接表内的顶点指向代表该邻接表的顶点
                r.addEdge((Integer) w,v);
            }
        }
        //返回我们所创建的反向图
        return r;
    }
}

```



路径查找

```javascript
package algorithm.sort;

public class DepthFirstPaths {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //用值来代表起点
    private int s;
    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点
    private int[] edgeTo;

    //初始化深度优先搜索对象，调用深度优先搜索找出G图中起点为s的所有路径
    public DepthFirstPaths(Graph G,int s){
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化起点
        this.s = s;
        //初始化edgeTo数组,长度也为结点数量
        this.edgeTo = new int[G.V()];
        //调用方法找出G图中起点能到达的顶点
        dfs(G,s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相邻顶点
    private void dfs(Graph G,int v){
        //把v表示为已搜索
        marked[v] = true;

        //遍历顶点v的邻接表，拿到每个相邻的顶点，继续递归搜索
        for (Object w:G.adj(v)) {
            //如果顶点w没有被搜索才继续进行递归搜索
            if(!marked[(int) w]){
                edgeTo[(int) w] = v;//将到达w顶点的上一个顶点记录在数组中
                dfs(G, (Integer) w);
            }
        }
    }

    //判断w顶点和s顶点是否存在路径
    public boolean hasPathTo(int v){
        //这里我们直接通过有没有被搜索过来判断其有没有路径，所以代码不用改动
        //这个其实也很好理解，因为只要一被搜索，就说明能从起点到该结点，就说明
        //有路径，如果起点都无法到达该结点，那肯定没有路径啊
        return marked[v];
    }

    //找出从起点s到顶点v的路径(就是该路径经过的顶点)
    public Stack<Integer> pathTo(int v){
        if(!hasPathTo(v)){
            //如果该点与起点不存在路径，那就没必要寻找路径
            return null;
        }
        //创造栈对象用于保存路径中的所有顶点
        Stack<Integer> path = new Stack<>();

        //通过循环，从顶点v开始一直往前找，直到起点为止，此处是从终点往起点遍历
        //这个for循环的构造非常妙，可以的话就记起来
        for (int x = v; x != s; x = edgeTo[x]) {
            //每次循环将x结点的值压栈
            path.push(x);
        }
        //将起点压入栈中，因为遍历到最后我们没有遍历起点
        path.push(s);
        return path;//返回存储路径的栈对象，相当于返回路径
    }

}

```



深度优先搜索

```javascript
package algorithm.sort;

public class DepthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;

    /*
     * 由于我们在构造方法里调用了找出图中所有结点的dfs方法，所以在测试
     * 类里我们一旦创建了深度优先搜索对象，那么我们就会立刻在对象中产生
     * 我们传入的要查找结点的连通结点数量
     */
    //构建深度优先搜索对象并使用深度优先搜索找出G图中s顶点的所有相邻顶点
    public DepthFirstSearch(Graph G,int s){
        //初始化marked数组,由于该数组索引代表结点的值,因此其长度与结点
        //数量一致,所以此处将无向图的结点数量传入
        this.marked = new boolean[G.V()];
        //初始化跟顶点s相通的顶点数量,默认为0
        this.count=0;
        //this.count=0;
        //调用找出指定顶点所有相邻顶点的方法
        dfs(G,s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相通顶点
    private void dfs(Graph G,int v){
        //先将传入的v顶点标记为已搜索
        marked[v] = true;

        for (Object w:G.adj(v)) {
            //判断当前w顶点有没有被搜索过，若没有被搜索过
            //则递归调用dfs方法进入其子节点中进行深度搜索
            if(!marked[(int) w]){
                dfs(G, (Integer) w);
                //count++;
            }
        }

        /*
         * 代码能执行到此，说明对于起码对于一个相邻结点的判断已经完成了
         * 而且其必然为v的相同顶点，因此相通顶点数量要+1，但说实话我个人
         * 觉得应该要放到if那里才对，然后将初始化的连通数量改为1就行了。
         * 之所以改为1没问题是任何结点都必然和他自己连通，不过放在外面
         * 即使一开始初始化为0最终也没问题，但我觉得不好理解，这里为了
         * 和它的课件保持同步就不做修改了
         */
        //相通顶点数量+1
        count++;
    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w){
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return count;
    }
}

```





广度优先搜索

```javascript
package algorithm.sort;

import java.util.WeakHashMap;

public class BreadthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;
    //用来存储待搜索邻接表的结点的队列
    private Queue<Integer> waitSearch;

    /*
     * 由于我们在构造方法里调用了找出图中所有结点的dfs方法，所以在测试
     * 类里我们一旦创建了深度优先搜索对象，那么我们就会立刻在对象中产生
     * 我们传入的要查找结点的连通结点数量
     */
    //初始化深度优先搜索对象并使用深度优先搜索找出G图中s顶点的所有相邻顶点
    public BreadthFirstSearch(Graph G, int s){
        //初始化marked数组,由于该数组索引代表结点的值,因此其长度与结点
        //数量一致,所以此处将无向图的结点数量传入
        this.marked = new boolean[G.V()];
        //初始化跟顶点s相通的顶点数量,默认为0
        this.count=0;//this.count=0;
        //初始化队列
        this.waitSearch = new Queue<Integer>();
        //调用找出指定顶点所有相邻顶点的方法
        bfs(G,s);
    }

    /*
     * 说实话，我觉得这个方法这样设计其实是没有体现出广度优先搜索的特性的，但是其也能
     * 完成需求，如果要广度优先搜索应该是先对兄弟结点进行遍历再遍历子节点，而这里采用
     * 递归的方式完成，那实际上代码会进入先进入到子节点中遍历，我认为这是不合理的。
     */
    //使用深度优先搜索找出G图中v顶点的所有相通顶点
    private void bfs(Graph G,int v){
        //先将传入的v顶点标记为已搜索
        marked[v] = true;
        //让顶点v压入队列并,此时顶点v处于待搜索状态
        waitSearch.enqueue(v);
        //构建循环，如果队列不为空，则从队列中弹出待搜索元素进行搜索
        while (!waitSearch.isEmpty()){
            //弹出一个待搜索的顶点
            Integer wait = waitSearch.dequeue();
            //遍历wait顶点的邻接表
            for (Object w:G.adj(wait)) {
                if(!marked((Integer) w)){
                    bfs(G, (Integer) w);
                    //count++;
                }
            }
        }

        /*
         * 代码能执行到此，说明对于起码对于一个相邻结点的判断已经完成了
         * 而且其必然为v的相同顶点，因此相通顶点数量要+1，但说实话我个人
         * 觉得应该要放到if那里才对，然后将初始化的连通数量改为1就行了。
         * 之所以改为1没问题是任何结点都必然和他自己连通，不过放在外面
         * 即使一开始初始化为0最终也没问题，但我觉得不好理解，这里为了
         * 和它的课件保持同步就不做修改了
         */
        //相通顶点数量+1
        count++;
    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w){
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return count;
    }
}

```



无向图

```javascript
package algorithm.sort;

public class Graph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;
    public Graph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量,最开始没有边，只有顶点，因此赋予0
        this.E = 0;
        //初始化邻接表，创建对应大小的队列数组
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }

    //获取顶点数目
    public int V(){
        return V;
    }

    //获取边的数目
    public int E(){
        return E;
    }

    //向图中添加一条边v-w
    public void addEdge(int v,int w){
        //无向图的边没有方向，一条边既可以说是从A到B也可以说是从B到A
        //因此我们要令A出现在B的邻接表中，也要让B出现在A的邻接表中
        //这样才能算是将一条边成功添加，所谓邻接表其实就是队列
        adj[v].enqueue(w);//将w添加到v的队列中
        adj[w].enqueue(v);//将v添加到w的队列中
    }

    //获取和顶点V相邻的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];//返回顶点V的队列，其队列中存放与其相邻的所有结点
    }

}
```



最终改良并查集

```javascript
package algorithm.sort;

public class UF_Tree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //用来存储每一个根结点对应的树中保存的结点的个数
    private int[] sz;
    //初始化并查集
    public UF_Tree(int N){
        //初始化分组的数量，默认情况下，有N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //将数组中每个索引的值赋予数组内部，代表不同分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }
        this.sz = new int[N];
        //默认情况下,sz中每个索引处的值都是1,此处其抽象意义表示的是每个树中
        //都只存储着一个根结点
        for (int i = 0; i < sz.length; i++) {
            sz[i] = 1;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //查找某个结点的父节点,也是根结点，union方法里需要此方法
    public int find(int p){
        //此处传入的p是我们要查找的结点
        while (true){//构建不断查找的循环
            //如果要查找的元素p(在数组中对应其索引)正好与其值相同
            //则说明我们找到了其根结点，返回p即可
            if(p == eleAndGroup[p]){
                return p;
            }
            //如果没找到，则令p变为p索引处的值，其动作意义是将p
            //在树中往根结点前进一位，在数组中表达的意义是将p定
            //位到其值所在的索引
            p = eleAndGroup[p];
        }
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connect(int p,int q){
        return find(p) == find(q);
    }

    /*
     * 说实话我觉得这里union方法还有问题，而且创建的数组不是为了表示抽象树的高度而是元素个数
     * 我也觉得有些奇怪，总感觉某些地方过不去又或者说是很奇怪，而且在抽象图上我也不能理解地特
     * 别明白，只能说明白个七七八八而已。但我又没法举出一个很好的反例出来，那就先这样吧
     */
    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //找到p元素和q元素所在组对应的树的根结点
        int pRoot = find(p);
        int qRoot = find(q);

        //判断pq是否已经在同一分组，因为都是父节点所以可以直接比较
        if(pRoot==qRoot){
            //如果已经在了则无需合并，直接结束方法
            return;
        }

        //先判断pRoot和qRoot谁的树大，并将较小的树合并到较大的树中去
        //都是父节点，因此可以直接传进sz[]中进行其值的比较
        if(sz[pRoot]<sz[qRoot]){
            //如果A小于B，则让A的根结点被B指向，代码上是令A索引处的值变为B索引的值
            eleAndGroup[pRoot] = qRoot;
            //将B树的元素数量加上A树元素的数量
            sz[qRoot]+=sz[pRoot];
        }else {
            eleAndGroup[qRoot] = pRoot;
            sz[pRoot]+=sz[qRoot];
        }

        //组的数量-1
        this.count--;
    }
}
```



改良并查集

```javascript
package algorithm.sort;

public class UF_Tree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //初始化并查集
    public UF_Tree(int N){
        //初始化分组的数量，默认情况下，有N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //将数组中每个索引的值赋予数组内部，代表不同分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //查找某个结点的父节点
    public int find(int p){
        //此处传入的p是我们要查找的结点
        while (true){//构建不断查找的循环
            //如果要查找的元素p(在数组中对应其索引)正好与其值相同
            //则说明我们找到了其根结点，返回p即可
            if(p == eleAndGroup[p]){
                return p;
            }
            //如果没找到，则令p变为p索引处的值，其动作意义是将p
            //在树中往根结点前进一位，在数组中表达的意义是将p定
            //位到其值所在的索引
            p = eleAndGroup[p];
        }
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connect(int p,int q){
        return find(p) == find(q);
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //找到p元素和q元素所在组对应的树的根结点
        int pRoot = find(p);
        int qRoot = find(q);

        //判断pq是否已经在同一分组
        if(pRoot==qRoot){
            //如果已经在了则无需合并，直接结束方法
            return;
        }

        //让p所在的树的根结点的父节点为q所在树的根结点的父节点
        eleAndGroup[pRoot] = qRoot;
        
        //组的数量-1
        this.count--;
    }
}
```



并查集

```javascript
package algorithm.sort;

/*
 * 这个并查集本身倒是不难理解，但是说实话，最开始讲并查集的时候是有
 * 树的，但后面实现并查集的代码是用数组实现的，只不过我们理解时可以
 * 将其抽象为树的实现，说实话这个抽象过程还是挺难理解的，如果直接理
 * 解成数组的话感觉要容易理解得多，而且并查集的底层用数组来实现的方
 * 式说实话效率不高
 * 但总之是实现了，实现了就行了
 */
public class UF {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //初始化并查集
    public UF(int N){
        //初始化分组的数量，默认情况下，有N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //将数组中每个索引的值赋予数组内部，代表不同分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //元素p所在分组的标识符
    public int find(int p){
        return eleAndGroup[p];
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connect(int p,int q){
        return find(p) == find(q);
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //判断元素pq是否已经在同一组中
        if(connect(p,q)){
            return;
        }
        //代码执行到此说明不为同一组
        
        //先找到p所在分组的标识符
        int pGroup = find(p);
        
        //找到q所在分组的标识符
        int qGroup = find(q);
        
        //合并组：将p所在组的所有元素的组标识符变为q所在组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            if(eleAndGroup[i]==pGroup){
                //如果其为p分组的表示符，则将其修改为q分组的标识符
                eleAndGroup[i] = qGroup;
            }
        }
        
        //分组个数-1
        this.count--;
    }
}
```







红黑树

```javascript
package cn.itcast.algorithm.heap;

public class ReaBlackTree<Key extends Comparable<Key>, Value> {
    //根结点
    private Node root;
    //记录树中元素的个数
    private int N;
    //红色链接
    private static final boolean RED = true;
    //黑色链接
    private static final boolean BLACK = false;

    //结点类
    private class Node {
        //存储键
        private Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子节点
        public Node right;
        //由其父节点指向其的链接的颜色
        public boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }

    //获取树中元素的个数
    public int size() {
        return N;
    }

    //判断当前结点的父指向链接是否为红色
    private boolean isRed(Node x) {
        //若结点为空则直接返回false
        if(x==null){
            return false;
        }
        //若结点不为空则返回比较值
        return x.color==RED;
    }

    /*
     * 这里之所以构建了x.color=h.color的代码而不是直接将x.color赋值为黑色
     * 的原因是h结点的颜色同时表达了其父节点对其自身的指向关系，而我们调用左旋
     * 方法是将两个结点换了位置之后还要让原先结点的子节点被原先结点的父节点给
     * 指向，因此我们这里要采用上面的代码，如果只是单纯的赋予黑色的话，就无法
     * 代表这种关系了，而且也有当前结点的父节点对其的指向其实是红色的可能，因此
     * 这里于情于理都是采用x.color=h.color的代码好
     */
    //左旋
    private Node rotateLeft(Node h){
        //获取h结点的右子节点，用结点x记录
        Node x = h.right;
        //让x结点的左子节点成为h结点的右子节点
        h.right=x.left;
        //让h成为x结点的左子节点
        x.left=h;
        //让x结点的color属性等于h结点的color属性
        x.color=h.color;
        //让h结点的color属性变为红色
        h.color = RED;
        //调用左旋方法之后原先结点与子节点交换了位置，因此返回原先结点的子节点
        return x;
    }

    //右旋
    private Node rotateRight(Node h){
        //获取h结点的左子节点，用结点x记录
        Node x = h.left;
        //让x结点的右子节点成为h结点的左子节点
        h.left=x.right;
        //让h成为x结点的右子节点
        x.right=h;
        //让x结点的color属性等于h结点的color属性
        x.color=h.color;
        //让h结点的color属性变为红色
        h.color = RED;
        //调用右旋方法之后原先结点与子节点交换了位置，因此返回原先结点的子节点
        return x;
    }

    /*
     * 按照颜色反转的方法演示实现方法，采用的是简单粗暴的直接赋值的方式，其实
     * 我个人觉得如果要在代码上表达颜色反转的意思的话，应该要构建if判断语句
     * 才比较合适，但是这里即使采用这种方式也并不不妥，所以没啥关系
     */
    //颜色反转
    private void flipColors(Node h) {
        //当前结点变为红色
        h.color=RED;
        //其左子树和右子树变为黑色
        h.left.color=BLACK;
        h.right.color=BLACK;
    }

    /*
     * 该方法将根结点与要插入的元素传入，然后调用真正执行插入的方法，将插入后的根结点重新赋值给root
     * 代表的意思是记录根结点的值root已经变换了，虽然说在红黑树里根结点一般都是不会变换的，一般而言
     * 这个操作似乎不用做，但我猜想这个方法存在的意义在于当根结点为临时的4-结点时，根结点会发生变换
     * 而且其深度会+1，此时我们将root更改为正确的根结点的方法就有了其意义
     */
    //在整个树上完成插入操作
    public void put(Key key, Value val) {
        root = put(root,key,val);
        //每次插入时重新赋予根结点的颜色为黑以确保根结点的链接不会因为在插入
        //时因为颜色反转等方法而改变颜色
        root.color=BLACK;
    }

    //在指定树中完成插入操作并返回添加元素后的新树
    private Node put(Node h,Key key, Value val) {
        //判断h是否为空，若为空则直接返回一个红结点，此处代表的意思是直接添加一个新的红结点到对应的子树中
        if(h==null){
            //结点数量+
            N++;
            return new Node(key,val,null,null,RED);
        }
        //比较h结点与要插入的值key的大小
        int cmp = key.compareTo(h.key);
        if(cmp<0){//如果插入值比当前的结点的值要更小
            //递归往左子树前进
            //这里构造将递归之后返回的结点重新赋值给h.left的原因是当我们调用了递归方法之后可能会因为各种
            //恢复其平衡性的方法而导致我们结点原先的指向变得混乱，这里构造这个代码的是为了每次递归结束之后
            //都要进行一次父节点对传入的子节点的重新指向，令红黑树本身变得有序，具体的过程我其实还不明白，
            //因为我没有拿例子去演示，但是我猜想应该就是这个原因
            h.left = put(h.left,key,val);
        }else if(cmp>0){
            //递归往右子树前进
            h.right = put(h.right,key,val);
        }else {
            //若相等，则发生值的替换
            h.value=val;
        }

        //插入完毕之后进行平衡性的恢复，其实我个人觉得这里是有问题的，因为我觉得恢复其平衡性并不是只要每次
        //都左右旋反转有必要就都执行一次就可以了，而是执行到结点确实不需要这些方法来恢复其平衡性的时候再停
        //止，但既然它都这么构建了，那就当是这样吧

        //进行左旋：当前结点的h的左子节点为黑色，右子节点为红色，需要左旋
        if(isRed(h.right) && !isRed(h.left)){
            //这里对h进行重新赋值，因为左旋会将结点值与其子节点值的位置互换
            //但是我们的h不应该发生变换，仍然是要定位到原先的位置，因此这里
            //每次左旋将该位置的新结点重新赋予给h，这样做也是为了上面插入方
            //法的重新指向的实现
            h = rotateLeft(h);
        }

        //进行右旋：当前结点h的左子节点及其左子节点的左子节点均为红色时，需要右旋
        if(isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        //颜色反转：当前结点h的左右子节点均为红色时，需要颜色反转
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        //返回被修改的新结点
        return h;
    }

    //根据key，从树中找出对应的值
    public Value get(Key key) {
        return get(root,key);
    }

    /*
     * 红黑树如果我们忽略红黑颜色的特殊性来看的话，其实它就是普通的二叉查找树
     * 那么我们这里从树中查找key对应的值的方法其实跟二叉查找树别无二致，这个
     * 应该很好理解
     */
    //从指定的树x中，查找key对应的值
    public Value get(Node x,Key key) {
        if(x==null) {
            return null;
        }

        //比较x结点的键和key的大小
        int cmp = key.compareTo(x.key);
        if(cmp<0){
            return get(x.left,key);
        }else if(cmp>0){
            return get(x.right,key);
        }else {
            return x.value;
        }
    }
}
```



最小索引优先队列

```javascript
package algorithm.sort;

/*
 * 索引优先队列的实现原理是先创建一个数组用于存放元素和关联的索引，第一个数组里存放了元素，同时这个元素自带索引
 * 我们姑且称之为真索引，数组称为真数组，接着第二个数组用于保存真索引排序后的值，其中里面的值都有对应的真索引
 * 这个数组我们成为影数组，其索引我们称之为影索引，接着我们定义了第三个数组用于保存第二个数组的逆序情况，
 * 第三个数组里面的每一个值都是影索引，我们称该数组为逆数组，其索引为逆索引
 * 这三个数组发挥的作用各不相同，真数组的作用其实是为了让影数组能够通过其值来找到对应的元素，而影数组本身是
 * 堆的一种抽象结构，通过影数组可以实现最小索引队列的数据结构，而逆数组的作用主要是为了提高效率，逆数组的存在
 * 能够让我们快速找到影数组的值所在的索引，能够省去很多拉满效率和代码简洁性的操作
 */
//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class IndexMinPriorityQueue<T extends Comparable<T>> {
    //用于存储堆中的元素的真数组
    private T[] items;
    //保存每个元素在items数组里的索引，pq数组需要堆有序，也就是影数组
    private int[] pq;
    //保存qp的逆序，将pq的值作为其索引，将其索引作为值，也就是逆数组
    private int[] qp;
    //记录堆中元素的个数
    private int N;

    //构造方法
    public IndexMinPriorityQueue(int capacity){
        //由于影数组是代表堆结构，因此影数组的首索引的位置废弃不用，影数组的值需要+1，逆数组自然也要+1
        //而真数组需要+1的原因我暂且蒙在鼓里，我怀疑即使不+1也是可以的
        this.items = (T[]) new Comparable[capacity+1];
        this.pq = new int[capacity+1];
        this.qp = new int[capacity+1];
        this.N = 0;

        //默认情况下，逆数组中没有任何数据，则让逆数组的元素都为-1，代表不存在任何元素
        //这里之所以给-1而不是null的原因是因为如果给null，容易造成空指针异常
        for (int i = 0; i < qp.length; i++) {
            qp[i]=-1;
        }
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j) {
        return items[pq[i]].compareTo(items[pq[j]])<0;
        //我们要实际比较的元素必然是真数组里的元素，因此这里利用影数组来获得
        //真数组里的对应元素并比较，而不是直接比较影数组的值
    }

    /*
     * 这个方法只完成交换，不进行复原堆中有序性的操作，当然实际上堆中的有序性
     * 是需要保证的，但是，这不是我们这个方法应该要做的事情，因此这里没有调用
     * 相应的能够恢复堆中有序性的方法
     */
    //交换堆中i索引和j索引处的值
    private void exch(int i,int j){
        //交换影数组pq中的数据
        int tmp = pq[i];
        pq[i] = pq[j];
        pq[j] = tmp;
        //此处我们只交换索引的原因是我们的抽象堆结构是由影数组pq构建的
        //那么我们只需要调整抽象结构里的索引位置就能够达到我们调整抽象结
        //构中索引对应的元素交换位置的目的

        //更新qp中的数据，由于影数组pq进行交换，那么逆数组qp也要进行改变
        qp[pq[i]]=i;
        qp[pq[j]]=j;
        /*
         * 首先我们要知道，pq的值就是qp的索引，而pq的索引就是qp的值，其中
         * 是有着对应的关系的，如果我们修改pq中的值，那么qp中的值也要相应
         * 发生改变，而其改变的方法很简单，首先是找到pq的改变的值所对应的
         * 索引，利用该索引得到变化后的pq的值，该值同时也是qp的索引，那么
         * 我们利用该值定位到qp的索引所对应的值，将该值修改为pq的索引
         * 而这样做之所以能够正确的原理在于，既然在pq里修改了规定索引的值
         * 那么在qp里就要修改原先值所对应的索引的值，qp修改后的值应该要是
         * pq的原先的值所对应的新索引，因为这里是换位操作而不是简单的修改
         * 操作，所以不会发生没有对应索引的情况
         * 这有点套娃的感觉，不是很好理解，但细想之后是能够理解其意思的
         * 实在想不明白的话直接记结论得了
         */
    }

    //判断k对应的元素是否存在
    public boolean contains(int k) {
        return qp[k]!=-1;
        //这里能够这样构造代码来判断是因为我们先将qp逆数组全部赋值为-1
        //而在其他方法中，如果pq影数组索引k真的存放了对应元素，那么在
        //其逆数组pq里必然是做了对应动作令其不为-1的
    }

    //最小元素关联的索引
    public int minIndex() {
        return pq[1];
        //由于我们是最小堆，那么最小堆的pq的第一个索引所对应的值就是该最小元素关联的索引
    }

    //往队列中插入一个元素，并关联索引
    public void insert(int i,T t) {
        //判断i是否已经被关联，若是，则结束方法，不允许关联
        if(contains(i)){
            return;
        }
        //插入元素必然要让元素个数+1，这里先令其+1便于后面添加元素
        N++;
        //把数据存储到items对应的i位置处
        items[i] = t;
        //此处i代表的就是就是我们的真数组的索引，将真数组的索引存于影数组的最后一位
        //把i存储到pq中，直接存储到pq数组的下一位，这里其实也对应了堆的抽象结构，因为
        //我们平时往堆里添加元素也是直接在后面上添加的，所以这里直接添加到pq抽象结构
        //数组的末位，没有任何问题
        pq[N]=i;
        //令逆数组i处索引添加对应逆序值
        qp[i]=N;
        //存储之后堆的有序性被打破，那么就要恢复其有序性
        //通过上浮算法完成对堆的调整
        swim(N);
    }

    /*
     * 删除队列中最小元素的方法和我们之前给最小优先队列的删除方法差不多，都是先将最小的
     * 元素与最后一位元素交换位置之后删除最后一位元素然后调用下沉方法恢复堆的有序性
     * 但是不同的是这里由于有着影数组和逆数组的存在，因此我们在使用这种方法时要进行
     * 影数组和逆数组的对应修改
     */
    //删除队列中最小的元素，并返回该元素关联的索引
    public int delMin() {
        //获取最小元素关联的索引，pq的第一个存储的值就是对应的最小元素的索引
        int minIndex = pq[1];

        //交换pq中索引1处和最大索引处的元素
        exch(1,N);
        //先删除逆数组qp中对应的内容，这里之所以构造如下代码，是因为N代表pq最后一位的索引
        //其索引所对应的值就是qp的索引，既然我们在pq中删除了这个元素，
        //那么在qp中也应该要没有了对应该值的索引，但实际上索引肯定还在，因为索引没法删除
        //那么我们就在qp中将该元素的值赋值为-1，代表该索引不存在亦或是该索引还未指向任何元素
        qp[pq[N]] = -1;
        //元素交换后删除pq最大索引处的内容，赋予-1就代表删除的意思
        pq[N]=-1;
        //删除items中对应的内容，因为我们删除了元素，自然也删除了真数组
        //中对应的元素，因此要将真数组中原来存在的元素删除，这里我们前面
        //记录过最小元素关联的索引，因此我们用其进行删除操作，这里赋值为
        //null是因为真数组的类型是T[]，只能赋值null代表删除
        items[minIndex] = null;
        //元素个数-1
        N--;
        //对堆进行下沉算法，恢复其有序性
        sink(1);
        //返回被删除的最小元素的关联的索引
        return minIndex;
    }

    /*
     * 删除索引i关联的元素其实是上一个删除最小元素的方法大同小异，都是要先将元素交换
     * 然后删除结尾的元素，同时由于影数组和逆数组的存在，所以要先对逆数组影数组修改
     * 最后再轮到真数组，虽然我们交换的不是根结点，而是中间的结点，但是这是最小索引
     * 优先队列，数组前面的元素必然小于后面的元素，因此当我们调换位置时，交换的元素
     * 必然是最大的元素，此时只需要调用下沉方法就可以了，但是即使我们调用了上浮也无妨
     * 由于黑马写的代码里调用了上浮，因此我们这里保留上浮的代码
     */
    //删除索引i关联的元素
    public void delete(int i) {
        //找到i在pq中的索引
        int k = qp[i];
        //交换pq中索引k处的值和索引N处的值
        exch(k,N);
        //删除qp的内容
        qp[pq[N]] = -1;
        //删除pq中的内容
        pq[N] = -1;
        //删除items中的内容
        items[k] = null;
        //元素的数量-1
        N--;
        //堆的调整
        sink(k);//下沉
        swim(k);//上浮
    }

    /*
     * 这个直接修改的方法与前面交换的方法不同，直接修改无法判断其大小关系究竟如何
     * 因此要恢复其堆有序则需要分别调用下沉和上浮算法
     */
    //把索引i关联的元素修改为t
    public void changeItem(int i,T t) {
        //修改items数组中i位置的元素为t
        items[i] = t;
        //找到i在pq中出现的位置并记录为k
        int k = qp[i];
        //堆调整
        sink(k);
        swim(k);
    }

    /*
     * 私以为这里有问题，因为调用了上浮算法，改变的是影数组的位置，但实际上我们的逆数组的位置
     * 也应该要相应进行改变，但是这里并没有做这样对应的改变，因此我觉得这一段其实是有问题的
     * 同样也包括下面的下沉算法，都是存在这个问题的。但是由于黑马的代码里没有提，因此这里也
     * 不多做修改，就这样吧
     */
    //使用上浮算法，使索引k处的元素处于正确位置
    private void swim(int k) {
        while (k>1){
            if(less(k,k/2)){
                exch(k,k/2);
            }
            k = k/2;
        }
    }

    //使用下沉算法，使索引k处的元素处于正确位置
    private void sink(int k) {
        while(2*k<=N){
            //找到子结点中的较小值
            int min;
            if (2*k+1<=N){
                if (less(2*k,2*k+1)){
                    min = 2*k;
                }else{
                    min = 2*k+1;
                }
            }else{
                min = 2*k;
            }
            //比较当前结点和较小值
            if (less(k,min)){
                break;
            }

            exch(k,min);
            k = min;
        }
    }
}
```



最小优先队列

```javascript
package algorithm.sort;

//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class MinPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public MinPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列中是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i,int j) {
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //删除堆中最大的元素，并返回这个最大元素
    public T delMax() {
        T min = items[1];
        exch(1,N);
        N--;
        //此处和之前我们建立堆代码不同的是这里没有将值赋予null
        //而且直接将N--，其实是都可以的，因为我们没有进行赋予空
        //的值到最终还是会被覆盖的，没什么影响
        sink(1);
        return min;
    }

    //使用上浮算法，是索引k处的元素在堆中处于一个正确的位置
    private void swim(int k){
        while (k>1){
            if(less(k,k/2)){
                exch(k,k/2);
            }
            k = k/2;
        }
    }

    //使用下沉算法，是索引k处的元素在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k<=N){
            int min;
            if(2*k+1<=N){
                if(less(2*k,2*k+1)){
                    min =2*k;
                }else {
                    min =2*k+1;
                }
            }else {
                min =2*k;
            }

            if(less(k, min)){
                break;
            }

            exch(k, min);

            k= min;
        }
    }
}
```





最大优先队列

```javascript
package algorithm.sort;

//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class MaxPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public MaxPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列中是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i,int j) {
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //删除堆中最大的元素，并返回这个最大元素
    public T delMax() {
        T max = items[1];
        exch(1,N);
        N--;
        //此处和之前我们建立堆代码不同的是这里没有将值赋予null
        //而且直接将N--，其实是都可以的，因为我们没有进行赋予空
        //的值到最终还是会被覆盖的，没什么影响
        sink(1);
        return max;
    }

    //使用上浮算法，是索引k处的元素在堆中处于一个正确的位置
    private void swim(int k){
        while (k>1){
            if(less(k/2,k)){
                exch(k/2,k);
            }
            k = k/2;
        }
    }

    //使用下沉算法，是索引k处的元素在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k<=N){
            int max;
            if(2*k+1<=N){
                if(less(2*k,2*k+1)){
                    max=2*k+1;
                }else {
                    max=2*k;
                }
            }else {
                max=2*k;
            }

            if(!less(k,max)){
                break;
            }

            exch(k,max);

            k=max;
        }
    }
}
```



排序堆

```javascript
package cn.itcast.algorithm.heap;

public class HeapSort {
    //判断heap堆中索引i处的元素是否小于索引j处的元素
    private static boolean less(Comparable[] heap, int i, int j) {
        return heap[i].compareTo(heap[j])<0;
    }

    //交换heap堆中i索引和j索引的值，这里与此前不同的是这里还要将数组也传入给该方法用于比较
    private static void exch(Comparable[] heap,int i, int j) {
        Comparable tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
    }

    //根据原数组source，构造出堆heap
    private static void createHeap(Comparable[] source,Comparable[] heap) {
        //把source中的元素赋值到heap中，heap中的元素是一个无序堆
        //调用API进行数组的复制，传入对应的值
        System.arraycopy(source,0,heap,1,source.length);

        //对堆中元素做下沉(从长度的一半处开始，往索引1处扫描)
        for (int i = (heap.length)/2; i > 0 ; i--) {
            sink(heap,i,heap.length-1);
            //范围之所以定位长度-1，是因为对于堆底部的数组而言，一开始是多创建了一个空间的，这是因为
            //我们将0位置的元素废弃了的缘故，但我们比较时是从1开始的，因此我们传入的范围需要-1，代表
            //堆中最大索引的范围，这行代码的意思也是说下沉算法的边界就在最大索引处的意思
        }
    }

    //对source数组中的数据从小到大排序
    public static void sort(Comparable[] source) {
        //构建堆，给其指定的空间+1，因为我们废弃了0位置处的空间，从1处开始添加元素，因为指定的空间要+1
        Comparable[] heap = new Comparable[source.length+1];
        createHeap(source,heap);//调用创造排序堆的方法
        //代码执行到此说明已经产生了有序堆
        //定义用于记录未排序元素最大索引的变量
        int N = heap.length-1;//N最开始定义到最大索引处
        while (N!=1){//只要索引没到1说明元素的交换没有到根结点处，那就继续进行交换
            //交换最大索引与最小索引的值
            exch(heap,1,N);
            //排序交换最大元素所在的索引，并令其不参加下沉
            N--;//直接减少N的值，这样N定义到次大索引处
            //对索引1处的元素执行下沉算法，传入N代表的边界值，N此时所代表的边界值就是我们所需要的边界值
            sink(heap,1,N);
        }

        //把heap中的数据赋值到原数组source中
        System.arraycopy(heap,1,source,0,source.length);
    }

    /*
     * 这个下沉算法与我们之前学习的下沉算法的代码逻辑只有细微区别，就不再赘述了
     * 不过有所不同的是这里我们比较的边界值range，而我们每次都要传入用于下
     * 沉算法的索引target，如果其二倍大于range，说明没有符合条件的子树，那么就
     * 跳出循环。其他代码没啥不同，不多说了
     */
    //在heap堆中，对target处的元素做下沉，范围是0~range
    private static void sink(Comparable[] heap,int target,int range) {
        while (2*target<=range){
            //找出当前结点的较大的子结点
            int max;
            if(2*target+1<=range){
                if(less(heap,2*target,2*target+1)){
                    max = 2*target+1;
                }else {
                    max = 2*target;
                }
            }else {
                max = 2*target;
            }

            //比较当前结点的值与较大子节点的值
            if(!less(heap,target,max)){
                break;
            }

            exch(heap,target,max);

            target = max;
        }
    }
}
```



堆

```javascript
package algorithm.sort;

//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class Heap<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    /*
     * 此处之所以是要生成Comparable接口是因为我们在泛型里继承了该接口
     * 如果我们生成Object类型的话会报类型转换异常，这里之所以让指定的
     * 容量+1是因为我们我数组里是废弃了0索引的，因此要多给予一个空间用
     * 于存放元素
     */
    public Heap(int capacity) {
        this.items=(T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中索引i和索引j处的值
    private void exch(int i,int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
        //其实我觉得这里应该要做一个调用上浮算法的动作的，但是没有
    }

    //往堆中插入一个元素
    public void insert(T t){
        //这里采用++N的方式是因为我们堆中的元素的首位是不存放任何元素的
        //我们采用++N，如果N等于0，那么我们就可以正确填入元素到1位置处
        //如果N不等于0，那么就正确填入元素到数组末尾
        items[++N]=t;
        swim(N);//添加完毕之后使用上浮算法令堆重新有序
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        //通过循环，不断比较当前结点和父节点的值
        while (k>1){//只要索引还大于1，说明还没到根结点，就继续执行循环
            //比较当前结点和父节点的大小
            if(less(k/2,k)){//如果当前结点大于父节点
                exch(k/2,k);//则交换字父结点的位置
            }

            k = k/2;//若不等于则令k结点的元素变化到其父节点的元素
        }
    }

    /*
     * 该方法只完成了交换和和调用下沉算法并且返回被删除的最大值的结点，这里删除元素的方式不是
     * 采用断开链表对其的指向，而且将其值赋值为null。在数组中就相当于不解除最后一个位置
     * 的空间，而将最后一个值赋值为null的意思。此处最大索引不是N-1而是N的原因是我们的首结点
     * 是只充当指引的元素，因为因此多占了一个位置，因此结尾可以到达N而不是N-1。在实际的代码上
     * 我们也是先从1索引处开始放置元素的，于情于理都可以理解N索引才是结尾而不是N-1
     * 我个人理解在本方法里交换最大和最小元素的意义在于，让最小元素成为根结点就可以保证下沉算法
     * 的不断实现，因为叶结点必然是最小的子节点，令其到头部可以不断使用下沉算法，通过下沉算法来
     * 让堆中的元素最终能达到一个部分排序的情况
     * 最后提一下这个方法只能用于删除堆中最大元素，而不是说删除指定元素
     */
    //删除堆中最大的元素，并返回这个最大元素
    public T delMax(){
        T max = items[1];//定义max用于记录最大元素

        //交换索引1处和最大索引处的元素
        exch(1,N);
        //删除最大索引处的元素
        items[N]=null;
        //元素个数-1
        N--;
        //通过下沉调整堆，让堆重新有序
        sink(1);
        //返回被删除的最大值
        return max;
    }

    //使用下沉算法使k在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k<=N){//只要2*k<=N存在，那么就说明还有左子树，还能继续进行循环比较
            int max;//定义max用于记录两子节点较大结点所在的索引
            if(2*k+1<=N){//判断有无右子树
                if(less(2*k,2*k+1)){//若有则判断左右子树大小
                    max = 2*k+1;//右子树大则让max记录右子树的索引
                }else {
                    max = 2*k;//反之则记录左子树的索引
                }
            }else {
                //若没有右子树则直接让max记录左子树的索引
                max = 2*k;
            }

            //比较当前结点和较大结点的值
            if(!less(k,max)){
                //如果当前结点大于较大结点，则说明已经处于正确位置，直接结束循环
                break;
            }

            //若小于交换索引k和较大子节点max所代表的值
            exch(k,max);

            //变化k的值，让k进入较大子节点的索引，实际上k也是与max进行的交换，因此将k的值定位到max上也容易理解
            k = max;
        }
    }
}
```





有序符号表

```javascript
package algorithm.sort;

import java.util.Iterator;

//令key继承Comparable接口，给Key所代表的元素提供比较方式，便于实现排序
public class OrderSymbolTable<Key extends Comparable<Key>,Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    //符号表中的结点类
    private class Node{
        //键，此处的Key是泛型标识
        public Key key;
        //值，此处的Value是泛型标识
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key,Value value,Node next) {
            this.key=key;
            this.value=value;
            this.next=next;
        }
    }

    //符号表的构造方法
    public OrderSymbolTable() {
        //创建不存储任何元素的首结点，其主要作用是指向下一个结点
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    /*
     *要实现该方法要先进行传入的key是否已经在符号表中存在的判断，如果
     * 已经存在了那么我们就替换对应value的值就可以了。如果不存在那么
     * 就正常插入，插入的方式不是让尾结点指向新结点，而是让头结点指向
     * 新的结点，让新的结点指向原先首结点指向的下一个结点，有点类似于
     * 队列中的插入方式
     */
    //往符号表中插入键值对
    public void put(Key key,Value value) {
        //定义两个Node变量分别记录当前结点与当前结点的上一个结点
        Node curr = head.next;//记录当前结点
        Node pre = head;//记录当前结点的上一个结点
        while (curr!=null&&key.compareTo(curr.key)>0){
            /*
             *构建while循环进行判断，要求当curr不为null且curr
             * 的key值小于我们进行比较的传入的key值，满足条件
             * 则说明结点定位还没到我们想要的传入值不小于结点key值
             * 的那个位置，那么我们就让结点继续前进
             */
            pre = curr;//令记录当前结点的上一个结点的结点前进一位
            curr = curr.next;//令当前结点前进一位
        }
        //代码执行到此说明已经到达了我们想要的传入值不小于结点key值
        //的位置，但是我们还要进行判断其是否相等
        if(curr!=null&&key.compareTo(curr.key)==0){
            curr.value = value;//如果相等则替换value
            return;//结束方法
        }
        //代码执行到此说明传入值比小于结点值key
        //创建新结点，令该结点指向其key值小于它的第一个结点
        Node newNode = new Node(key,value,curr);
        //令原先curr的结点的上一个结点指向这个新结点
        pre.next = newNode;

        //元素的个数+1
        N++;
    }



    /*
     * 该删除方法的实现原理是先找到对应的结点，然后将对应结点的上一个
     * 结点指向对应结点的下一个结点
     */
    //删除符合表中键为key的键值对
    public void delete(Key key){
        //先构建循环找到键为key的结点
        Node n = head;//同样先创建n保存头结点
        while (n.next!=null){
            //判断n结点的下一个结点是否为key，若是就进入方法
            //由于n最初是头结点，因此先构建代码n.next没有问题
            if(n.next.key.equals(key)){
                //令被删除结点的上一个结点的尾指针域指向被删除结点
                //的下一个结点
                n.next = n.next.next;
                N--;
                return;
            }
            //若不是则令n进入下一个结点
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while (n.next!=null){
            //令n进入其所指向的下一个结点
            n = n.next;
            //判断是否是与传入的key的值相同的结点
            if(n.key.equals(key)){
                //若是则返回该结点的value
                return n.value;
            }
        }
        //代码执行到此说明符号表内压根没有对应的key，返回null
        return null;
    }
}
```





无序符号表

```javascript
package algorithm.sort;

import java.util.Iterator;

public class SymbolTable<Key,Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    //符号表中的结点类
    private class Node{
        //键，此处的Key是泛型标识
        public Key key;
        //值，此处的Value是泛型标识
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key,Value value,Node next) {
            this.key=key;
            this.value=value;
            this.next=next;
        }
    }

    //符号表的构造方法
    public SymbolTable() {
        //创建不存储任何元素的首结点，其主要作用是指向下一个结点
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    /*
     *要实现该方法要先进行传入的key是否已经在符号表中存在的判断，如果
     * 已经存在了那么我们就替换对应value的值就可以了。如果不存在那么
     * 就正常插入，插入的方式不是让尾结点指向新结点，而是让头结点指向
     * 新的结点，让新的结点指向原先首结点指向的下一个结点，有点类似于
     * 队列中的插入方式，将新结点插入到链表的头部
     */
    //往符号表中插入键值对
    public void put(Key key,Value value) {
        //先进行符号表中有无该key的键值对的循环判断
        Node n = head;//用n保存首结点便于后续遍历
        while (n.next!=null){//只要不为空说明还没循环到底，继续循环
            //令n进入其原先所指向的下一个结点，由于n是首结点，所以
            //其先进入下一个结点没有问题，因为首结点只负责指向
            n = n.next;
            //判断n结点存储的key与传入的key是否相等
            if(n.key.equals(key)){
                //若相等则替换对应结点内的value的值
                n.value = value;
                return;//插入完毕，直接结束该方法
            }
        }
        //代码执行到此说明不存在与其相等的key，则创建新结点
        Node newNode = new Node(key,value,null);
        //用oldFirst保存首结点指向的第一个结点
        Node oldFirst = head.next;
        //令新结点指向首结点指向的下一个结点
        newNode.next = oldFirst;
        //让首结点指向新结点
        head.next = newNode;
    }



    /*
     * 该删除方法的实现原理是先找到对应的结点，然后将对应结点的上一个
     * 结点指向对应结点的下一个结点
     */
    //删除符合表中键为key的键值对
    public void delete(Key key){
        //先构建循环找到键为key的结点
        Node n = head;//同样先创建n保存头结点
        while (n.next!=null){
            //判断n结点的下一个结点是否为key，若是就进入方法
            //由于n最初是头结点，因此先构建代码n.next没有问题
            if(n.next.key.equals(key)){
                //令被删除结点的上一个结点的尾指针域指向被删除结点
                //的下一个结点
                n.next = n.next.next;
                N--;
                return;
            }
            //若不是则令n进入下一个结点
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while (n.next!=null){
            //令n进入其所指向的下一个结点
            n = n.next;
            //判断是否是与传入的key的值相同的结点
            if(n.key.equals(key)){
                //若是则返回该结点的value
                return n.value;
            }
        }
        //代码执行到此说明符号表内压根没有对应的key，返回null
        return null;
    }
}
```





实现了链表反转的单向链表

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class LinkList<T> implements Iterable<T>{
    //记录头结点
    private Node head;
    //记录链表的长度
    private int N;

    //结点类
    private class Node {
        //存储元素
        T item;
        //指向下一个结点
        Node next;

        public Node(T item, Node next){
            this.item=item;
            this.next=next;
        }
    }

    //单向链表的构造方法
    public LinkList() {
        //初始化头结点,头结点不存储数据，因此item是null，头结点刚初始化也不指向谁，因此next也是null
        this.head=new Node(null,null);
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear() {
        head.next=null;
        this.N=0;
        //清空链表，直接让头结点不指向下一个结点，这样结点由于没有指向，会被垃圾回收器回收，达到清空链表的目的
    }

    //获取链表的长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //获取指定位置i处的元素
    public T get(int i) {

        //通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = head.next;//先创造一个结点n并赋予其头结点的引用
        for (int index = 0; index < i; index++) {
            n=n.next;//每次循环令n变为其结点的引用，循环i次就正好到自己想要到的结点的位置
        }

        return n.item;
    }

    //向链表中添加元素t
    public void insert(T t) {
        //先找到当前最后一个结点

        Node n = head;//先定义一个结点n令其等于头结点
        while (n.next!=null){
            n=n.next;
            //利用while循环来将n的next循环到指向结尾位置
        }

        //创建新结点，保存元素t
        Node newNode = new Node(t,null);
        //让当前最后一个结点指向新结点
        n.next=newNode;
        //元素的个数+1
        N++;
    }

    //向指定位置i处，添加元素t
    //要想添加元素就要找到想添加元素的位置的前/后各一个结点
    public void insert(int i,T t) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
            //循环i-1次，正好到i位置的前一个结点
        }

        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点要指向原来i位置的结点
        Node newNode = new Node(t,curr);
        //原来i位置的前一个结点指向新结点
        pre.next=newNode;
        //元素的个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回被删除的元素
    //要删除指定位置的i处的元素，同样要先找到该元素的一个前后元素
    public T remove(int i) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
        }
        //要找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //前一个结点指向下一个结点
        pre.next = nextNode;
        //元素个数-1
        N--;
        return curr.item;
    }

    //查找元素t在链表中第一次出现的位置
    public int indexof(T t){
        //从头结点开始，依次找到每一个结点，取出item和t比较，相同则返回下标
        Node n = head;
        for (int i = 0;n.next!=null; i++) {
            //循环继续条件为n.next!=null，这样就可以达到遍历到底的效果
            n=n.next;
            if(n.item.equals(t)){
                return i;
            }
        }
        return -1;//代码执行到此说明链表里没有目标元素，因此返回-1
    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
        //该方法的重写要求返回一个iterator对象
        //但是iterator是接口，无法直接创造对象
        //因此创建一个内部类来实现iterator接口
        //通过创建该内部类的方式来返回有相同作用的对象
    }

    //实现iterator接口需要重写hasNext和Next方法
    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
            //该方法用于判断当前指针指向还有没有下一个元素
            //用n.next!=null的判断代码可以通过判断其指针域是否为空来进行判断
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
            //先让指针指向下一个结点，接着返回该结点的数据内容
        }
    }

    //用于反转整个单向链表的方法
    public void reverse(){
        //先判断当前链表是否为空，若为空则结束运行
        if(isEmpty()){
            return;
        }
        //程序运行到此说明不为空，执行用于反转链表的重载reverse方法
        reverse(head.next);
    }

    //反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr) {
        //若结点为最后一个结点，即该结点不再指向下一个结点
        if(curr.next==null){
            //则让首结点指向该结点，该结点是原先的尾结点
            head.next=curr;
            //返回该尾结点
            return curr;
        }
        //递归返回的当前结点用定义好的pre结点对象来进行保存
        Node pre = reverse(curr.next);
        //让返回的结点的尾指针域指向原先的上一个结点
        //相当于是加上了后面对前面的指针
        pre.next=curr;
        //把当前结点的尾指针域赋值为null
        //相当于是把原先指向下一个结点的指针给清除
        curr.next=null;
        //最后按照需求返回当前的结点，这个返回只是为了不报错而设计的
        //设计在程序里这个返回值用户可以选择接收也可以选择不接收
        return curr;
    }
}
```



队列

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class Queue<T> implements Iterable{
    //记录首结点
    private Node head;
    //用于记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }

    public Queue() {
        this.head = new Node(null,null);
        this.last = null;
        this.N = 0;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //返回队列中的元素个数
    public int size(){
        return N;
    }

    /*
     * 我们这里的这个方法的主要作用是向队列中插入元素t，那当我们是队列
     * 数据结构时，我们应该怎么实现插入方法呢？我们可以按顺序在链表中
     * 添加元素，每次添加都让新添加的元素成为尾结点
     */
    public void enqueue(T t){
        //先判断队列中有无元素，通过last是否为null来判断
        if(last==null){
            //如果当前尾结点为null，也就是队列为空
            //直接将last定位到新创建的结点上，此时可以理解为新结点成为了尾结点
            last = new Node(t,null);
            //首结点指向尾结点
            head.next=last;
        }else {
            //当前尾结点的last不为null，此时先将last的结点记录于oldLast上
            Node oldLast = last;
            //令last指向新的尾结点
            last = new Node(t,null);
            //让上一个结点的尾指针域指向尾结点
            oldLast.next=last;
        }
        //元素个数+1
        N++;
    }

    //从队列中拿出一个元素

    /*
     * 这个方法的主要作用是从队列中拿出一个元素，但是注意在队列的数据
     * 结构中拿出元素是要按照先进先出的原则的，因此我们要想办法在取出
     * 元素时做到先取出第一个放置的元素。我们可以先取出首结点的下一个
     * 结点，然后让首结点指向被取出结点的下一个结点，按照这个方式取出
     * ，我们就可以达到先进先出的效果
     */
    public T dequeue(){
        //先判断队列是否为空
        if (isEmpty()){
            return null;
            //若为空则直接返回null
        }

        //将头结点指向的下一个结点用oldFirst记录起来
        Node oldFirst = head.next;
        //令头结点指向被取出结点的下一个结点，这个动作相当于删除结点同时下一个结点称为新结点
        head.next = oldFirst.next;
        N--;//元素个数-1

        //这个动作其实是在删除元素，如果队列的元素被删除完了，那么要重置last
        if(isEmpty()){
            last=null;
        }
        return oldFirst.item;//返回被删除元素的数据
    }

    @Override
    public Iterator iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator{
        //定义一个记录头结点的结点变量
        private Node n;

        public QIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```





栈

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class Stack<T> implements Iterable{
    //记录首结点
    private Node head;
    //栈中元素的个数
    private int N;

    private class Node{
        public T item;
        public Node next;

        public Node(T item,Node next) {
            this.item=item;
            this.next=next;
        }
    }

    //栈的构造方法，调用该方法将创造一个数据内容为null的结点对象并将引用传递给head
    public Stack() {
        this.head = new Node(null,null);
        this.N=0;
    }

    //判断当前栈中元素的个数是否为0
    public boolean isEmpty(){
        return N==0;
    }

    //获取栈中元素的个数
    public int size(){
        return N;
    }

    //把t元素压入栈

    /*
     *该方法的原理是不断往链表里增加元素，如果增加的结点为1，那么就
     * 让新结点被首结点指向，如果不为1，则让首结点指向该新结点，同时
     * 该新结点指向原来的旧结点。这里就模仿了栈的数据的先进后出特点，
     * 我们只要按照上述方式来构建链表，那么等到我们遍历时，我们的链表
     * 所遍历的元素会先从最后一个加入的元素遍历到我们第一个加入的元素
     */
    public void push(T t){
        //找到首结点指向的第一个结点，并将其赋予给oldFirst
        //私以为这里有问题，运行时会发生空指针异常
        //但实际却没有发生空指针问题，我感到无法理解
        Node oldFirst = head.next;
        //创建新结点
        Node newNode = new Node(t,null);
        //让首结点指向新结点
        head.next = newNode;
        //让新结点指向原来被首结点指向的旧结点
        newNode.next=oldFirst;
        //元素个数+1
        N++;
    }

    //弹出栈顶元素
    public T pop(){
        //找到首结点指向的第一个结点，并将该结点用oldFirst保存
        Node oldFirst = head.next;
        //如果oldFirst为null则直接返回null，不必再做判断
        //这里代表的意思是已经取到底了，没有元素可以取了
        if(oldFirst==null){
            return null;
        }
        //让首结点指向原来的第一个结点的下一个结点
        head.next=oldFirst.next;
        //元素个数-1
        N--;
        return oldFirst.item;
    }

    @Override
    public Iterator iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private Node n;

        public SIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
```





单向链表

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class LinkList<T> implements Iterable<T>{
    //记录头结点
    private Node head;
    //记录链表的长度
    private int N;

    //结点类
    private class Node {
        //存储元素
        T item;
        //指向下一个结点
        Node next;

        public Node(T item, Node next){
            this.item=item;
            this.next=next;
        }
    }

    //单向链表的构造方法
    public LinkList() {
        //初始化头结点,头结点不存储数据，因此item是null，头结点刚初始化也不指向谁，因此next也是null
        this.head=new Node(null,null);
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear() {
        head.next=null;
        this.N=0;
        //清空链表，直接让头结点不指向下一个结点，这样结点由于没有指向，会被垃圾回收器回收，达到清空链表的目的
    }

    //获取链表的长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //获取指定位置i处的元素
    public T get(int i) {

        //通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = head.next;//先创造一个结点n并赋予其头结点的引用
        for (int index = 0; index < i; index++) {
            n=n.next;//每次循环令n变为其结点的引用，循环i次就正好到自己想要到的结点的位置
        }

        return n.item;
    }

    //向链表中添加元素t
    public void insert(T t) {
        //先找到当前最后一个结点

        Node n = head;//先定义一个结点n令其等于头结点
        while (n.next!=null){
            n=n.next;
            //利用while循环来将n的next循环到指向结尾位置
        }

        //创建新结点，保存元素t
        Node newNode = new Node(t,null);
        //让当前最后一个结点指向新结点
        n.next=newNode;
        //元素的个数+1
        N++;
    }

    //向指定位置i处，添加元素t
    //要想添加元素就要找到想添加元素的位置的前/后各一个结点
    public void insert(int i,T t) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
            //循环i-1次，正好到i位置的前一个结点
        }

        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点要指向原来i位置的结点
        Node newNode = new Node(t,curr);
        //原来i位置的前一个结点指向新结点
        pre.next=newNode;
        //元素的个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回被删除的元素
    //要删除指定位置的i处的元素，同样要先找到该元素的一个前后元素
    public T remove(int i) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
        }
        //要找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //前一个结点指向下一个结点
        pre.next = nextNode;
        //元素个数-1
        N--;
        return curr.item;
    }

    //查找元素t在链表中第一次出现的位置
    public int indexof(T t){
        //从头结点开始，依次找到每一个结点，取出item和t比较，相同则返回下标
        Node n = head;
        for (int i = 0;n.next!=null; i++) {
            //循环继续条件为n.next!=null，这样就可以达到遍历到底的效果
            n=n.next;
            if(n.item.equals(t)){
                return i;
            }
        }
        return -1;//代码执行到此说明链表里没有目标元素，因此返回-1
    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
        //该方法的重写要求返回一个iterator对象
        //但是iterator是接口，无法直接创造对象
        //因此创建一个内部类来实现iterator接口
        //通过创建该内部类的方式来返回有相同作用的对象
    }

    //实现iterator接口需要重写hasNext和Next方法
    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
            //该方法用于判断当前指针指向还有没有下一个元素
            //用n.next!=null的判断代码可以通过判断其指针域是否为空来进行判断
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
            //先让指针指向下一个结点，接着返回该结点的数据内容
        }
    }
}
```





双向链表

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class  TwoWayLinkList<T> implements Iterable<T> {
    //首结点
    private Node head;
    //最后一个结点
    private Node last;

    //链表的长度
    private int N;

    //结点类
    private class Node{
        //存储数据
        public T item;
        public Node pre;
        public Node next;

        public Node(T item,Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
    }

    public TwoWayLinkList(){
        //初始化头结点的尾结点
        this.head = new Node(null,null,null);
        this.last = null;//此时尾结点还不存在，因此赋予null
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear(){
        //要实现清空链表的效果，只要做两件事情，第一件是令头结点不再指向任何结点
         this.head.next=null;
         this.head.pre=null;//这个可写可不写
         this.head.item=null;//同上
        //第二件是让最后一个尾结点为null，让尾结点不存储任何东西
        this.last=null;
        //最后让记录N的长度的变量为0
        this.N=0;
    }

    //获取链表长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //获取第一个元素
    public T getFist(){
        //先判断头结点是否为空，即头结点有无指向下一个结点
        if (isEmpty()){
            return null;//若为空则返回null
        }
        //若不为空则返回头结点的下一个结点的内容
        return head.next.item;
    }

    //获取最后一个元素
    public T getLast(){
        //先判断头结点是否为空，即头结点有无指向下一个结点
        if (isEmpty()){
            return null;//若为空则返回null
        }
        //若不为空则返回尾结点的内容
        return last.item;
    }

    //插入元素t
    public void insert(T t){
        //链表为空的情况
        if(isEmpty()){
            //先创建新的结点，该头指针域指向头结点，尾指针域为空
            Node newNode = new Node(t,head,null);
            //让新结点成为尾结点，这也是其尾指针域为空的原因
            last=newNode;
            //让头结点的尾指针域指向尾结点
            head.next=last;
        }else {
            //如果链表不为空的情况
            //先将为结点用oldLast来保存
            Node oldLast = last;

            //创建新的结点，让该结点的头指针域指向原先的尾结点
            Node newNode = new Node(t,oldLast,null);

            //让当前的尾结点的尾指针域指向新结点
            oldLast.next=newNode;

            //让新结点成为尾结点
            last = newNode;
        }

        //元素个数+1
        N++;

    }

    //向指定位置插入元素t
    public void insert(int i,T t){
        //找到i位置的前一个结点,先定义pre结点存储这个节点的引用
        //将pre定义为head并循环i次可以定义到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre=pre.next;
        }
        //手动找到i位置的结点，定义curr结点存储i位置结点的引用
        Node curr = pre.next;
        //创建新结点
        Node newNode = new Node(t,pre,curr);
        //令原先i位置的前一个结点的尾指针域指向新结点
        pre.next=newNode;
        //让i位置的结点的头指针域指向新结点
        curr.pre=newNode;
        //元素个数+1
        N++;
    }

    //获取指定位置i处的元素
    public T get(int i){
        //将n定义为首结点的下一个结点，循环i次能正好定义到位置处的结点
        Node n = head.next;
        for (int index = 0; index < i; index++) {
            n=n.next;
        }
        //定义到i位置之后取出该位置的数据
        return n.item;
    }

    //找到元素t在链表中第一个出现的位置
    public int indexOf(T t){
        Node n = head;
        for (int i = 0; n.next!=null; i++) {
            n=n.next;
            if(n.next.equals(t)){
                return i;
            }
        }
        return -1;
    }

    //删除i位置的元素，并返回该元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre=pre.next;
        }
        //找到i位置的结点，并用结点curr暂时保存其引用
        Node curr = pre.next;
        //找到i位置的下一个结点，并用nextNode保存其引用
        Node nextNode = curr.next;
        //让原先i位置的前一个结点的尾指针域指向i位置的下一个结点
        pre.next=nextNode;
        //让原先i位置的下一个结点的头指针域指向i位置的前一个结点
        nextNode.pre=pre;
        //元素的个数-1
        N--;
        //返回被删除的元素的数据内容
        return curr.item;
    }

    //继承Iterable接口重写的Iterator方法
    @Override
    public Iterator<T> iterator() {
        return new TIterator();
        //返回以实现方式实现的内部类，其作用等同于Iterator
    }

    //实现Iterator接口的类要重写hasNext和next方法
    private class TIterator implements Iterator{
        private Node n;//先定义一个结点
        public TIterator(){
            this.n=head;
            //令该结点获得head结点的引用
        }
        
        @Override
        public boolean hasNext() {
            return n.next!=null;
            //只要其结点的尾指针域不为空则表示还有下一个
        }

        @Override
        public Object next() {
            n=n.next;//令n进入下一个结点
            return n.item;//取出该结点的数据
        }
    }
}
```





顺序表

```javascript
package algorithm.sort;

import java.util.Iterator;

//若想要遍历，就应该要先实现Iterable接口
public class SequenceList<T> implements Iterable<T> {
    //存储元素的数组
    private T[] eles;//该数组还没有进行初始化，没有赋予空间大小
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //之所以采用这种方式，是因为this.eles=new T[capacity];这种语法无法通过
        //其原因在于泛型T无法被直接实例化

        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    private void clear(){
        this.N=0;
        //个人认为这里只是将记录数组长度的变量赋值为0，并没有真正将数组的元素清空
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线性表中添加元素t
    public void insert(T t){
        if(N==eles.length){
            resize(2*eles.length);
        }
        eles[N++]=t;
        //将数值赋给对应位置之后，将长度+1
        //同样我认为这方法只是将记录的值+1，实际上没有创建新的用于存放数据的空间
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        if(N==eles.length){
            resize(2*eles.length);
        }

        //把i索引处的元素及其后面的元素依次向后移动一位
        for (int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;
        //这里利用倒序遍历法来将数组插入后续的值都后移一位的思想值得学习
        //但是我认为这里同样存在没有增加存放插入数据的空间的问题
        //而且应该会报数组下标越界异常才对，但是实际运行没啥问题，就有点小怪

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素一次向前移动一位
        for (int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;

        if(N<eles.length/4){
            resize(eles.length/2);
        }

        return current;
    }

    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for (int i=0;i<N;i++){
            if(eles[i].equals(t)){//使用equals方法进行比较
                return i;
            }
        }
        return -1;
    }

    //根据参数newSize，重置eles的大小
    public void resize(int newSize){
        //定义一个临时数组，指向原数组
        T[] temp=eles;
        //创建新数组
        eles=(T[])new Object[newSize];
        //把原数组的数据拷贝到新数组即可
        for(int i=0;i<N;i++){
            eles[i]=temp[i];
        }
    }

    //实现Iterable接口需要重写Iterator方法
    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    //重写该方法要令其返回一个Iterator，但是Iterator是接口，无法直接new对象
    //因此我们自己写一个内部类令其继承Iterator并重写其内部的方法
    //这样就可以通过new这个类来达到返回一个Iterator的目的了
    private class SIterator implements Iterator{

        //定义一个指针用于遍历
        private int cursor;

        //定义一个构造方法，调用该方法初始化指针为0
        public SIterator(){
            this.cursor=0;
        }

        //继承Iterator需要重写hasNext和next两个方法
        @Override
        public boolean hasNext() {
            return cursor<N;
            //该方法用于判断指针指向的位置是否还有元素，因此使用cursor<N
        }

        @Override
        public Object next() {
            return eles[cursor++];
            //该方法用于获取元素之后使指针指向下一位，因此是cursor++
        }
    }
}
```





二叉树

```javascript
package algorithm.sort;

//令key继承Comparable接口，给Key所代表的元素提供比较方式，便于实现排序
public class BinaryTree<Key extends Comparable<Key>,Value> {
    //记录根节点
    private Node root;
    //记录树中元素的个数
    private int N;

    //二叉树的结点类
    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子节点
        public Node left;
        //记录右子节点
        public Node right;

        //提供创建结点的构造方法
        public Node(Key key,Value value,Node left,Node right){
            this.key=key;
            this.value=value;
            this.left=left;
            this.right=right;
        }
    }

    //获取树中元素的个数
    public int size() {
        return N;
    }

    /*
     * 调用该方法只需要用户传入key和value就可以完成向树中添加元素，
     * 该方法内部会调用重载的put方法并传入树的根节点，要添加的key和
     * value，并最终将这个值返回给原先的树的根结点root，最后达成修
     * 改树的效果。树的根结点是最能够代表整个树的结点
     */
    //向树中添加元素key-value
    public void put(Key key,Value value) {
        root = put(root,key,value);
    }

    /*
     * 调用该方法需要传入树，要添加的key和value，我们在这个方法里先进行
     * 传入的树是否为null的判断，若是就直接产生一个新结点并返回就可以了。
     * 若不是则需要比较传入的值与树中各结点的key值的大小，若传入元素大于
     * 结点元素则往右子树上前进，反之则往左子树上前进，若相等则覆盖结点。
     * 这里我们往左右子树上前进的方式是采用了递归的方式的，比方说我们的键
     * 大于结点，那么我们就传入该右子树和key以及value递归调用put方法，并
     * 将该右子树的修改结果返回赋给原先的结点的右子树
     */
    //向指定的树x添加key-value并返回添加元素后的新的树
    private Node put(Node x,Key key,Value value) {
        //如果x子树为空
        if(x==null){
            N++;//元素个数+1
            //返回一个新结点，该结点没有任何子树，因此左右子树都没有指向
            return new Node(key,value,null,null);
        }
        //代码执行到此说明子树不为空

        //定义比较的结果并赋值给cmp
        int cmp = key.compareTo(x.key);
        //比较x结点的键与传入的key的大小
        if(cmp>0){
            /*
             * 如果key大于x结点的key，则往x结点的右子树上前进
             * 递归调用本方法，并且传入右子树的结点进入，且返回该结点的结果给原先结点的右子树
             * 之所以要把结果返回给x.right，是因为返回这个动作本身就带有赋值，指向的意义
             * 通过这个代码可以将新创建的结点正确地被其父节点指向。如果把不添加返回代码，那么
             * 到时候就会出现创建了对应的结点然而没有正确指向的情况。如果把x.right改为return
             * 那么最后的情况就是会正确创建对应结点并返回该结点，但是该结点却没有被正确指向
             */
            x.right = put(x.right,key,value);
        }else if(cmp<0){
            //如果key小于x结点的key，则往x结点的左子树上前进
            x.left = put(x.left,key,value);
        }else {
            //如果相等则覆盖value的值
            x.value=value;
        }
        //返回添加成功添加元素后的树
        return x;
    }

    /*
     * 该方法用于查找树中对于的key值的结点的value元素
     * 调用该方法只要传入一个key，会自动查找并返回value
     * 实际上该方法会调用重载的get方法，传入树和需要查找的key
     */
    //查询树中指定key对应的value
    public Value get(Key key){
        return get(root,key);
    }

    /*
     * 调用该方法需要传入树和key，先判断树是否为空，若为空则返回null
     * 代表在树中找不到对应元素的意义。若不为空同样判断key与结点中key
     * 的值，若传入key大于结点key则往右子树前进，反之则往左子树前进，
     * 若相等说明找到了，直接返回对应结点的value值就行了
     */
    //从指定的数x中，查找key对应的值
    public Value get(Node x,Key key) {
        //x所代表的树的结点为null
        if(x==null){
            return null;
        }

        //代码执行到此说明不为null，进行大小比较
        //定义比较的结果并赋值给cmp
        int cmp = key.compareTo(x.key);
        if(cmp>0){
            /*
             * 如果key大于x结点的key，则往x结点的右子树上前进，这里用return的原因
             * 是在于我们需要返回对应结点的值，因此我们需要使用return，因为我们不需
             * 指向，所以没必要跟上一个方法一样构造指向代码
             */
            return get(x.right,key);
        }else if(cmp<0){
            //如果key小于x结点的key，则往x结点的左子树上前进
            return get(x.left,key);
        }else {
            //如果相等说明找到了，直接返回x结点的值
            return x.value;
        }
    }

    //删除树中对应的value
    public void delete(Key key) {
        delete(root,key);
    }

    //删除指定树中的key对应的value，并返回删除后的新树
    public Node delete(Node x,Key key) {
        //如果其定位结点为null，说明找不到要删除的目标结点，那就直接返回null
        if(x==null){
            return null;
        }

        //代码执行到此说明结点不为空
        //定义比较的结果并赋值给cmp
        int cmp = key.compareTo(x.key);
        if(cmp>0){
            /*
             * 如果key大于x结点的key，则往x结点的右子树上前进，这里之所以构建了指向
             * 代码，是因为当我们将被删除元素的位置用另外一个次小的元素替换时，需要令
             * 其被父节点指向，为了实现这个动作，因此这里设置了指向代码
             */
            x.right = delete(x.right,key);
        }else if(cmp<0){
            //如果key小于x结点的key，则往x结点的左子树上前进
            x.left = delete(x.left,key);
        }else {
            //令元素个数-1，放置于此能让所有情况都实现N--
            N--;

            //如果相等说明找到了需要删除的结点，进行删除的操作
            //先判断目标结点的右子树是否为空
            if(x.right==null){
                /*
                若为空则直接返回左节点，这里面的原理是对于一个被删除元素而言
                若其右子树为空，则其次小元素必然在左子树的第一个结点中，说实话
                这为啥知道他就行我也不是很懂，但是经过分析发现无论左子树中还有没有
                子树，最后都是成立的，因此这个方法没有问题。
                 */
                return x.left;
            }

            if(x.left==null){
                return x.right;
            }

            //先将目标结点的右子树记录于minNode中，因为次小的元素必然在右子树的
            //左子树中，所以我们直接将minNode定位在被删除结点的右子树中
            Node minNode = x.right;
            //Node deleteNode = null;
            //通过while循环将minNode定位到最左子树的结点中
            while (minNode.left!=null){
                //if(minNode.left.left==null){
                //    deleteNode=minNode;
                //}
                minNode = minNode.left;
            }

            //deleteNode.left=null;

            //接下来要删除右子树中最小的结点
            Node n = x.right;
            //构建循环定位目标结点
            while (n.left!=null){
                //判断当前结点的后后结点是否为null，若是则说明下一个结点就是要删除的结点
                if(n.left.left==null){
                    //当前结点指向最小数值结点的指针删除
                    n.left=null;
                }else {
                    //若不到目标结点则让结点前进一位
                    n = n.left;
                }
            }
            /*
            个人觉得这里再构建一个循环用来专门定位次小结点的父节点未免有些多此一举
            实际上大可以在第一个循环里就去把次小结点的父节点给记录下来，这样就可以
            省略一个循环了，有益于提高我们的效率,实际操作之后发现真的可以
            这里上面的被注释的代码是我写的代码
             */

            //让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            //让x结点的父节点指向minNode，直接让x变为minNode，然后返回x
            //这样通过递归可以让x自动被其父节点指向
            x = minNode;

        }
        return x;
    }

    /*
     * 调用该方法会继续调用重载的min(Node)方法，而重载的方法会返回
     * 最小键所在的结点回来，此时直接取该结点的key就是我们所需要的
     * 最小值了
     */
    //查找整个树中最小键的方法
    public Key min(){
        //min(Node x)方法
        return min(root).key;
    }

    /*
     * 其最小键所在的结点无非就是在树中的最左结点，这是根据左小右大
     * 原则推理就能够得来的，这里使用了递归的方法，如果左节点不为空
     * 则继续调用该重载方法进入左节点直到为空时返回x的结点。其实我
     * 个人觉得用迭代的方式也可以，而且应该比这个方法更加容易想到
     * 但是用递归也是可以的，没有什么问题
     */
    //在指定的树x中找到最小键所在的结点
    private Node min(Node x){

        //判断x还有无左节点，若无则是x最小键所在的结点
        if(x.left!=null){
            return min(x.left);
        }else {
            return x;
        }
    }

    //查找整个树中最大键的方法
    //其原理和上面的一样，不多赘述了
    public Key max(){
        return max(root).key;
    }

    //在指定的树x中找到最大键所在的结点
    private Node max(Node x){

        //判断x还有无右节点，若无则是x最大键所在的结点
        if(x.right!=null){
            return max(x.right);
        }else {
            return x;
        }
    }

    /*
     * 因为要求要返回一个队列，因此在这个方法里先创建一个队列
     * 然后调用第二个方法将队列树中的元素按照前序遍历方式放入
     * 队列中，接着将该队列返回
     */
    //获取整个树中所有的键，此处是前序遍历的方法
    public Queue<Key> preErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列
        preErgodic(root,keys);//调用第二个方法来修改队列
        return keys;
    }

    /*
     * 该方法是使用递归实现的，理论上我认为也可以用迭代实现，前序遍历的方式是根左右
     * 因此这里我们的代码的构造形式是先将结点中的值放入队列，此处代表先取出根中的值
     * 接着是先判断左子树是否为空，这里递归调用时若左子树不为空也是先进入左子树里去
     * 查找的，接着左子树查找完了再继续进行右子树的判断。说实话，我觉得这种方式并不
     * 好去想得到，起码我就肯定想不到，但是是可以理解的
     * 最后队列的元素放好之后再逐个取出队列中的元素就是我们所需要的排序后的值了
     */
    //获取指定树x的所有键并放到keys队列中
    private void preErgodic(Node x,Queue<Key> keys){
        //先判断传入的结点是否为空
        if(x==null){
            //若为空则结点结束方法
            return;
        }

        //每次调用都把x结点的key放入到keys中
        keys.enqueue(x.key);

        //递归遍历x结点的左子树
        if(x.left!=null){
            //若左子树不为空则重复调用该方法并将队列传入
            preErgodic(x.left,keys);
        }

        //递归遍历x结点的右子树
        if(x.right!=null){
            //若右子树不为空则重复调用此方法并将队列传入
            preErgodic(x.right,keys);
        }
    }


    //获取整个树中所有的键，此处是中序遍历的方式
    public Queue<Key> midErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列
        midErgodic(root,keys);//调用第二个方法来修改队列
        return keys;
    }

    /*
     * 同样用递归的方法实现这个代码，与之不同的是中序遍历的方式是左根右
     * 所以这里先进入进行左子树是否为空的判断，如果是则不断进入左子树，
     * 然后再取出其根的值，接着在进行右子树的判断，其实本质差不多，无非
     * 是顺序变换了而已，于是乎对应现实逻辑，我们的代码逻辑也是只换了位置
     */
    //获取指定树x的所有键并放到keys队列中
    private void midErgodic(Node x,Queue<Key> keys){
        //先判断传入的结点是否为空
        if(x==null){
            //若为空则结点结束方法
            return;
        }

        //递归遍历x结点的左子树
        if(x.left!=null){
            //若左子树不为空则重复调用该方法并将队列传入
            midErgodic(x.left,keys);
        }

        //每次调用都把x结点的key放入到keys中
        keys.enqueue(x.key);

        //递归遍历x结点的右子树
        if(x.right!=null){
            //若右子树不为空则重复调用此方法并将队列传入
            midErgodic(x.right,keys);
        }
    }

    //获取整个树中所有的键，此处是后序遍历的方式
    public Queue<Key> afterErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列
        afterErgodic(root,keys);//调用第二个方法来修改队列
        return keys;
    }

    //获取指定树x的所有键并放到keys队列中
    private void afterErgodic(Node x,Queue<Key> keys){
        //先判断传入的结点是否为空
        if(x==null){
            //若为空则结点结束方法
            return;
        }

        //递归遍历x结点的左子树
        if(x.left!=null){
            //若左子树不为空则重复调用该方法并将队列传入
            afterErgodic(x.left,keys);
        }

        //递归遍历x结点的右子树
        if(x.right!=null){
            //若右子树不为空则重复调用此方法并将队列传入
            afterErgodic(x.right,keys);
        }

        //每次调用都把x结点的key放入到keys中
        keys.enqueue(x.key);
    }

    /*
     * 层序遍历无非是使用了两个队列来辅助完成排序，不过这里并没有
     * 使用递归的方式，而是使用迭代的方式，我猜想也可以使用递归来
     * 完成这个方法
     */
    //使用层序遍历，获取整个树中所有的键
    public Queue<Key> layerErgodic(){
        //定义两个分别存储结点和键的队列
        Queue<Key> keys = new Queue<>();//存放键的队列
        Queue<Node> nodes = new Queue<>();//存放节点的队列

        //默认要往队列中先放入根结点，这是必然的，根结点都没有怎么遍历啊
        nodes.enqueue(root);//将结点压入到结点队列

        //只要结点队列不为空就继续执行循环
        while (!nodes.isEmpty()){
            //从结点队列中弹出结点并将其key放入到键队列中
            Node n = nodes.dequeue();//弹出结点
            keys.enqueue(n.key);//将弹出结点的值压入到键队列

            //判断当前结点还有无左子树，若有则将左子树放入到结点队列中
            if(n.left!=null){
                nodes.enqueue(n.left);//压入左子树结点到节点队列
            }

            //判断当前结点还有无右子树，若有则将右子树放入到结点队列中
            if(n.right!=null){
                nodes.enqueue(n.right);//压入右子树结点到节点队列
            }
        }
        return keys;//最后返回键队列
    }

    //获取整个树的最大深度
    public int maxDepth(){
        return maxDepth(root);
    }

    /*
     * 主要发挥查询最大深度的方法是这个方法，上一个方法说是调用树的最大深度，其实本质是传入树的根
     * 然后调用这个方法，而这个方法是可以查询指定树的最大的深度。其原理是利用递归达成的，为了安全
     * 性所以首先判断传入结点是否为空，若为空就直接返回0就完了
     * 这个方法的主要思想是对每一个结点都进行左右深度的判断，谁大就返回谁并+1，经过不断地递归最终
     * 在我们一开始传入的结点里我们能够得到两个深度值，对其进行左右值的判断并返回+1即可。这里我们
     * 定义三个变量的原因是我们需要这三个变量来保存和判断，max是保存其深度的最大值，而maxL则是每
     * 次都记录其左子树的最大值而maxR则是右子树的最大值。说实话要我想我真想不到，但是可以理解
     */
    //获取指定树x的最大深度
    private int maxDepth(Node x){
        //结点的安全性判断，若为空则直接返回0
        if(x==null){
            return 0;
        }
        //定义max来保存x的最大深度
        int max=0;
        //定义maxL来保存左子树的最大深度
        int maxL=0;
        //定义maxR来保存右子树的最大深度
        int maxR=0;

        //计算x结点左子树的最大深度
        if(x.left!=null){
            //因为要用maxL进行判断所以每次递归时都要将最大值传给maxL，每次重复调用将左子树传入
            maxL = maxDepth(x.left);
        }
        //计算x结点右子树的最大深度
        if(x.right!=null){
            //因为要用maxR进行判断所以每次递归时都要将最大值传给maxR，每次重复调用将右子树传入
            maxR = maxDepth(x.right);
        }
        //比较左右子树的最大深度，取较大值+1并赋给max，这里运用三元运算符，其意思是判断maxL是否
        //大于maxR，若大于则返回maxL+1，小于则返回maxR+1。这里之所以用>符号就可以了是因为无论
        //让谁+1最后都会赋给max，都一样的其实，但之所以使用大于号，是为了便于最后的根结点的比较
        //如果用小于号的话，最后根结点返回的深度会是较小的那个，而我们的思路是返回较大的那个，因此
        //这里必须用大于号
        max = maxL>maxR?maxL+1:maxR+1;
        return max;
    }
}
```



