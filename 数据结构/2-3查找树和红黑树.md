2-3查找树概述

之前我们学习了二叉查找树，其查询效率大部分时候都比链表要来得高，但是不幸的是，在最坏情况下，其查询效率仍然非常糟糕，因此我们要学习创建另外一种树，令其即使在最坏情况下，其查询效率仍然是良好的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc8523d3700ecff175487ea45259cd3c6.png)



2-3查找树的定义

那么什么是2-3查找树呢？

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4ce461ddb9186eb77b0d72096dd9ede4.png)

简而言之，2-3查找树就是含有两种特殊的结点，一种是2-结点，2-结点含有一个键值且连接另外两条链，左子树的2-结点的键钧小于2-结点，而右子树的的值都大于该结点，比如对于R结点而言，P结点的值小于R，而其右子树下的3-结点的S与X均大于R结点

另外一种结点是3-结点，含有两个键三条链，左子树的3-结点均小于该结点值，而中间的2-结点的值则正处于该两点的值之间，右边的2-结点的值则大于该3-结点的两个值，具体可以看图上的例子

其中2-结点与3-结点的命名方式是按照该结点其下有几条子树来命名的，而且其结点存储的值数量总为其子树数量-1，而且在2-3查找树中，只有2-结点和3-结点两种结点的存在

那么2-3查找树是怎么查找对应的值的呢？

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE218977c870bc2eea9fbd693392ec6db6.png)

以H为例，其先与M进行对比发现比M小则会进入3-结点EJ中查找，查找发现其在EJ中间进入2-结点H中查找，比较发现H就是所需要的值，那么查找成功

如果我们查找Z的值的话，最终会进入3-结点SX中，但SX后续已经没有结点了，那么就会查找失败



2-3查找树的插入

在我们实现2-3的查找树的插入之前，我们得先学习2-3查找树插入新结点的四种不同情况的处理方式。

首先我们来学习向2-结点中插入新建结点的情况的处理方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE25e7cd30a06bf39efecebc2a036913e5.png)

可以看到我们要往2-3查找树立插入K，经过定位会发现要插入到2-结点L中，那么我们就应该将该2-结点转化为一个3-结点，其中K和L的谁放左边我们要通过比较来确定，这里经过比较发现L比K大，因此K放左边，L放右边

接着我们再来学习向一颗只含有一个3-结点的的树中插入新建结点的情况的处理方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6d6fd49007687d7b3faa9d2ca3755a88.png)

比方说我们要插入S，此时我们可以看到在3-结点AE中已经没有位置存储S了，那么我们就创建一个临时的4-结点，当然，元素的位置也是按照其大小排列的，接着我们将该4-结点分解，生成三个2-结点并令其构建连接，具体方式是将中间值E提出来创建一个2-结点，该2-结点分别指向左右两个值所创建的新2-结点

然后我们再来学习向一个父节点为2-结点的3-结点插入新结点的情况的处理方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf06f2f2d17c414fb628cd899aa516254.png)

比方说我们这里要插入Z元素的话，我们显然会定位到3-结点SX中，然后我们同样要将SX转换为了一个临时的4-结点，然后将X提出来创建三个2-结点并联立，但是我们可以看到4-结点SXZ的父节点是一个2-结点，如果我们将X提出来并合并的话，我们就要对R做之前我们学习过的对2-结点里插入新结点的处理，因此我们这里将2-结点R转换为一个3-结点RX，经过比较发现X比R大，因此X放R的右边，其下的三条子树分别连接原先的2-结点和我们新创建的两个2-结点

最后我们来学习向一个父节点为3-结点的3-结点中插入新建的情况的处理方式

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa4ec79e6d8e4f82e7f1f0154dd91323c.png)

假设我们插入D，那么我们显然能定位到3-结点AC中，将其变为4-结点ACD，然后提出C会撞上其父节点EJ，因此再次构建4-结点CEJ，此时4-结点连接两个由原来的4-结点分解的新创建的2-结点和原先的两个2-结点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf9991368a7664128bcdd0c22b00e7542.png)

最后我们将E提出与M对撞，此时将M变为3-结点，分别连接新创建的两个2-结点CJ与原先的2-结点R，而4-结点CEJ分解产生的两个新2-结点CJ则分别连接原先4-结点其下的四个2-结点

俗话说，四大天王都有五个，因此我们接着要学习分解根结点的方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1c0270c255e9119e2bcb2d662d75d258.png)

同样我们假设要插入D结点，先遇上3-结点AC，将其变为4-结点之后，提出C遇上3-结点EJ，因此又有新的4-结点CEJ，且连接2-结点ADHL，此时将E提出，由于其没有父节点了，因此我们可以直接创建一个2-结点E出来，则E成为2-结点连接其下分解的两个2-结点CJ，2-结点CJ又分别连接原先的4个2-结点ADHL

此时我们的根结点由原先的3-结点EJ变为2-结点E，而且我们的树高+1



2-3树的性质

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE63ddf0604d3b2539edd58aaedf909026.png)

那么现在讲完了2-3查找树的原理之后我们接下来来学习2-3树的性质，首先2-3查找树的任意空连接到根结点的路径长度都是相等的，其次是当4-结点变换为3-结点时，除非是根结点是临时的4-结点，否则树高都不会发生变化，最后是2-3查找树与普通的二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生成，而2-3树是自底向上生长，简单理解就是二叉查找树是直接往下增加结点来增加深度的，而2-3查找树增加深度的方式是以变换结点往上提的方式来增加深度的



2-3查找树的实现

显然我们知道如果我们要实现2-3查找树的话，属实是太麻烦了，因此我们这里就不实现了，那我们学习这个是为了什么？主要是为了给后面我们学习红黑树的B树打基础

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb6a50395f4cabc63739686f0159f6c55.png)



红黑树

那么接着我们来学习红黑树，红黑树是2-3查找树的一种简单实现，红黑树背后的基本思想是用标准的二叉查找树和一些额外的信息来表示2-3树，而那些额外的信息就是不同的链接，我们将树中的链接分为两类，分别是红链接与黑链接，红链接表示的意思是将两个2-结点连接起来构成一个3-结点，而黑链接表示的意思是2-3树中的普通链接。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0c6346e42cbaa44af59feb9d3872fe91.png)

比方说对于上面的红黑树而言，E和J元原本是两个2-结点，但是用红链接联立起来，就成了3-结点EJ了，其对应的三个子树分别是CHL

接着我们再来看看红黑树的标准定义

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe841b95a2b8c545a321591a0673f830e.png)

对于第二条定义的理解，如果有一个结点同时和两条红链接相连，那么其就是一个4-结点了，而在2-3树里，是不允许4-结点的存在的，而红黑树又是2-3树的简单实现，其必然也遵从2-3树的规则，因此在红黑树里不存在同时和两条红链接相连的结点

对于第三条定义，我们可以直接看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa7e462457a33224fedf5a3c3bcb5ac96.png)

将红色链接水平绘制之后我们就比较容易理解，由红链接联立的两个结点是一个3-结点，那么我们在2-3查找树里说过2-3查找树的一个性质是其每一个叶结点到子节点的路径是相同的，那么在红黑树里，黑链接就是普通链接，红链接是将两个结点联立陈给一个3-结点的连接，我们算路径长度是就恶意忽略红链接，因此我们的任意叶结点到根结点上的路径是相同的，即其路径上的黑链接数量是相同的

如果我们将红链接去除，能够得到真正意义上的2-3树，当然，要自己合并结点就是

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2be74a8f1a02bcc5b5093edee56fd63f.png)

那我们应该怎么去实现红黑树呢？在这之前我们先来学习红黑树的结点类设计，因为我们首先需要确定其结点的API设计，先来看看其结点的API设计吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE683832403e0f146df0aa3f73741b209e.png)

显然，在红黑树里的节点都有父节点指向其的红链接或黑链接，那么我们可以用一个布尔类型的变量来表示红链接与黑链接，若为true，则说明是红链接，若为false，则说明是黑链接

根结点则相对特殊，其没有父节点的链接指向它，不过我们只要对根结点进行特殊处理就完了

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3527cdce8fba08fac848de05cfc1f021.png)



红黑树的平衡化

在正式实现红黑树的数据结构之前，我们要先了解红黑树的平衡化方法，所谓平衡化，就是我们在添加元素时，我们所构造的树的结构可能会出现不符合红黑树数据结构的情况，此时我们需要通过平衡化方法令其恢复到红黑树的数据结构

红黑树的平衡化方法有两种，分别是左旋和右旋，这里我们先来讲讲左旋

当某个结点的左子节点为黑色，右子节点为红色时，此时需要左旋，这里我们设当前结点为h，其右子节点为x，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE298b098f79905c829089e5e04cf1f4f6.png)

接下来我们来看看左旋的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE00714fff2d80cc1d141df6e07e045b80.png)

首先我们让当前结点h的右子树位置获得s的左子树，接着令h成为x的左子节点，第三步是将h结点的黑链接变为赋给x，这里之所以采用赋予的方式是为了令h的父节点能成功地指向x结点，不过这是我猜的，第四步由于只需要将h结点的链接颜色变为红就行了，因此直接将其color属性变为true

接着我们讲下右旋，什么时候我们需要右旋呢？当某个结点的左子树为红色，其左子树的左子树也为红色时，此时我们就需要右旋，同样的，我们这里也设置当前结点为h，h的左子树为x，请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE56b49383bad359bdf099958767f63b82.png)

接下来看看右旋的步骤

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE416132cea3070b37d777a4c935e8e98a.png)

首先让x结点的右子树变为h结点的左子树，然后将当前结点变为其左子树的右子树，第三步是将当前结点的父指向赋予其左子树，第四步是将调转之后的结点h的链接颜色变为红

经过实际检验，我们会发现无论是左旋还是右旋，我们红黑树的有序性都是保持的。但问题在于右旋，显然，我们能够看到右旋之后产生了一个结点其左右子树都是红链接，这样显然不符合我们红黑树的定义，这个怎么解决呢？这个就要靠我们后面学习的颜色反转这一方式来进行解决



红黑树的插入

接着我们来学习红黑树的插入，由于红黑树的插入有多种情况，因此这里我们分情况来一个个进行讲解

首先是向单个2-结点中插入新键，这里要分两种情况，第一种情况是新建小于当前结点的键，如果是这种情况，那么我们只要将新建变为当前键的左子树并令当前键指向新建的链接变红即可

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8cf5c4e2e3f2971365b8d5bae27d042b.png)

此时我们的红链接对应的ab结点所构成的整体是与3-结点无异的

第二种情况是我们的要插入的新键大于当前的键，那么我们就令新键成为当前键的右子树，同时令当前键指向改键的链接变红，这样还没完，因为在红黑树里，红链接不能出现在右子树中，此时我们需要左旋操作令红黑树恢复原来的结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc4475d0938dd520aa375f90a483dffeb.png)

接着我们来讲第三种情况，向底部的2-结点插入新键

这个其实和我们上面讲解的两种方式比较类似，先来看看其理论解释

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE14cbb25cf563fe3b1133eecf0dd82d6a.png)

接下来我们来看看其图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1ec6af7961815513b5c563668ff3d614.png)

可以看到，我们这里也是先添加新键，然后用了一个经典的左旋操作完成了插入，唯一的不同应该在于这里的左旋操作需要让C准备地被E所指向，而最开始我们讲解的方法里显然不用，因为其只有两个结点，没有父节点指向，因此可以省略这一步骤

接着我们来讲讲颜色反转，所谓颜色反转，就是当我们的红黑树里出现一个结点其左右子树都是红链接时，此时我们需要使用颜色反转，令其恢复红黑树的数据结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbad953bdc4cb28b6253e53b1bdfe3bba.png)

请看下图的颜色反转演示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE11b6298cbca9aa065427143f6d40b1db.png)

一个结点的左右子树都为红链接时，此时可以将三个结点组成的正题视为一个4-结点，而我们的颜色反转模仿的其实就是4-结点分解为三个2-结点的过程（上图中左边表示我们的颜色反转过程，右边表示我们的2-3树里的分解过程），而我们之所以将其成为颜色反转，这是因为我们这个过程其实就是简单把黑链接变红链接，红链接变黑链接就能够完成了的，因此我们这里将这个行为称之为颜色反转

接着我们继续来讲我们的插入情况，接着我们讲向一棵双键树（即一个3-结点中插入新建）的插入方法

这里我们要分三种情况，第一种情况时新键大于原树中的两个键

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf45970da81cdde6422b8576de6fe7c7d.png)

这时我们按照二叉树的增加规则先将c结点插入到b的右子树中， 此时出现了一个结点里左右子树均为红链接的情况，这是使用颜色反转方法正式完成插入

第二种情况时新键小于原树中的两个键

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE86727ef79a0117c5cd1fa9bd8ebb3384.png)

同样先按照二叉树的增加规则先将a结点插入到b的左子树中，此时出现了一个结点里其左子树为红链接，其左子树的左子树同样为红链接的情况，那么我们首先调用右旋方法，之后再调用颜色反转方法即可完成插入

第三种情况是我们要插入的新键位于原树中的两个键之间

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa32c9982834daae06d73b8712ee6345d.png)

此时我们的b元素将插入到a的右子树之中，那么首先我们要调用左旋方法，接着调用右旋然后颜色反转即可完成插入



根结点的颜色总是黑色的

这里我们顺便讲一个只是，那就是根结点的颜色总是黑色的，因为我们之前讲的红黑树的结点类API设计里，我们是将红黑定义为父节点指向子节点的链接的颜色，而根结点是没有父节点的，因此我们每一次插入都要根结点的颜色设置为黑色

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc968ac40a406e42a95e31d01817470cf.png)

然后我们继续来讲我们的插入情况，现在我们来讲向树底部的3-结点插入新键的情况，同样会出现三种情况，同样我们只要调用我们之前学过的方法就能够解决这些问题，完成正确的插入

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEee80078aba81ce3526d8b2853e20c6bb.png)

这里我们只讲一种情况来作为举例

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6fa2d3be6cd978f5d32e8b71a387d888.png)

可以看到我们将H结点插入到R结点的左子树中，那么首先我们调用右旋方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd3a15808736052a1cb1e6be4c69a5d71.png)

记着再调用颜色反转方法，此时出现了E的左子树为黑链接而右子树为红链接的情况，再调用左旋方法即可完成正确插入

其实讲到这里我们也应该能总结出一些东西来了，就是在红黑树里面所有的结点都是2-结点，我们每插入新结点我们都期望其与原先的2-结点组成新的3-结点，因此我们无论在哪里插入新结点，其最开始的链接都必然是红链接



红黑树的实现

那么接下来我们就来正式用代码来实现红黑树这一数据结构，先来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf85bd79b23887bbc7a26c76516b1e791.png)

这里我们之所以在成员变量里定义了RED和BLACK是因为，如果我们只用true和false来表示红黑的话，可读性不高，因此我们这里又额外创建了两个RED和BLACK链接标识来表示红黑，这样就能够有效提高其可读性

由API设计我们可以构造其代码如下

```javascript
package cn.itcast.algorithm.heap;

public class ReaBlackTree<Key extends Comparable<Key>, Value> {
    //根结点
    private Node root;
    //记录树中元素的个数
    private int N;
    //红色链接
    private static final boolean RED = true;
    //黑色链接
    private static final boolean BLACK = false;

    //结点类
    private class Node {
        //存储键
        private Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子节点
        public Node right;
        //由其父节点指向其的链接的颜色
        public boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }

    //获取树中元素的个数
    public int size() {
        return N;
    }

    //判断当前结点的父指向链接是否为红色
    private boolean isRed(Node x) {
        //若结点为空则直接返回false
        if(x==null){
            return false;
        }
        //若结点不为空则返回比较值
        return x.color==RED;
    }

    /*
     * 这里之所以构建了x.color=h.color的代码而不是直接将x.color赋值为黑色
     * 的原因是h结点的颜色同时表达了其父节点对其自身的指向关系，而我们调用左旋
     * 方法是将两个结点换了位置之后还要让原先结点的子节点被原先结点的父节点给
     * 指向，因此我们这里要采用上面的代码，如果只是单纯的赋予黑色的话，就无法
     * 代表这种关系了，而且也有当前结点的父节点对其的指向其实是红色的可能，因此
     * 这里于情于理都是采用x.color=h.color的代码好
     */
    //左旋
    private Node rotateLeft(Node h){
        //获取h结点的右子节点，用结点x记录
        Node x = h.right;
        //让x结点的左子节点成为h结点的右子节点
        h.right=x.left;
        //让h成为x结点的左子节点
        x.left=h;
        //让x结点的color属性等于h结点的color属性
        x.color=h.color;
        //让h结点的color属性变为红色
        h.color = RED;
        //调用左旋方法之后原先结点与子节点交换了位置，因此返回原先结点的子节点
        return x;
    }

    //右旋
    private Node rotateRight(Node h){
        //获取h结点的左子节点，用结点x记录
        Node x = h.left;
        //让x结点的右子节点成为h结点的左子节点
        h.left=x.right;
        //让h成为x结点的右子节点
        x.right=h;
        //让x结点的color属性等于h结点的color属性
        x.color=h.color;
        //让h结点的color属性变为红色
        h.color = RED;
        //调用右旋方法之后原先结点与子节点交换了位置，因此返回原先结点的子节点
        return x;
    }

    /*
     * 按照颜色反转的方法演示实现方法，采用的是简单粗暴的直接赋值的方式，其实
     * 我个人觉得如果要在代码上表达颜色反转的意思的话，应该要构建if判断语句
     * 才比较合适，但是这里即使采用这种方式也并不不妥，所以没啥关系
     */
    //颜色反转
    private void flipColors(Node h) {
        //当前结点变为红色
        h.color=RED;
        //其左子树和右子树变为黑色
        h.left.color=BLACK;
        h.right.color=BLACK;
    }

    /*
     * 该方法将根结点与要插入的元素传入，然后调用真正执行插入的方法，将插入后的根结点重新赋值给root
     * 代表的意思是记录根结点的值root已经变换了，虽然说在红黑树里根结点一般都是不会变换的，一般而言
     * 这个操作似乎不用做，但我猜想这个方法存在的意义在于当根结点为临时的4-结点时，根结点会发生变换
     * 而且其深度会+1，此时我们将root更改为正确的根结点的方法就有了其意义
     */
    //在整个树上完成插入操作
    public void put(Key key, Value val) {
        root = put(root,key,val);
        //每次插入时重新赋予根结点的颜色为黑以确保根结点的链接不会因为在插入
        //时因为颜色反转等方法而改变颜色
        root.color=BLACK;
    }

    //在指定树中完成插入操作并返回添加元素后的新树
    private Node put(Node h,Key key, Value val) {
        //判断h是否为空，若为空则直接返回一个红结点，此处代表的意思是直接添加一个新的红结点到对应的子树中
        if(h==null){
            //结点数量+
            N++;
            return new Node(key,val,null,null,RED);
        }
        //比较h结点与要插入的值key的大小
        int cmp = key.compareTo(h.key);
        if(cmp<0){//如果插入值比当前的结点的值要更小
            //递归往左子树前进
            //这里构造将递归之后返回的结点重新赋值给h.left的原因是当我们调用了递归方法之后可能会因为各种
            //恢复其平衡性的方法而导致我们结点原先的指向变得混乱，这里构造这个代码的是为了每次递归结束之后
            //都要进行一次父节点对传入的子节点的重新指向，令红黑树本身变得有序，具体的过程我其实还不明白，
            //因为我没有拿例子去演示，但是我猜想应该就是这个原因
            h.left = put(h.left,key,val);
        }else if(cmp>0){
            //递归往右子树前进
            h.right = put(h.right,key,val);
        }else {
            //若相等，则发生值的替换
            h.value=val;
        }

        //插入完毕之后进行平衡性的恢复，其实我个人觉得这里是有问题的，因为我觉得恢复其平衡性并不是只要每次
        //都左右旋反转有必要就都执行一次就可以了，而是执行到结点确实不需要这些方法来恢复其平衡性的时候再停
        //止，但既然它都这么构建了，那就当是这样吧

        //进行左旋：当前结点的h的左子节点为黑色，右子节点为红色，需要左旋
        if(isRed(h.right) && !isRed(h.left)){
            //这里对h进行重新赋值，因为左旋会将结点值与其子节点值的位置互换
            //但是我们的h不应该发生变换，仍然是要定位到原先的位置，因此这里
            //每次左旋将该位置的新结点重新赋予给h，这样做也是为了上面插入方
            //法的重新指向的实现
            h = rotateLeft(h);
        }

        //进行右旋：当前结点h的左子节点及其左子节点的左子节点均为红色时，需要右旋
        if(isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        //颜色反转：当前结点h的左右子节点均为红色时，需要颜色反转
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        //返回被修改的新结点
        return h;
    }

    //根据key，从树中找出对应的值
    public Value get(Key key) {
        return get(root,key);
    }

    /*
     * 红黑树如果我们忽略红黑颜色的特殊性来看的话，其实它就是普通的二叉查找树
     * 那么我们这里从树中查找key对应的值的方法其实跟二叉查找树别无二致，这个
     * 应该很好理解
     */
    //从指定的树x中，查找key对应的值
    public Value get(Node x,Key key) {
        if(x==null) {
            return null;
        }

        //比较x结点的键和key的大小
        int cmp = key.compareTo(x.key);
        if(cmp<0){
            return get(x.left,key);
        }else if(cmp>0){
            return get(x.right,key);
        }else {
            return x.value;
        }
    }
}
```

