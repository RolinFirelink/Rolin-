之前我们已经做过了回溯算法的入门学习，但那都只是小试牛刀，接下来，我们就要进行进阶的学习，本节的内容就颇具难度了。

- 组合总和 II

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1bff56f594e4fd9096b5907b2e7ea5a1.png)

这题，就很有难度了，这里难的主要部分在于去重，我们要怎么才能够保证我们最终得到的组合不是重复的呢？我们容易想到使用set集合来进行去重，但这个属实是太慢了，最后我们会在一个例子里直接进行一个时的超，寄了。

回到正题，那我们要如何进行去重呢？

其实我们的基本思路很简单，只要让我们的递归逻辑不会在同一层中选择相同的元素就可以了，这里正确性的证明就不做了，我懒得，反正原理的确就是如此。那么我们要如何完成这个逻辑呢？我们新创建一个布尔类型的数组来帮我们完成这个工作，我们的逻辑很简单，我们每次选择一个数的时候，就将该数对应的坐标代表的布尔数组的值更改为true，回到这一层的时候就将其更换为false。我们每次选择数之前，判断该数是否与前一个树相同，如果相同再进行其前一个布尔类型的值是否为真的判断，若为真则说明前一个数已经被我们选取，现在已经是我们的组合中的一员，我们就不用对其进行任何考虑，但如果没有选择，则说明我们前一个递归已经选择过该数了，此时我们为了去重就不应该重复选择相同的数，此时我们要跳过该值的选择

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE15e531f10d9ba4bf653a0da95ac372a6.png)

那么根据上面的思路，我们可以写入我们的代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<Integer> list = new ArrayList<>();
        boolean[] booleans = new boolean[candidates.length];
        Arrays.sort(candidates);
        dfs(candidates,target,list,booleans,0,0);
        return this.list;
    }

    private void dfs(int[] candidates, int target, List<Integer> list, boolean[] booleans,int sum,int start) {
        if(sum==target){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if(i>0 && candidates[i]==candidates[i-1] && !booleans[i-1]){
                continue;
            }
            if(sum+candidates[i]>target){
                break;
            }
            list.add(candidates[i]);
            booleans[i]=true;
            dfs(candidates,target,list,booleans,sum+candidates[i],i+1);
            list.remove(list.size()-1);
            booleans[i]=false;
        }
    }
}
```

我们这里先对我们的数组进行了排序，这是当然的，如果不进行排序，那我们后面的东西根本玩不转。然后我们的中间的递归逻辑是我们的第一个数不参与去重，这也很好理解，而当我们的总和超越了我们的目标和时，我们就直接停止for循环里的递归，不必再进行查找。

最后我们其实容易知道，我们的这个代码其实的本质逻辑其实就是不要令其选择同一层的重复元素而已，我们之前是用布尔类型的数组来帮助我们的判断的，但实际上，我们也可以不用该数组。我们可以使用最开始传入的坐标来完成我们的判断，请看代码

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<Integer> list = new ArrayList<>();
        Arrays.sort(candidates);
        dfs(candidates,target,list,0,0);
        return this.list;
    }

    private void dfs(int[] candidates, int target, List<Integer> list,int sum,int start) {
        if(sum==target){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if(i>0 && candidates[i]==candidates[i-1] && i>start){
                continue;
            }
            if(sum+candidates[i]>target){
                break;
            }
            list.add(candidates[i]);
            dfs(candidates,target,list,sum+candidates[i],i+1);
            list.remove(list.size()-1);
        }
    }
}
```

我们上面的代码原理在于，如何当我们递归进入新一层时，必然其start也会跟着变化，且最开始的i必然是等于start的，只要i大于start，此时就说明start代表的元素已经被选取，那么此时i和start必然在同一层且i指向的是大于start的元素，此时i还没有被选择，此时我们进行i是否与前一位相同的判断，若相同则跳过，不相同则选取。

这里我们要记住的模板是我们的去重的判断，几乎很多需要去重的题目，其去重过程都可以简化为不在同一层中选择相同的元素来解决，我们实现不同组合中的元素不相同的方法就是使用上面的方法实现的

- 分割回文串

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE55badcde4f3493f811d040ef47a8ab32.png)

本节要求我们要做的事情是分割回文串，我们要做的事情是对我们的该串进行分割，令其返回所有可能形成的回文子串，这题难就难在这里的递归逻辑其实和我们之前的不太一样，我们首先要确定我们的递归停止的逻辑，我们以前的递归停止逻辑都是当我们的集合收集到指定数量的值之后停止，但是我们的这里的集合根本没有指定的大小，那么我们应该怎么办呢？我们注意看可以发现，我们的返回的所有串，其必然都是由原来的串组成的，那么我们就可以设置我们的递归逻辑为我们的起始坐标到达我们的字符串的尾部时，我们就收集结果。接着是我们的递归逻辑，我们的递归逻辑是，每次递归我们寻找回文子串，若不是，则扩大搜索范围，若是，则以该回文子串的结尾在其后继续寻找回文子串。

```
class Solution {
    List<List<String>> list = new ArrayList<>();
    public List<List<String>> partition(String s) {
        List<String> list = new ArrayList<>();
        dfs(s,0,list);
        return this.list;
    }

    private void dfs(String s, int start, List<String> list) {
        if(start>=s.length()){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < s.length(); i++) {
            String s1 = s.substring(start,i+1);
            if(judge(s1)){
                list.add(s1);
            }else {
                continue;
            }
            dfs(s,i+1,list);
            list.remove(list.size()-1);
        }
    }

    private boolean judge(String s1) {
        if(s1.length()==1){
            return true;
        }
        int len = 0,right = s1.length()-1;
        while (len<right){
            if(s1.charAt(len++)!=s1.charAt(right--)){
                return false;
            }
        }
        return true;
    }
}
```

这里我们需要记忆的就是我们这种for循环结合continue的递归模板，用于解决回文串或者是构造我们的一些目标串时很是受用

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE13b6645dc4aa74b1e16678c43ef42ff5.png)

最后我们来看一下我们的标准答案的代码

```
class Solution {
    List<List<String>> lists = new ArrayList<>();
    Deque<String> deque = new LinkedList<>();

    public List<List<String>> partition(String s) {
        backTracking(s, 0);
        return lists;
    }

    private void backTracking(String s, int startIndex) {
        //如果起始位置大于s的大小，说明找到了一组分割方案
        if (startIndex >= s.length()) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            //如果是回文子串，则记录
            if (isPalindrome(s, startIndex, i)) {
                String str = s.substring(startIndex, i + 1);
                deque.addLast(str);
            } else {
                continue;
            }
            //起始位置后移，保证不重复
            backTracking(s, i + 1);
            deque.removeLast();
        }
    }
    //判断是否是回文串
    private boolean isPalindrome(String s, int startIndex, int end) {
        for (int i = startIndex, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
```

- 复原IP地址

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE78f21df7dc25e70e39fa0aea315482dd.png)

然后我们来做复原IP地址的问题，这一题可以说是上一题的再练习，其模板是十分相似的，那么同样我们来做一下这一题，我们这题首先我们要明确的是，我们的字符串长度必须在4和12之间，否则就不可能有任何结果，所以我们首先进行一个正确性的校验。

然后我们的递归的结束条件时当我们的坐标到达我们的结尾时，但是我们就收集结果并结束递归，然后我们的for循环的条件也很简单，首先，如果我们的i和起始点位置相差大于4，那么我们就不用玩了，然后每次我们截取对应的结点作为我们的IP地址的子串，验证其正确性，若正确则将其加入到我们的可变长字符串中，否则就跳过，我们每次加入可变长字符串我们都往其中手动添加一个.，但是这里要注意的是，我们的.的数量不能超过四个，因此我们在开头设置了校验，一旦我们的.的数量超越了4，我们就结束这个方法，因为其必然不符合。最后我们还设置了一个回溯的方法，这里回溯使用的方法是可变长数组的删除方法

最后得到的结果总是会在结尾处带着.的，所以我们再加入我们的结果前还需要对我们的结果做相应的处理，首先我们要去除最后的.，然后我们的字符串是可能出现.有四个，但是内部包含的字符串只有三个的情况的，因此我们还要对字符串进行一个数量判断，只有字符串数量大于3的字符串，我们才会将其加入

```
class Solution {
    List<String> list = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        if(s.length()<4 || s.length()>12){
            return list;
        }
        dfs(s,0,new StringBuffer(),0);
        return list;
    }

    private void dfs(String s, int index, StringBuffer sb,int sum) {
        if(index>=s.length()){
            String s1 = sb.substring(0,sb.length()-1);
            String[] split = s1.split("\\.");
            if(split.length<=3){
                return;
            }
            list.add(s1);
        }
        if(sum>3){
            return;
        }
        for (int i = index; i < s.length(); i++) {
            if(i-index>4){
                break;
            }
            String s1 = s.substring(index,i+1);
            int start = sb.length();
            if(judge(s1)){
                sb.append(s1);
                sb.append('.');
            }else {
                continue;
            }
            int right = sb.length();
            dfs(s,i+1,sb,sum+1);
            sb.delete(start,right);
        }
    }

    private boolean judge(String s) {
        if(s.length()==1){
            return true;
        }
        if(s.charAt(0)=='0'){
            return false;
        }
        int i = Integer.parseInt(s);
        return i >= 0 && i <= 255;
    }
}
```

接着我们来看看官方的回溯模板，其实差不多，不过我们的递归逻辑是加入四个点之后再进行对应的处理和判断，符合条件的我们就加入，而这里是加入三个点之后再对结果进行判断，如果结果符合，就将其加入到集合中。这里我们的递归条件是判断我们加入的逗号的数量，如果等于3就收集，否则就继续递归。我们的递归逻辑是每次判断我们的字符串是否是回文串，若是我们则往其中加入标点，并令我们的记录标点的数量+1然后进行递归，当然移除的时候要加入-1，这里增加和移除标点使用的方法都是字符串的截取函数，其中后者还使用了拼接，所以会导致效率不高。

最后我们可以看到一旦不符合就直接停止循环递归，这是因为一旦这个不符合，那么后续无论怎么增加都是不符合的，的确可以直接停止递归，我们前面用的是continue，其实是不够完美，也是对我们的题目理解不够深刻的体现。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3c20f65f149d7451909999bd856556cf.png)

最后我们也是可以确定我们什么时候用continue，什么时候用break，前者是当我们的结果不符合时继续搜寻可能符合的时候，而后者是无论怎么搜寻都不可能符合的时候

```
class Solution {
    List<String> result = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12) return result; // 算是剪枝了
        backTrack(s, 0, 0);
        return result;
    }

    // startIndex: 搜索的起始位置， pointNum:添加逗点的数量
    private void backTrack(String s, int startIndex, int pointNum) {
        if (pointNum == 3) {// 逗点数量为3时，分隔结束
            // 判断第四段⼦字符串是否合法，如果合法就放进result中
            if (isValid(s,startIndex,s.length()-1)) {
                result.add(s);
            }
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            if (isValid(s, startIndex, i)) {
                s = s.substring(0, i + 1) + "." + s.substring(i + 1);    //在str的后⾯插⼊⼀个逗点
                pointNum++;
                backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2
                pointNum--;// 回溯
                s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点
            } else {
                break;
            }
        }
    }

    // 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法
    private Boolean isValid(String s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s.charAt(start) == '0' && start != end) { // 0开头的数字不合法
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // 如果⼤于255了不合法
                return false;
            }
        }
        return true;
    }
}
```

- 子集

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2a1a1ab39e50b504a0d0eb9abbb8ca47.png)

本题似乎和我们之前的画风不太一样，好像又变简单了些，其实不是的，这题我们是要提升我们的另外一个理解，到底是什么理解，我们接着看就知道了

首先这题怎么做呢？一个简单的想法就是可以递归嵌套for循环，让for循环的条件成为递归的结束条件来完成本体，请看代码

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        for (int i = 0; i <= nums.length; i++) {
            List<Integer> list = new ArrayList<>();
            dfs(nums,0,i,list);
        }
        return this.list;
    }

    private void dfs(int[] nums, int start, int sum, List<Integer> list) {
        if(list.size()==sum){
            this.list.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < nums.length; i++) {
            list.add(nums[i]);
            dfs(nums,i+1,sum,list);
            list.remove(list.size()-1);
        }
    }
}
```

上面就是我们的代码，我们利用for循环作为我们的终止条件，完美地实现了不重复的去重并收集结果。但是这个方法并不具有通用性，而且也不够符合我们的要求，因为一般来说我们是希望我们的方法是能够一次解决问题的，而不是通过一个for循环来实现解决问题。那我们应该要怎么做呢？其实奥秘就隐藏在我们的结束条件里

我们之前的结束条件总是我们的集合到达某一种情况就结束搜索并收集结果，而本题我们求所有的子集，其实在我们的循环递归过程中，就会自然地将所有的结果都遍历完，我们只需要将这些结果全部收集起来就能够得到答案了。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd6cb83af3d78771b733e2a43c0050fbf.png)

那么我们可以写入我们的代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        List<Integer> list = new ArrayList<>();
        dfs(nums,0,list);
        return this.list;
    }

    private void dfs(int[] nums, int start, List<Integer> list) {
        this.list.add(new ArrayList<>(list));
        for (int i = start; i < nums.length; i++) {
            list.add(nums[i]);
            dfs(nums,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

- 子集 II

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfec2420177fd749dff2ab4d3629d592d.png)

接着我们这题就是对我们之前的题目的一个综合运用了，如果我们对之前的题目的知识点掌握地比较深的话，那么这题本质上是不难的。首先，我们看到本题要进行去重，那么我们就需要使用我们的之前的去重模板，我们的递归逻辑就设置成不能令我们的递归选择我们同层中的重复元素，同时别忘了要事先对我们的数组进行排序，不然我们根本就玩不转。然后我们这里要获得其所有的自己，那么我们对其做出的对应改动就是不设置任何的递归条件，每次递归都令其收集结果，这样其就能获得我们所需要的值了

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<Integer> list = new ArrayList<>();
        Arrays.sort(nums);
        dfs(nums,0,list);
        return this.list;
    }

    private void dfs(int[] nums, int start, List<Integer> list) {
        this.list.add(new ArrayList<>(list));
        for (int i = start; i < nums.length; i++) {
            if(i>start && nums[i]==nums[i-1]){
                continue;
            }else {
                list.add(nums[i]);
                dfs(nums,i+1,list);
                list.remove(list.size()-1);
            }
        }
    }
}
```

最后我们来看看我们的递归分析图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf8fa22293efdc41ab09d14b34970fb2d.png)

- 递增子序列

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb659d89b7b80a49fbbc4bde7ce0be6f0.png)

我们解开这题的经典想法会是利用树层去重但是，我们的树层去重有一个前提，那就是我们的数组一定要是排序过的，而我们这里是不允许对数组自身进行排序的，所以我们这里不可以使用树层的去重法，一用就错。这件事也提醒我们，不要套模板套爽了，就遇见什么类似的题目就二话不说直接套模板，一定要好好复习分析下题目本身是否可以套模板。

那么我们要如何解决这题呢？我们先用我们的递归做法来做，首先我们要确定我们的递归结束情况，我们希望当我们的集合里有两个及以上元素时，我们就收集结果。其次，我们希望我们的路径收集的集合总是比前面的大的，所以我们判断我们的路径中的最后一个元素是否有元素，如果没有则直接添加，如果有我们就取出其最后一个与当前的元素做比较，如果当前的比较小，那么就跳过当前的选取，反之则选取

那么我们可以构造出我们的没有进行去重的算法代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer> list = new ArrayList<>();
        dfs(nums,0,list);
        return this.list;
    }

    private void dfs(int[] nums, int start, List<Integer> list) {
        if(list.size()>1){
            this.list.add(new ArrayList<>(list));
        }
        for (int i = start; i < nums.length; i++) {
            if(list.size()!=0 && nums[i]<list.get(list.size()-1)){
                continue;
            }
            list.add(nums[i]);
            dfs(nums,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

最后我们要解决的问题是，我们要怎么去重才能保证我们不会选取重复的元素？这里就要使用到我们的哈希来帮助我们去重了，首先我们要确定我们要去除的是什么情况下的元素，我们可以通过一个样例来加深理解

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE692451a4de8321b80b4b3bfb9ee3873e.png)

可以看到，我们的实际结果比预期的结果多了两个1、1的集合，这两个集合产生的原因是一位我们的1在第一次循环时进行了选取，而后面我们的1又和最后一个1进行了选取，最终导致我们的答案里出现了三个1。那么我们去重时，我们的一个简单想法就是，我们希望我们一旦选择过一次1，我们后续的选择中就不要再次选择同样的元素了，注意，这里是同一层的逻辑，也就是说，只有在同一层中我们要遵从这样的逻辑，不同层的结果不会互相影响。因为实际上我们的集合中还有1、1、1这样的组合，因此我们不可以令其变成一旦选取了1，那么后续就不会再选取1的情况

要实现这种想法，我们可以利用我们的哈希表进行去重，每次选取元素时，我们就判断该元素是否已经被选取，若已经被选取，那么我们就跳过该元素的选取，反之则选取。同时，由于我们的逻辑只用于同一层中，因此我们在每层中都创建一个哈希表并进行去重，这样就能达到我们想要的每一层进行独立的逻辑去重的效果

最后我们可以构造我们的代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer> list = new ArrayList<>();
        dfs(nums,0,list);
        return this.list;
    }

    private void dfs(int[] nums, int start, List<Integer> list) {
        if(list.size()>1){
            this.list.add(new ArrayList<>(list));
        }
        Set<Integer> set = new HashSet<>();
        for (int i = start; i < nums.length; i++) {
            if(!list.isEmpty() && nums[i]<list.get(list.size()-1) || set.contains(nums[i])){
                continue;
            }
            set.add(nums[i]);
            list.add(nums[i]);
            dfs(nums,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

最后我们值得一提的是，本题中限定了数组的范围是从-100到100，因此我们可以手动构建一个数组作为哈希表进行去重，这样还能提高一层效率，因为java中提供的哈希表比较慢，不太好使。那么最后我们可以写入我们的代码如下

```
class Solution {
    List<List<Integer>> list = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer> list = new ArrayList<>();
        dfs(nums,0,list);
        return this.list;
    }

    private void dfs(int[] nums, int start, List<Integer> list) {
        if(list.size()>1){
            this.list.add(new ArrayList<>(list));
        }
        int[] arr = new int[201];
        for (int i = start; i < nums.length; i++) { 
            if(list.size()!=0 && nums[i]<list.get(list.size()-1)){
                continue;
            }else if(arr[nums[i]+100]==1){
                continue;
            }
            arr[nums[i]+100]=1;
            list.add(nums[i]);
            dfs(nums,i+1,list);
            list.remove(list.size()-1);
        }
    }
}
```

最后我们值得一提的是，我们这里的每层使用哈希表去重的逻辑所完成的功用是可以防止在同一层中我们再次选取相同的元素，其具体的作用过程可以看图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6a1aab3bd88319191bcafceeaac16631.png)

最后，哈希表去重法我们只用过这么一回，而且我们也只用过哈希表，一般是哈希表组合每层递归达到固定层去重的目的，因此如果我们要使用这种逻辑，我们要注意的是，要用就只用哈希表来完成，别自己耍什么大聪明拿其他的来用，记住我们这套哈希去重的模板，每层创建哈希表，且不会刻意移除哈希表内的元素，其他情况下我们该用之前的递归模板还是用之前的递归模板就行了。