那么我们现在来实现最后一个功能，也就是用户充值，我们充值的逻辑很简单，充值后判断对应的用户余额是否大于0，若不大于0则保持冻结状态，若大于0则修改其状态为正常

我们这里就不用实现Dao层了，直接实现Service层就可以了，为什么？因为我们这里做的无非就是修改的操作，而Dao层我们之前是有写好了的现成能用的，所以我们直接在Service层里调用我们所需要的Dao层就完了

那么首先我们要解决一个问题，那就是我们要如何查找我们需要的用户对象呢？因为我们的充值界面是只能输入金额的，一个简单想法就是我们用编号来找，就像我们之前学习过的一样，在充值界面里其实还传入了用户编号，只是用户看不到而已

但是我们这里可以用更加简便的方法，直接获取用户的编号进行查找，不必用隐藏的方式偷偷传编号，因为通过代码分析我们能知道其实他是会将对应的用户对象也一并传过来的，这是怎么做到的呢？我们先看分析下

我们首先进入UserChargeViewCtrl类中，可以看到其中有User属性，那么这个User属性肯定是会传过来的，问题在于这个User对象到底传过来的是不是null，那么这个User对象是从哪里传过来的呢？其实是从UserViewCtrl类中传过来的，这个界面其实就是对应的用户管理的界面，我们来看看其源码

```javascript
@FXML
private void chargeView() {
    try {
        User user = this.userTableView.getSelectionModel().getSelectedItem();
        if (user == null){
            Alerts.warning("未选择","请先选择要充值的数据");
            return;
        }
        initChargeStage(user);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

可以看到这里调用了initChargeStage方法并传入了user对象，我们点进去该方法里看看

```javascript
/*
    初始化充值stage
 */
private void initChargeStage(User user) throws IOException {
    FXMLLoader loader = new FXMLLoader();
    loader.setLocation(App.class.getResource("/com/bjpowernode/module/user/UserChargeView.fxml"));
    StackPane target = (StackPane) loader.load();
    Scene scene = new Scene(target);

    Stage stage = new Stage();//创建舞台；
    UserChargeViewCtrl controller = (UserChargeViewCtrl)loader.getController();
    controller.setStage(stage);
    controller.setUser(user);
    controller.setUserTableView(userTableView);
    stage.setHeight(500);
    stage.setWidth(400);
    //设置窗口图标
    stage.getIcons().add(new Image("icon.png"));
    stage.initModality(Modality.APPLICATION_MODAL);
    stage.setScene(scene); //将场景载入舞台；
    stage.show(); //显示窗口；
}
```

重点在第11行和13行代码，我们看到这里先获得了UserChargeViewCtrl对象，然后传入了user对象进去，那么我们的controller层里的User属性就必然不为空，其为我们所传入的User对象，那么我们就可以直接通过这个传入的对象获取对应的编号信息，不需要通过拐弯抹角的方式来获得

理解了这些之后，我们先来实现Service层的代码，先提供接口方法

```javascript
User charge(User user, BigDecimal money);
```

这里之所以填写User为返回值是因为我们还需要修改了借阅数据之后，我们总之要更新界面里的借阅数据的，我们返回修改后的User对象，便于我们在controller层里进行展示的user对象的替换

当然，实际上我们也可以不返回这个User对象，而是把这些事情在controller层里实现，但是我们一般不这样做，因为这里毕竟涉及到了逻辑运算，逻辑运算的事我们交给service层去做，Dao层做增删改查，而controller层一般只负责调用各种方法，不做具体运算

实现方法

```javascript
/**
 * 用户充值
 * @param user
 * @param money
 * @return
 */
@Override
public User charge(User user, BigDecimal money) {
    //计算充值之后的余额
    BigDecimal sum = money.add(user.getMoney());
    //判断充值后的余额是否大于0
    if(BigDecimal.ZERO.compareTo(sum) < 0){
        //修改用户状态
        user.setStatus(Constant.USER_OK);
    }

    user.setMoney(sum);
    //更新用户
    userDao.update(user);

    //修改借阅文件中的用户数据
    List<Lend> lendList = lendDao.select(null);

    for (int i = 0; i < lendList.size(); i++) {
        Lend lend = lendList.get(i);
        if(lend.getUser().getId() == user.getId()){
            lend.setUser(user);
            lendDao.update(lend);
            break;
        }
    }
    return user;
}
```

这里我们更新了两个数据，一个是用户类的数据，另外一个是借阅管理的数据，这类我们两个数据的坏处就显现出来了，就是我们要更新两次，很麻烦，后续我们学习了数据库就没有这个问题了

最后我们实现controller类的方法

```javascript
/*
    充值
 */
@FXML
private void charge() {
    try {
        //本次充值的金额
        BigDecimal money = new BigDecimal(moneyField.getText());
        User chargeUser = userService.charge(user,money);
        user = chargeUser;

        userTableView.refresh();
        stage.close();
        Alerts.success("成功", "操作成功");
    } catch (Exception e) {
        e.printStackTrace();
        Alerts.error("失败","操作失败");
    }
}
```

这里就是简单地调用了service方法并且将新的对象返回给了展示台



总结

那么到此为止，我们的图书管理系统的代码就算是写完了，我们现在来做一个总结

1.我们一定要用上代码分层的思想来构建我们的系统

2.对于普遍使用的方法，可以构建工具类来完成我们的需求

3.尽量使用传入参数在后，比较对象在前的方式来构建判断语句，这样能有效避免空指针异常

4.三层每一层都有各自的分工，Dao层一般只做增删改查，service层实现更加复杂的业务逻辑，而controller层一般只负责调用service层

5.对自己的写的程序要进行测试，尽量令其少出现bug