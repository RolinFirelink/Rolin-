本章节我们来学习MyBatis的多表操作，我们之前学习的都是十分简单的数据查询，随着业务的深入，我们必然是要使用到较为深入的多表操作的，因此我们学习多表操作。

- 多表模型的介绍

我们不妨先来复习下多表模型，免得大家忘了。在多表模型中，有一对一、一对多和多对多三种。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa3ae3d5821a6a656978486f4008aa6d0.png)

- 一对一的数据准备

首先我们来看看一对一的情况，其模型当然是经典的人和身份证

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1ad07dcaaafe8d6d8f041f44ad943686.png)

然后我们来看看其数据准备，我们先做mysql的，其代码如下

```
DROP DATABASE db2;

    CREATE DATABASE db2;

    USE db2;

    CREATE TABLE person(
    id INT PRIMARY KEY AUTO_INCREMENT,
    NAME VARCHAR(20),
    age INT
    );
    INSERT INTO person VALUES (NULL,'张三',23);
    INSERT INTO person VALUES (NULL,'李四',24);
    INSERT INTO person VALUES (NULL,'王五',25);

    CREATE TABLE card(
    id INT PRIMARY KEY AUTO_INCREMENT,
    number VARCHAR(30),
    pid INT,
    CONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)
    );
    INSERT INTO card VALUES (NULL,'12345',1);
    INSERT INTO card VALUES (NULL,'23456',2);
    INSERT INTO card VALUES (NULL,'34567',3);
```

然后我们更改一下我们的对应的映射配置文件和核心配置文件就完了，还有创建对应的person类和card类，card类中包含有person类当成员变量，我们这里假设我们就已经搞定了

- 一对一的功能实现

我们首先在对应的文件夹下创建对应的xml文件，然后引入对应的映射配置文件的固定代码，接着我们在核心配置文件上引入映射配置文件的路径。

```
<!--mappers引入映射配置文件-->
<mappers>
    <mapper resource="com/itheima/one_to_one/OneToOneMapper.xml"/>
</mappers>
```

然后我们在table01文件夹创建对应的接口并写入对应的方法

```
public interface OneToOneMapper {
    //查询全部
    public abstract List<Card> selectAll();
}
```

那么我们现在的目标是希望查找处所有的身份证，然后找出这些身份证所对应的人，如果是在sql中，我们容易编写出这样的语句

```
SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.`pid`=p.`id`;
```

我们这里之所以不选择展示全部的原因是如果我们选择展示全部那么会有多的一列id会被寻找到，而这份id并没有什么作用，还妨碍我们将数据封装到对象中，因此我们的选择只展示我们所需要的一部分。这里我们展示的前两列的内容是我们身份证的数据，而后两列的内容则是对应的人的数据。

那么我们将这行语句放到我们的映射配置文件里的查询语句中，由于此时我们的要封装的对象涉及到了两个，一个是身份证，一个是人，此时再用resultType就不适合了，因为这玩意只适合封装一个对象，如果我们要进行多表操作时对象的封装，此时我们要改用resultMap属性，其是在select标签下的属性，该属性可以用于给对应的多表对象封装数据。然后我们额外创建新的resultMap标签，其下有id和type属性，前者是唯一标识，我们在select和resultMap上的id属性都应该要填写一致的，这样select才能正确使用到resultMap。后者则是我们的数据要封装到的数据类型，我们这里封装的是身份证，所以我们填入card，代表card类型。

然后在resultMap中我们如何封装我们的数据呢，我们要写入id的子标签，这个子标签有两个属性，column属性和property属性，后者用于指定对象中要封装数据的成员变量，前者表示要封装的数据在数据库中的列名，用于取出对应的列名并封装，这个可以写入多个，以给多个成员变量赋值。但是要注意的是，只有主键id的列我们采用id标签，其他应该采用result标签，其下的方法是一样的，用法也一样，无非是标签不同罢了

我们知道在Card中包含有Person引用变量，如果我们想要给对象中的另一个对象赋值的话，那么就不该还是用上面的方法，应该使用association标签，其可以配置被包含对象的映射关系，其下有两个属性，property和javaType，前者要填入被包含对象的变量名，后者要填入其对应的数据类型。我们也是通过id标签和result标签进行的赋值的

那么最终我们可以写入我们的配置文件的代码如下

```
<?xml version="1.0" encoding="UTF-8" ?>
<!--MyBatis的DTD约束-->
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.itheima.table01.OneToOneMapper">
    <!--配置字段和实体对象属性的映射关系-->
    <resultMap id="oneToOne" type="card">
        <id column="cid" property="id"/>
        <result column="number" property="number"/>

        <!--
            association：配置被包含对象的映射关系
            property：被包含对象的变量名
            javaType：被包含对象的数据类型
        -->
        <association property="p" javaType="person">
            <id column="pid" property="id"/>
            <result column="name" property="name"/>
            <result column="age" property="age"/>
        </association>
    </resultMap>

    <select id="selectAll" resultMap="oneToOne">
        SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id;
    </select>
</mapper>
```

然后我们写入测试文件的代码如下

```
@Test
public void selectAll() throws Exception{
    InputStream is = Resources.getResourceAsStream("MyBatisConfig.xml");

    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

    SqlSession sqlSession = sqlSessionFactory.openSession(true);

    //获取OneToOneMapper接口的实现类对象
    OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);

    List<Card> list = mapper.selectAll();

    for (Card c:list) {
        System.out.println(c);
    }

    sqlSession.close();
    is.close();
}
```

实际测试也没有问题，此时就说明我们的功能已经完成了。

最后我们可以再做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdcf33bbb1a59d8dc3f7150c2321feb10.png)

- 一对多的数据准备

那么接着我们来学习一对多的多表操作，其最经典的模型莫过于是学生和班级，一个班级可以有多个学生，多个学生可以是一个班级的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9dfd0ddeb178c3cbb6fd421f670b7815.png)

我们首先要做一些对应的环境准备，先来看看创造数据sql语句

```
CREATE TABLE classes(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20)
);
INSERT INTO classes VALUES (NULL,'黑马一班');
INSERT INTO classes VALUES (NULL,'黑马二班');


CREATE TABLE student(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(30),
age INT,
cid INT,
CONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)
);
INSERT INTO student VALUES (NULL,'张三',23,1);
INSERT INTO student VALUES (NULL,'李四',24,1);
INSERT INTO student VALUES (NULL,'王五',25,2);
INSERT INTO student VALUES (NULL,'赵六',26,2);
```

然后是一些在idea上的对应准备，这里就省略了，反正无非也就是创建对应的班级类和学生类，班级类中有多个学生类，用集合保存

- 一对多的功能实现

接着我们来实现我们的一对多的功能，首先我们还是先构造出我们的查询的sql语句，因为我们的查询的语句比较复杂，所以我们先构造出来，这样不容易犯错，那么我们可以构造其语句如下

```
SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.`id`=s.`cid`;
```

构造的基本思路和上题差不多，这里不再赘述。然后我们创建一个配置文件并在核心配置文件中将其映射，接着我们同样进入对应的封装语句的构造，不过这里要注意的是，我们这里由于是一对多的操作，因此给被包含对象赋值时不可以使用association标签，这标签是专为一对一准备的。此时我们应该要使用collection标签，其可以用于一对多的使用，其下有两个属性property和ofType，前者存放被包含对象的变量名，后者存放集合内部存放的对象的数据类型，其实和前面的差不多，那么我们可以构造其代码如下

```
<?xml version="1.0" encoding="UTF-8" ?>
<!--MyBatis的DTD约束-->
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.itheima.table02.OneToManyMapper">
    <!--配置字段和实体对象属性的映射关系-->
    <resultMap id="oneToMany" type="classes">
        <id column="cid" property="id"/>
        <result column="cname" property="name"/>

        <!--
            collection:配置被包含的集合对象的映射关系
            property:被包含的对象的变量名
            ofType:被包含对象的实际参数类型
        -->
        <collection property="students" ofType="student">
            <id column="sid" property="id"/>
            <result column="sname" property="name"/>
            <result column="sage" property="age"/>
        </collection>
    </resultMap>

    <select id="selectAll" resultMap="oneToMany">
        SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid;
    </select>
</mapper>


```

当然我们不要忘了在核心配置文件上配置我们对应的映射配置文件的路径，不然我们的程序是无法运行的。同时要创造对应的接口以用于动态生成实现类

```
package com.itheima.table02;

import com.itheima.bean.Classes;

import java.util.List;

public interface OneToManyMapper {
    //查询全部
    public abstract List<Classes> selectAll();
}
```

最后我们可以做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE27f76f05f11c571c9b0fcd222cc0628c.png)

- 多对多的数据准备

多对多的最经典模型莫过于是学生和课程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE18790018e45cbc69fa5f20aad4431911.png)

我们首先要做多对多的数据准备，先来看看我们的sql语句

```
CREATE TABLE course(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20)
);
INSERT INTO course VALUES (NULL,'语文');
INSERT INTO course VALUES (NULL,'数学');


CREATE TABLE stu_cr(
id INT PRIMARY KEY AUTO_INCREMENT,
sid INT,
cid INT,
CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),
CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)
);
INSERT INTO stu_cr VALUES (NULL,1,1);
INSERT INTO stu_cr VALUES (NULL,1,2);
INSERT INTO stu_cr VALUES (NULL,2,1);
INSERT INTO stu_cr VALUES (NULL,2,2);
```

然后是经典创建对应的包和类了，这里就不赘述了。不过我们这里值得一提的是我们并没有创建中间表的对象，这是为什么呢？这是因为我们只在这里演示查询操作，因此我们没有必要去保存中间表对象，所以我们不创造，主要还是贪方便。像之前的外键约束的名称那些的实体类我们也是没有提供的，这个了解下就行了

- 多对多的功能实现

在实现其功能之前，我们需要将我们的学生实体类里添加这么一行代码

```
private List<Course> courses;  //学生所选择的课程集合
```

就是往里面添加了一个课程集合，因为学生是包含有课程集合的，我们往里面添加这行代码自然也无可厚非

首先我们创造一个对应的映射配置文件，然后我们在核心配置文件中添加该映射配置文件的地址。

然后我们创建对应的接口类并写入对应的代码

```
package com.itheima.table03;

import com.itheima.bean.Student;

import java.util.List;

public interface ManyToManyMapper {
    //查询全部
    public abstract List<Student> selectAll();
}
```

然后我们就开始写入我们的对应的配置文件的代码了，首先我们要创造我们对应的sql语句

```
SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id;
```

我们这里特别提一下我们是怎么创建我们的对应的sql语句的，首先我们要确定的当然是查询的总体代码，我们先查询出来，至于显示什么，怎么显示我们先按下不表，此时我们容易构造出FROM及其后面的语句，然后我们发现展示的数据又多又杂乱，不适合我们封装数据，此时我们再选择性展示数据，我们从中选择我们要封装的数据，先从第一个对象也就是学生开始，拿下两列，再拿下第一个对象里的包含对象，也就是课程对象，在表里对标的是选择展示对应的三列，用于封装课程对象，给过长的名字进行对应的命名，最后我们就会得到一个我们想要的便于封装的数据展示

那么我们可以写入我们的配置文件的代码如下

```
<?xml version="1.0" encoding="UTF-8" ?>
<!--MyBatis的DTD约束-->
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.itheima.table03.ManyToManyMapper">
    <resultMap id="manyToMany" type="student">
        <id column="sid" property="id"/>
        <result column="sname" property="name"/>
        <result column="sage" property="age"/>
        <collection property="courses" ofType="course">
            <id column="cid" property="id"/>
            <result column="cname" property="name"/>
        </collection>
    </resultMap>

    <select id="selectAll" resultMap="manyToMany">
        SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id;
    </select>
</mapper>
```

其实我们可以看到多对多的方式和一对一的方式差不多，只不过是查询语句变了些而已。

最后我们做个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdc01f7247fd24034cce642f981c5cf65.png)

- 多表操作的小结

最后我们可以做一个多表操作的小结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEacf5c38d0ac63a10babeeed42f6a693c.png)

