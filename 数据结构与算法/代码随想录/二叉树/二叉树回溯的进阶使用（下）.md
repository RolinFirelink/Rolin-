- 删除二叉搜索树中的结点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa63d283972c0ddbe36eb20cee81c23b5.png)

对于这一题，我们的做法是要分情况讨论，具体分的情况如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE77b4e6c56653769c4bc968409691b430.png)

这五种情况就是囊括了我们删除结点时能遇到的所有情况了，对于第五种情况，可能光看文字可能会有点难以理解，我们来看个动图演示吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE0a93153e566b78065b7313163eae96db.gif)

那么最终我们可以写入我们的代码如下

```
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return root;
        if (root.val == key) {
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            } else {
                TreeNode cur = root.right;
                while (cur.left != null) {
                    cur = cur.left;
                }
                cur.left = root.left;
                root = root.right;
                return root;
            }
        }
        if (root.val > key) root.left = deleteNode(root.left, key);
        if (root.val < key) root.right = deleteNode(root.right, key);
        return root;
    }
}
```

可以看到我们这里对我们的情况进行了分类讨论，并且进行了分类处理，利用其二叉搜索树的特性来决定我们的递归的走向

但是实际上，二叉搜索树不止一种，我们实际上还有另外一种处理本题的第五种情况的方式，就是将当前结点的值改为右子树的最左子树的结点值，然后将右子树的最左子树删除。根据这个思路，我们可以写入我们的代码如下

```
class Solution {
    int val;
    public TreeNode deleteNode(TreeNode root, int key) {
        val=key;
        return dfs(root);
    }

    private TreeNode dfs(TreeNode root) {
        if(root==null){
            return null;
        }
        if(root.val<val){
            root.right=dfs(root.right);
        }else if(root.val>val){
            root.left=dfs(root.left);
        }else {
            if(root.left==null && root.right==null){
                return null;
            }else if(root.left==null){
                return root.right;
            }else if(root.right==null){
                return root.left;
            }else {
                TreeNode right = root.right;
                while (right.left!=null){
                    right=right.left;
                }
                root.val= right.val;
                int num = val;
                val= root.val;
                root.right=dfs(root.right);
                val=num;
            }
        }
        return root;
    }
}
```

可以看到我们这里处理第五种情况时将对应结点删除的方式就是再次调用原函数就完了，同时为了让其能够寻找对应的值进行了一个值的改变和回调，如果我们采用传值的方式来进行递归的话，都不用进行值的特殊处理。如下所示

```
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        root = delete(root,key);
        return root;
    }

    private TreeNode delete(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val > key) {
            root.left = delete(root.left,key);
        } else if (root.val < key) {
            root.right = delete(root.right,key);
        } else {
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            TreeNode tmp = root.right;
            while (tmp.left != null) {
                tmp = tmp.left;
            }
            root.val = tmp.val;
            root.right = delete(root.right,tmp.val);
        }
        return root;
    }
}
```

- 修建二叉搜索树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5ed3ae82f7d3e7e85740c68b783288c7.png)

我们这里一题简单来说就是删除的题目的进阶版本，以前我们是删除对应的结点，这回我们是要将不在范围内的结点删除掉而已。我们的一个简单想法就是遇到不在范围内的结点我们就返回null，否则就继续搜索，这个想法虽然很简单，但这是行不通的，具体请看下面的例子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9af9b4d2448e237f2b1f581f3fc06d97.png)

如果我们是遇上不符合的内容就直接返回的话，那么最终我们的结点就是3-4，啥都没了，这肯定是不符合要求的。

其实我们不需要对我们的所有结点进行修改，如果我们遇上了不符合的结点，我们就直接跳过这个节点，将其子节点赋予给其上一个结点就行了。换言之，我们做本题并不需要我们的去做手动的删除，我们只需要改变树中结点的指向，令所有不符合的结点不被指向就行了。

那么按照这个思路我们可以构造我们的代码如下

```
class Solution {
    int low,high;
    public TreeNode trimBST(TreeNode root, int low, int high) {
        this.low=low;this.high=high;
        return dfs(root);
    }

    private TreeNode dfs(TreeNode root) {
        if(root==null){
            return null;
        }
        if(root.val<low){
            return dfs(root.right);
        }
        if(root.val>high){
            return dfs(root.left);
        }
        root.left=dfs(root.left);
        root.right=dfs(root.right);
        return root;
    }
}
```

我们这里的递归逻辑是先对结点为空时，我们就令其返回空，这是停止条件，若结点不属于边界返回内，我们就令其返回边界值内的结点，所以我们这里的递归是当前结点比low小我们就递归处理右子树，反之则是左子树。最后如果属于在其中，我们就不做什么处理，直接递归处理器左右子树，最后返回该结点

- 将有序数组转换为二叉搜索树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbfdc16022ff5be759f2faac4d25575e1.png)

我们这一题要是想不明白那就寄了，要是想明白了那其实不难。我们这题本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。我们只要确定我们的递归处理的逻辑就可以实现对所有的结点进行一个创建的过程了，我们这里有两种递归方式，一种是左闭右闭一种是左闭右开，每次我们都是先令其获得中间的结点，然后左右分别递归获得对应的结点就行了，左闭右闭和左闭右开的方式分别对应的是每次递归处理时选择的结点不同，其最大的不同就在于数组长度为偶数时，决定我们选择左边的结点来创建还是右边的结点来创建，但无论是那种方式，都是可以通过的，因为我们的二叉平衡搜索树本身就是不止一个的

那么我们可以写入我们的左闭右闭的代码如下

```
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(null,nums,0,nums.length-1);
    }

    private TreeNode dfs(TreeNode node, int[] nums, int len, int right) {
        if(len>right){
            return null;
        }
        int mid = len+(right-len)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left=dfs(root.left,nums,len,mid-1);
        root.right=dfs(root.right,nums,mid+1,right);
        return root;
    }
}
```

然后我们写入左闭右开的代码如下

```
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums,0,nums.length);
    }

    private TreeNode dfs(int[] nums, int len, int right) {
        if(len>=right){
            return null;
        }
        int mid = len+(right-len)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left=dfs(nums,len,mid);
        root.right=dfs(nums,mid+1,right);
        return root;
    }
}
```

- 把二叉搜索树转换为累加树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb48cd2efe44a9511f5185a99aafac40f.png)

这题我们的经典想法就是利用回溯来做，先获得左右然后再处理中间结点，然而这种思路就寄了，因为这里的递归逻辑其实是先处理右子树，再处理中间结点，最后再处理左子树。我们用回溯压根做不到这样的，如果我们用参数传参来进行递归的话，那又不知道怎么样将值传到我们的递归的左子树中去，就突出一个痛苦，那我们应该要怎么办呢？答案是利用成员变量，我们这里只能使用成员变量来承接我们的值，来实现我们的右中左的递归思路，其他的方法都做不到（反正我是试不出来）

那么我们可以写入我们的递归代码如下

```
class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        dfs(root);
        return root;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        dfs(root.right);
        sum+= root.val;
        root.val=sum;
        dfs(root.left);
    }
}
```

那么到此为止，我们的二叉树的题目就算是全部学习完了，可喜可贺可喜可贺

- 面试题，后继者

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEadd0d47e9c68db3035d7a65bd917eff9.png)

最后我们来做一道有关于二叉树的面试题，关于这题，我只能说这位更是重量级