那么从这一节开始我们来开始实现图书管理这一章节的内容

我们先来实现初始化图书数据，我们此前写过InitDataUtil这样一个工具类，在这个工具类里我们写过初始化用户数据的操作，那么我们接着就要用同样的方法来初始化图书数据

```javascript
/**
 * 初始化图书数据
 */
public static void initBook(List<Book> bookList){
    ObjectOutputStream oos = null;
    //创建相关文件夹
    File directory = new File("book/");
    File file = new File(PathConstant.BOOK_PATH);
    //判断文件夹是否存在
    if(!directory.exists()){
        directory.mkdir();
    }
    //判断文件是否存在
    if(!file.exists()){
        try {
            file.createNewFile();
            List<Book> list = new ArrayList<>();
            if(bookList == null){
                list.add(new Book(1,"java入门","张三",Constant.TYPE_COMPUTER,"123-1","机械工业出版社",Constant.STATUS_STORAGE));
            }else {
                list = bookList;
            }

            //利用对象输出流将list数据写出到文件中
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.BOOK_PATH));
            oos.writeObject(list);
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException();
        }finally {
            if(oos!=null){
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
```

这里我们提前在地址常量类中添加了Book的地址，因此这里可以直接调用常量的地址，但是这样还有一个问题，就是我们发现这个方法和我们之前初始化用户数据的方法非常像，那我们能不能将这两个方法合并到一块去？让我们的程序启动的时候只执行一块代码就能够初始化两个不同的模块？说干就干，我们可以组合两个方法如下

```javascript
public class InitDataUtil {
    //提供主方法
    public static void main(String[] args) {
        //初始化用户数据
        List<User> userList = new ArrayList<>();
        userList.add(new User(1001,"张大虎",Constant.USER_OK,BigDecimal.TEN));
        initData(PathConstant.USER_PATH,userList);

        //初始化图书数据
        List<Book> bookList = new ArrayList<>();
        bookList.add(new Book(1,"java入门","张三",Constant.TYPE_COMPUTER,"123-1","机械工业出版社",Constant.STATUS_STORAGE));
        initData(PathConstant.BOOK_PATH,bookList);
    }

    /**
     * 初始化数据
     */
    public static void initData(String path,List<?> list){
        ObjectOutputStream oos = null;
        //创建相关文件夹，用/来分割字符串，获得前面的地址，加上/即是我们所需要的字符串
        File directory = new File(path.split("/")[0] + "/");
        //创建相关文件，直接将对应地址传入
        File file = new File(path);
        //判断文件夹是否存在
        if(!directory.exists()){
            directory.mkdir();
        }
        //若文件不存在则创建文件
        if(!file.exists()){
            try {
                file.createNewFile();//创建文件
                //利用对象输出流将list数据写出到文件中
                oos = new ObjectOutputStream(new FileOutputStream(path));
                oos.writeObject(list);
                oos.flush();
            } catch (IOException e) {
                e.printStackTrace();
                throw new RuntimeException();
            }finally {
                if(oos!=null){
                    try {
                        oos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

可以看到我们这里将两个方法修改为一个方法，然后此时我们的方法就比较具有通用性了，这时我们只要在提供的主方法里提供地址和对应的集合就可以了

这里我们提供了地址，对地址进行了切割和拼接获得了我们想要的地址，其次是我们的这里使用了泛型，由于我们这里的方法是要初始化多个模块的，因此泛型是不能固定的，于是我们的给予泛型?，代表一个通配符，意味着这个集合里存什么都可以



图书查询操作的实现

接着我们来实现图书查询的操作，同样要利用代码分层的思想，我们先从Dao层开始，由于我们的换了一个模块了，因此我们要新添加一个接口类，我们称之为BookDao，在里面提供查询方法

```javascript
public interface BookDao {
    List<Book> select(Book book);
}
```

查询方法当然需要查询的对象，一般来说我们查询可以通过名字和ID进行查询，所以理论上我们只要传名字和ID就可以了，但是我们这里选择传一个Book对象，这是为什么呢？因为我们的程序可能后续还有升级操作，以后可能还需要用到书籍的其他信息进行查询，到时候要改的话又要把方法改来改去，太麻烦，我们干脆传入一个Book对象，这样有利于我们的以后的拓展，而且因为可以满足我们现在的需求

然后同样我们创建一个实现类称之为BookDaoImpl，实现接口内部的方法，写入代码如下

```javascript
/**
 * 查询
 * @param book
 * @return
 */
@Override
public List<Book> select(Book book) {
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.BOOK_PATH));
        List<Book> list = (List<Book>) ois.readObject();
        if(list!=null){
            if(book==null || ("".equals(book.getBookName()) && "".equals(book.getIsbn()))){
                //若传入的book为空或者该book对象不存在名字和编号，则说明要查询全部数据，直接返回从硬盘中读取的集合对象到内存中
                return list;
            }else {
                //代码执行到此说明要执行条件查询，先创建一个集合用于存储符合条件的图书对象
                List<Book> conditionList = new ArrayList<>();
                //条件查询
                if(!"".equals(book.getBookName())) {
                    //根据图书名称查询，若书名相同则将该对象直接添加到集合中并将该集合赋给conditionList，这里利用了Stream流
                    conditionList = list.stream().filter(b -> b.getBookName().equals(book.getBookName())).collect(Collectors.toList());
                }
                if(!"".equals(book.getIsbn())) {
                    //根据Isbn编号查询，若书名相同则将该对象直接添加到集合中并将该集合赋给conditionList，这里利用了Stream流
                    conditionList = list.stream().filter(b -> b.getIsbn().equals(book.getIsbn())).collect(Collectors.toList());
                }
                //返回符合条件的集合
                return conditionList;
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    //如果硬盘中的集合为空，说明硬盘中啥都没存，此时创建一个新的空集合返回给界面
    return new ArrayList<>();
}
```

那么到此我们的Dao层就实现完了，接着我们来实现Service层

创建新接口

```javascript
public interface BookService {
    List<Book> select(Book book);
}
```

实现新接口

```javascript
public class BookServiceImpl implements BookService {

    private BookDao bookDao = new BookDaoImpl();

    @Override
    public List<Book> select(Book book) {
        return bookDao.select(book);
    }
}
```

最后我们来实现controller层，controller层在module包下的BookViewCtrl类下，我们实现其代码如下

```javascript
ObservableList<Book> books = FXCollections.observableArrayList();

private BookService bookService = new BookServiceImpl();

@Override
public void initialize(URL location, ResourceBundle resources) {

    //查询
    List<Book> bookList = bookService.select(null);
    books.addAll(bookList);
    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    c2.setCellValueFactory(new PropertyValueFactory<>("bookName"));
    c3.setCellValueFactory(new PropertyValueFactory<>("author"));
    c4.setCellValueFactory(new PropertyValueFactory<>("type"));
    c5.setCellValueFactory(new PropertyValueFactory<>("isbn"));
    c6.setCellValueFactory(new PropertyValueFactory<>("publisher"));
    c7.setCellValueFactory(new PropertyValueFactory<>("status"));
    bookTableView.setItems(books);

}
```

我们这里先给controller层提供对应的service层的成员变量，然后我们在对应的方法里调用查询方法，由于刚开始我们查询时必然是想要展示所有数据的，因此我们这里传入null，就意味着其会查找所有数据，然后返回一个集合对象，我们将这个集合对象里的图书对象全部添加到对应的可观察对象ObservableList<Book>就可以在界面中正常展示我们所需要的集合了



图书条件查询

刚刚我们实现了图书查询，那么我们在图书查询的基础之上来实现图书条件查询

先进入BookView.fxml文件中找到查询对应的界面代码

```javascript
<Button layoutX="516.0" layoutY="10.0" mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0" onMouseClicked="#bookSelect" styleClass="btn-success" text="查询" />
```

进去其鼠标点击事件

```javascript
/*
    查询
 */
@FXML
private void bookSelect(){
    String bookName = bookNameField.getText();
    String isbn = isbnField.getText();
    boolean bookFlag = "".equals(bookName);
    boolean isbnFlag = "".equals(isbn);
    ObservableList<Book> result = books;
    if (bookFlag && isbnFlag) {
        return;
    }else {
        if (!bookFlag){
            result = books.filtered(s -> s.getBookName().contains(bookName));
        }
        if (!isbnFlag) {
            result = books.filtered(s -> s.getIsbn().contains(isbn));
        }
    }

    books = new ObservableListWrapper<Book>(new ArrayList<Book>(result));
    bookTableView.setItems(books);
}
```

这个方法就是查询方法，不过其是基于内存进行的查询，我们首先获得书名和编号，然后判断这个书名和编号是否为空，若为空则不查询，若不为空则进入对应的查询方法，现在我们要将这个代码修改为基于硬盘文件来查询。

其实就光从查询功能而言，没必要从硬盘文件中查询，只从内存中查询就可以了的，是符合需求的，但我们这里总得找点事情做是吧，所以就改改呗

那么我们可以修改代码如下

```javascript
/*
    查询
 */
@FXML
private void bookSelect(){
    String bookName = bookNameField.getText();
    String isbn = isbnField.getText();
    Book book = new Book();
    book.setBookName(bookName);
    book.setIsbn(isbn);
    //根据条件查询图书
    List<Book> bookList = bookService.select(book);
    //将查询出的list集合对象转换成可展示的ObservableList集合对象
    books = new ObservableListWrapper<Book>(new ArrayList<Book>(bookList));
    bookTableView.setItems(books);
}
```

这里我们只通过书的名字和编号来进行查询，而我们又需要图书对象进行查询，因此我们先创建图书对象，然后设置对应的名字和编号，然后传入该图书对象调用此前我们实现过的select查询方法进行查询，返回一个符合条件的List集合，然后我们将该List集合转换为可观察的集合然后传给展示台就完了

但是我们现在这样的查询方法是存在bug的，其中一个最明显的bug就是，如果用户同时输入了姓名和编号进行查询，那么姓名就只有编号会发挥作用，姓名没有效果，相当于是只能查询编号

```javascript
if(!"".equals(book.getBookName())) {
    //根据图书名称查询，若书名相同则将该对象直接添加到集合中并将该集合赋给conditionList，这里利用了Stream流
    conditionList = list.stream().filter(b -> b.getBookName().equals(book.getBookName())).collect(Collectors.toList());
}
if(!"".equals(book.getIsbn())) {
    //根据Isbn编号查询，若书名相同则将该对象直接添加到集合中并将该集合赋给conditionList，这里利用了Stream流
    conditionList = list.stream().filter(b -> b.getIsbn().equals(book.getIsbn())).collect(Collectors.toList());
}
```

之所以会这样，是因为我们的代码里两个if没有区分，如果姓名和编号同时存在，那么编号的查询结果会覆盖原来的conditionList，导致最后我们只能获得编号查询的结果，要解决这个问题，我们可以做一个编号和名字都不为空的判断并进行特殊处理，我们可以在条件判断的最前头加入这个一个判断条件

```javascript
//条件查询
if(!"".equals(book.getBookName())&&!"".equals(book.getIsbn())){
    conditionList = list.stream().filter(b -> b.getBookName().equals(book.getBookName())).collect(Collectors.toList());
    conditionList = conditionList.stream().filter(b -> b.getIsbn().equals(book.getIsbn())).collect(Collectors.toList());
    return conditionList;
}
```

我们这里的处理是先通过名字搜索处符合条件的对象放置于集合中，然后在这个集合的基础上再查找符合的编号的图书集合，然后返回这个集合