接下来我们就要学习高级排序了，首先我们来学习希尔排序，它可以简单理解为是插入排序的改良版本

希尔排序

我们先来看看希尔排序的原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3054b5d7e534defd79bb69c0226d2a14.png)

其实希尔排序的实质就是先将数组的所有元素进行分组，分完组之后对每一组的元素分别进行插入排序，插入排序完成之后我们再进行分组，接着再进行插入排序，这样不断循环往复，每次分组的数值也在变小，当分组的数组足够小时，我们就相当于是在对一个部分有序数组进行插入排序，此时要进行运算次数就很少了，可以达到我们的目标

我们来看看它的图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6c8cd76c9310a4b1cb4b228bebc19067.png)

首先我们可以看到我们有一个数组长度为10，最后下标为9的数组，首先我们可以看到我们的h为5，那么我们就将数组按照这个规则将数组的元素从第一个开始分，分为五组，每组两个，然后对其进行插入排序，比如第一组的{9,4}，进行插入排序之后就变成{4,9}，这里利用插入排序，将数组本身分为两组，一组未排序一组已排序，这里未排序的是9，已排序的是4，比较发现4比9小，因此进行了交换，同时由于数组只有两个，因此不需要再进行对其他数组的比较、

当我们将h=5的排序执行完毕之后，我们就得到了一个部分排序数组，接着我们将h=2，再次进行分组，将数组分为两组，一组五个，其中一组为{4,2,5,8,5}，接着对其进行插入排序，将4默认设置为已排序数组，将2,5,8,5默认为未排序数组，接着用未排序数组的第一个对已排序数组尽心分别的一个个的比较，首先我们将2与4进行比较，发现4小于2，于是4与2交换位置，接着拿5与4比较，发现5大于4，于是直接停止循环。接着8与5比较也是同理，然后8与5比较，8与5交换，再拿交换位置的5与5比较，发现并不是小于关系，于是直接停止循环

最后h=1也是同理，经过这三次排序之后，我们最后就能得到一个排序完全的数组

那么这个h要怎么决定呢？每次减少多少，以及最开始是从多大开始的呢？这里面其实是有规则的，规则如图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEcec92b67f165343c836f6b44defc9032.png)

比方说我们这里的数组长度是10，那么按照规则，我们就可以确定其h的最初长度是7。但问题是，最开始我们明明搞得是5啊，为啥这里又是7呢？其实这里的5只是为了我们方便理解这个方法而人为设置的，实际上内部运作的时候最开始的长度就是7

然后每次减少的长度为减少到它的一般，那么最开始的长度为7，第二次就为3，第三次就为1

学习完希尔排序的原理之后，我们来看看希尔排序的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2ede308e629a1b88327898c45f662512.png)

然后我们就可以实现它的算法如下

```javascript
package algorithm.sort;

public class Shell {
    public static void sort(Comparable[] a){
        //根据a的长度，确定h的初始值
        int h=1;
        while (h<a.length/2){
            h=h*2+1;
        }
        //希尔排序
        while (h>=1){
            //排序
            //2.1找到待插入的元素
            for (int i = h; i < a.length; i++) {
                //2.2把待插入的元素插入到有序数组中
                for (int j = i; j >= h ; j-=h) {
                    //待插入的元素是a[j]，比较a[j]和a[j-h]
                    if(greater(a[j-h],a[j])){
                        //交换元素
                        exch(a,j-h,j);
                    }else {
                        //待插入的元素的已经找到了合适的位置，结束循环;
                        break;
                    }
                }
            }
            //减小h的值
            h=h/2;
        }
    }

    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w)>0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```

这里我们先确定h的长度，所以用了一个while循环来先确定其最大长度

接着我们构建一个h不断变为其一半的while循环代表多次执行循环，最小的循环为h=1，我们通过分析发现，每一个分组的第一组的第二个元素的下标必然等于h，如在第一次排序里的4，其下标为5，第二次排序里的2，其下标就为2。因此我们可以构建第一个for循环，该for循环的第一个代表了每一组的第二个元素的下标，随后不断增加到最后一个下标

然后在该for循环里我们再建立一个for循环，第二个for循环则是以第一个for循环所代表的下标从左每次下标减少h并对其进行选择排序，每一个第二个for循环的结束代表着一个选择排序的一次循环的结束，外层for循环的结束则代表着第一趟分组的排序的结束，while循环的结束就代表着排序的正式结束

反正就套娃其实，嗯套就完了

本来我们应该照例来用大O记法来分析下希尔排序的时间复杂度的，这是事前分析方法，但是呢，因为希尔排序比较复杂，这里面涉及很多的高深莫测的数学问题，这对于我们目前这个阶段的学习来说实在是太痛苦了，为了避过这一步，我们使用时候分析方法来分析其时间复杂度

利用IO流，放入了一个10万到1的逆序数组，用插入排序来做需要三万毫秒多，而用希尔排序只需要30毫秒，谁快谁慢高下立判了属于是，因此当我们涉及大量计算时，我们还是使用高级排序法比较好，低级排序法费拉不堪



归并排序

在讲归并排序之前我们应该要先对递归有所了解，但是递归我们已经了解过了，所以不讲了

归并排序的核心思想在于拆，排，排，合。我们先来看看其原理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE351ec6d159edc72a8a4aac58d3774aae.png)

先将一个数组不断拆分，拆分到一个一个为止，然后不断合并，合并的同时不断排序，最后合并出来的一个数组就是排序好的数组，我们可以看看其图示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE40c9c5e5a4c0e8f44d11ff1e967dd00a.png)

接下来我们来看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb73945f443b8fb0096bca045fce9c7fd.png)

可以看到，有三个方法是跟以前我们学习的方法是一模一样的，除了名字之外。这三个方法分别是sort(1)，exch，less方法，接着在Merge方法里还有两个独特的方法，这个方法分别是sort的重载方法(2)与merge方法

并且在这个方法里还有一个成员变量，这个成员变量是一个辅助数组

该方法的执行过程是通过将数组分组，分组之后再排序，排序之后，我们要进行归并，那我们这个归并过程的是如何实现的呢？其原理又是如何的呢？我们先来讲讲，先看看其前提

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE854755905f966fef932bfec80026f8de.png)

这里我们先分好了组，且调用了两次sort方法将两个数组本身进行了排序，最后我们要调用merge方法进行归并，就是合并，并且要合成排序好的合并，那我们要怎么办呢？我们可以通过三个自定义的指针以及辅助数组来实现该方法

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE7ee384f84651e769a2bebc9ce8e3f907.png)

其原理是我们让指针p1指向左子组，指针p2指向右子组，接着定义一个指针i指向辅助数组assist，然后我们重复进行p1与p2的大小的判断，如果p1小，那么就将p1指向的元素放到指针i指向的元素中，同时将p1与i指针都向后移动一位，反之则是移动p2与i，若p1或者p2有其中一个到达了其尾端，那么就不要再进行比较，直接将另一个指针的元素按顺序放到assist中就可以了

注意这里是先将左子组与右子组排序好之后我们才可以这样做的，如果没有事先排序好，上面的方法是不成立的

最后放在我们的辅助数组assist中的数组就是我们排序好的数组，最后我们要做的事情就是将辅助数组里的元素一个个拷贝到原数组对应的位置中去

那么我们可以实现其方法如下

```javascript
package algorithm.sort;

public class Merge {

    //成员变量的辅助数组，未初始化
    private static Comparable[] assist;

    public static void sort(Comparable[] a){
        //先初始化辅助数组assist，创造一个具体对象，其长度为原数组的长度
        assist = new Comparable[a.length];
        //定义lo变量与hi变量，分别记录数组中的最小与最大索引
        int lo=0;
        int hi=a.length-1;
        //调用sort重载方法完成对数组a中从索引lo到hi的元素排序
        sort(a,lo,hi);
    }

    private static boolean less(Comparable v, Comparable w) {
        //与之前的方法不同的是这里是<号，比较谁小
        return v.compareTo(w)<0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void sort(Comparable[] a, int lo, int hi){
        //先进行安全性校验，确保传入的索引合法
        if(hi<=lo){
            return;
        }

        //对lo与hi之间的数据分为两组
        int mid=lo+(hi-lo)/2; //    lo=5,hi=9 mid=7

        //对分组之后的数组进行分别排序，这里对前数组进行排序
        sort(a,lo,mid);
        //这里对后数组进行排序
        sort(a,mid+1,hi);
        //上面是使用了递归的方法

        //最后将两个组中的数据进行归并
        merge(a,lo,mid,hi);
    }

    private static void merge(Comparable[] a,int lo,int mid,int hi){
        //先定义三个指针
        int i=lo;//定义i=lo，让i指针指向对应的起始位置，而不是只会在开头
        int p1=lo;
        int p2=mid+1;
        
        //遍历，移动p1和p2指针，比较对应索引的值，找出小的那个并放到辅助数组的对应索引处
        while (p1<=mid && p2<=hi){
            //比较对应索引处的值
            if(less(a[p1],a[p2])){
                assist[i++]=a[p1++];
            }else {
                assist[i++]=a[p2++];
            }
        }
        
        //如果p1的指针没有走完，那么顺序移动p1指针，把对应元素放到辅助数组的对应索引处
        while (p1<=mid){
            assist[i++]=a[p1++];
        }
        //如果p2的指针没有走完，那么顺序移动p2指针，把对应元素放到辅助数组的对应索引处
        while (p2<=hi){
            assist[i++]=a[p2++];
        }
        //把辅助数组中的元素拷贝到原数组中
        for (int index=lo;index<=hi;index++){
            a[index]=assist[index];
        }
    }
}

```

Tips:使用Arrays.toString();方法可以直接打印数组内的值，可以省去for循环

接下来我们照例来分析下其方法的时间复杂度，我们先来看看用来分析其时间复杂度的演示图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdc0b83fbd4fea48275f3db57b2ff0531.png)

接着我们我们来看看其时间复杂度的理论分析

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE680f7780200822dafdcd98196f351154.png)

最后我们可以得出答案，其时间复杂度就是O(nlogn);这个显然是比简单排序法的效率要高得多的

但是，对于归并排序而言，不断地使用递归的方法是有导致内存溢出的可能的，而且由于在归并排序里是创造了一个辅助数组来完成排序的，因此也比其他的方法需要更多的空间，是一种典型的用空间效率来换时间效率的方法

归并排序和希尔排序的效率是差不多的，那我们排序时应该选择哪一种方法来排序呢？这个不用急，等我们后续讲到了排序的稳定性之后，这个问题就会迎刃而解了



快速排序

我们先来看看其理论定义吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE11302df64d9414f7b6d3696cdd3d312a.png)

简而言之，就是对一个数组选择一个数作为分解值然后分组，将大于等于其的数据放到数组右边，反之则放左边，然后对左右两侧的数组做同样的流程，最后分到不能再分的时候，我们再进行合并，不断合成，最后形成一个排序好的数组

比方说对于下面的图示而言

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8a0c2a1169fba40b31879d595ee8c41a.png)

我们直接选第一个数组6作为分界值，然后把数组分为左右两组，接着对左右两组继续进行同样的流程，把每个数组再细分，由于右边分界值为9的数组右边是没有比他更大的数值的，因此其分界值右边是没有元素的，然后我们继续分，这第三次就是最后一次分组了，因为这时候已经分到只剩下2个元素了，没法继续拆了，此时剩下的三个就是分好序的拆分数组，然后我们再讲分界值对应合并，最后我们就可以得到我们想要的排好序的数组了

学完了理论之后，接下来我们来学习下快速排序的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbed0195da5f1d271c259469decc3974f.png)

我们可以看出，其实其API设计和归并排序似乎很像，但是不同的是，我们这里有一个partition方法，这个方法的作用是在于对数组a中，从索引lo到索引hi之间的元素尽心个分组，并返回分组界限返回的索引，我们先来重点讲解下这个方法

先来看看其原理吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE41f1690267bbbb451268ae533af1b5ae.png)

简单来说，就是我们先定义两个指针，第一个指针指向数组的头索引，第二个指针指向数组的末索引的下一位，然后先从右往左搜索，找到比分界值小的元素并让指针指向该元素，接着左指针往右搜索，找到比分界值大的元素并让指针指向该元素，若此时左指针仍然小于右指针，则交换左右指针的值并继续在从交换位置重复此过程，直到左指针大于或等于右指针时交换分界值与两指针共同指向的值，然后结束循环，当然，左指针或者右指针到了数组结尾的时候也要结束循环

用演示图来演示则是如下所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE06d462a9cc88846e68852e31b3e8d310.png)

我们这里将6作为分界值，右指针找到了5这个元素比边界值小，此时右指针指向5

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf51d4e2ad3d6133586ea04f3bd53cb31.png)

然后左指针开始遍历，左指针找到比分界值大的值为7，然后此时左右指针还不满足左指针大于右指针的情况，所以交换两指针所指向的值，然后重复进行上述动作，又交换了9和4

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE6227a7d1b67de9a3d765968ad1298b9d.png)

最后两个指针都指向了3，此时交换6与3，这样数组就完成了分组了

由图我们可以实现该方法如下

```javascript
package algorithm.sort;

public class Quick {

    public static void sort(Comparable[] a){
        int lo = 0;//定义数组的头索引
        int hi = a.length-1;//定义数组的末索引
        sort(a,lo,hi);//调用重载的给数组排序的方法
    }

    private static boolean less(Comparable v, Comparable w) {
        //与之前的方法不同的是这里是<号，比较谁小
        return v.compareTo(w)<0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void sort(Comparable[] a, int lo, int hi){
        //安全性校验
        if(hi<=lo){
            return;
        }
        //对数组中lo索引到hi索引处的元素进行分组(左子组和右子组)
        int partition = partition(a,lo,hi);//返回分组分界值所在的索引，注意是分界值位置变换后的索引
        //让左子组有序
        sort(a,lo,partition-1);//-1是为了从分界值前一位作为终止索引
        //让右子组有序
        sort(a,partition+1,hi);//+1是为了从分界值后以为作为起始索引
    }

    private static int partition(Comparable[] a,int lo,int hi){
        //确定分界值
        Comparable key = a[lo];//分界值就是数组头位置的值，lo传入的就是数组头索引
        //定义两个指针，分别指向待切分数组的最小索引处和最大索引处的下一个位置
        int left=lo;
        int right=hi+1;

        //切分
        while (true){
            //从右往左遍历，移动right指针，找到一个比分界值小的元素后停止
            while (less(key,a[--right])){
                //使用less(key,a[--right);方法，这样让右指针找到比key小的元素之后结束此循环
                //使用--right是为了让右指针先移动到对应位置在进行比较
                if(right==lo){//如果右指针到了首位置，就结束循环
                    break;
                }
            }

            //从左往右遍历，移动left指针，找到一个比分界值大的元素后停止
            while (less(a[++left],key)){
                if(left==hi){//如果左指针到了末位置，就结束循环
                    break;
                }
            }
            //判断left>=right，若为真，则证明扫描完毕，结束循环，反之交换元素
            if(left>=right){
                break;
            }else {
                exch(a,left,right);
            }
        }
        //交换分界值
        exch(a,lo,right);
        return right;//返回边界值的所在位置的索引
    }
}

```

快速排序和归并排序的区别

无论是快速排序还是归并排序，其本质都是一种分治算法。不同的是，归并排序是将数组本身分为两个子数组然后分别排序，接着将有序的子数组进行排序之后再进行归并从而让整个数组有序。而快速排序的方法本质是当两个数组都有序时，整个数组就自然有序了。

其次，归并调用发生在处理整个数组之前，我们是先递归，递归的同时处理数组，同时我们总是把数组分成两半，取中间值。而快速排序则反过来，在快速排序里，切分数组的位置取决于数组的内容，而且我们是先处理数组内容，后再进行递归。



快速排序的时间复杂度分析

接着照例来分析下快速排序的时间复杂度分析，对于快速排序而言，我们分析其时间复杂度我们要分为三种情况来分析

首先是最优情况，在最优情况下，快速排序的效率和递归排序是差不多的，每一次切分的数组正好将数字等分，此时其时间复杂度为O(nlogn);

而在最坏情况下，每次切分都是当前序列中的最大数和最小数，这样就得总共切分n次，所以最坏情况下，其时间复杂度为O(n^2);

而在平均情况下，其时间复杂度为O(nlogn);这里是用数学归纳法来证明的，涉及到许多数学知识点，我们这里就直接给答案了，反正讲了也听不懂不是，没必要

