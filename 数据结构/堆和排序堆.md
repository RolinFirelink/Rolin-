学习完二叉树入门后，我们现在来学习堆这种数据结构，首先我们要知道，堆这种数据结构的实现是基于二叉树结构，底层通过数组实现的。

在构造堆数据结构的代码之前，我们先来学习下堆这种数据结构的特点及其原理

首先，堆是完全二叉树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb3cf7ad91afa5bbd83ebbb7ecd766f63.png)

关于完全二叉树的定义我们之前也讲过了，这里再讲一遍无妨，首先完全二叉树是指除了最后一层的结点不需要满结点之外，其他层都需要满的，如果最后一层不是满的，那么一定要满足左满右不满的定律，否则其不是完全二叉树

其次是堆通常是以数组来实现，接下来让我们来看看堆是如何用数组来表示完全二叉树的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9321ae89bbedeed2bbe5bf5ccb24d48f.png)

一般而言，为了表示方便，堆中的数组索引的0位置处是不存放任何元素的，接下来我们可以从图中获得以下两个性质

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd70d6334878a96f295a2d803e1d82103.png)

这几个规律总结下来就是，如果一个结点的位置为k，则其父节点的位置为k/2，其子节点的位置则为2k和2k+1。其次是每个结点都大于其两个子节点，但两个子节点间的大小关系没有规定

接下来让我们看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE69364cee617f4fb857671c38aa2068cc.png)

这里我们要对这里面的API设计具体讲讲，首先这里的构造方法要传入int参数用于指定空间，这主要是因为我们底层调用的是数组对象，而数组是要先指定空间创造的

其次是这里我们Heap里面的泛型元素T继承了Comparable方法，这是因为我们上面讲过的规则里有一条父节点必然大于子节点的规则，那么堆里面的元素就是有序的，起码是部分有序的，那么就需要用于排序的方法，因此这里继承了Comparable接口

最后是我们看到5.6两个方法，这两个方法说使用了上浮算法，下沉算法似乎我们没学过，其实这两个方法的主要目的就是为了让我们往堆里添加了元素之后我们要用这种算法使得我们的添加的元素处于一个正确的位置，因为我们的堆里的元素是部分有序的，因此我们不能添加之后就让其破坏我们堆里的这种有序，必须要用这种方法进行处理

而所谓上浮算法，其实就是将元素的位置往其父节点方向上移动的意思，下沉算法则反之

我们先来看看我们上浮算法的实现图示原理吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9c6a985842dab48008658f6c732f28d5.png)

我们只需要让我们添加的新元素不断地与其父节点的元素进行比较，确定到底谁大谁小，如果子节点的元素的确大于父节点，那么就交换位置，这样不断循环直到进入到合适的位置为止

再来说说我们的删除方法和下沉算法的原理，我们这里的删除方法是要删除堆中元素最大的值，显然，堆中元素最大的值就在根结点处，所以我们直接删除根结点其实就挺好，但这样就会导致让我们的树变成森林了，而这不是我们想要的，我们应该要让我们的删除方法能够删除最大的元素的同时又能够就行保持堆中的部分有序规则，那么我们应该怎么办呢？我们容易想到一个方法就是让P或者R去成为新的根结点，但这样的话由于子节点谁大谁小没比较，所以左子树的子树未必就小于右子树本身，这样的又需要比较，这样就太麻烦了，也不容易去实现

这里我们采用了一个比较讨巧的办法，我们先将首结点与最后一位结点交换，接着将最后一位结点删除，然后对首结点使用下沉算法，直到让改变后的首结点到达了正确位置为止，来看看其交换位置的图示吧

![](WEBRESOURCE8c1ce2419f111d803343d5083b17d6d5)

接着是使用下沉算法的图示

![](WEBRESOURCEe1a0ed4cb2340a8d267606569ed092de)

这样我们最终就可以得到一个有序的堆了

那么根据API我们就可以构造代码如下

```javascript
package algorithm.sort;

//令T继承Comparable接口，给T所代表的元素提供比较方式，便于实现排序
public class Heap<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    /*
     * 此处之所以是要生成Comparable接口是因为我们在泛型里继承了该接口
     * 如果我们生成Object类型的话会报类型转换异常，这里之所以让指定的
     * 容量+1是因为我们我数组里是废弃了0索引的，因此要多给予一个空间用
     * 于存放元素
     */
    public Heap(int capacity) {
        this.items=(T[]) new Comparable[capacity+1];
        this.N=0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }

    //交换堆中索引i和索引j处的值
    private void exch(int i,int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
        //其实我觉得这里应该要做一个调用上浮算法的动作的，但是没有
    }

    //往堆中插入一个元素
    public void insert(T t){
        //这里采用++N的方式是因为我们堆中的元素的首位是不存放任何元素的
        //我们采用++N，如果N等于0，那么我们就可以正确填入元素到1位置处
        //如果N不等于0，那么就正确填入元素到数组末尾
        items[++N]=t;
        swim(N);//添加完毕之后使用上浮算法令堆重新有序
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        //通过循环，不断比较当前结点和父节点的值
        while (k>1){//只要索引还大于1，说明还没到根结点，就继续执行循环
            //比较当前结点和父节点的大小
            if(less(k/2,k)){//如果当前结点大于父节点
                exch(k/2,k);//则交换字父结点的位置
            }

            k = k/2;//若不等于则令k结点的元素变化到其父节点的元素
        }
    }

    /*
     * 该方法只完成了交换和和调用下沉算法并且返回被删除的最大值的结点，这里删除元素的方式不是
     * 采用断开链表对其的指向，而且将其值赋值为null。在数组中就相当于不解除最后一个位置
     * 的空间，而将最后一个值赋值为null的意思。此处最大索引不是N-1而是N的原因是我们的首结点
     * 是只充当指引的元素，因为因此多占了一个位置，因此结尾可以到达N而不是N-1。在实际的代码上
     * 我们也是先从1索引处开始放置元素的，于情于理都可以理解N索引才是结尾而不是N-1
     * 我个人理解在本方法里交换最大和最小元素的意义在于，让最小元素成为根结点就可以保证下沉算法
     * 的不断实现，因为叶结点必然是最小的子节点，令其到头部可以不断使用下沉算法，通过下沉算法来
     * 让堆中的元素最终能达到一个部分排序的情况
     * 最后提一下这个方法只能用于删除堆中最大元素，而不是说删除指定元素
     */
    //删除堆中最大的元素，并返回这个最大元素
    public T delMax(){
        T max = items[1];//定义max用于记录最大元素

        //交换索引1处和最大索引处的元素
        exch(1,N);
        //删除最大索引处的元素
        items[N]=null;
        //元素个数-1
        N--;
        //通过下沉调整堆，让堆重新有序
        sink(1);
        //返回被删除的最大值
        return max;
    }

    //使用下沉算法使k在堆中处于一个正确的位置
    private void sink(int k){
        while (2*k<=N){//只要2*k<=N存在，那么就说明还有左子树，还能继续进行循环比较
            int max;//定义max用于记录两子节点较大结点所在的索引
            if(2*k+1<=N){//判断有无右子树
                if(less(2*k,2*k+1)){//若有则判断左右子树大小
                    max = 2*k+1;//右子树大则让max记录右子树的索引
                }else {
                    max = 2*k;//反之则记录左子树的索引
                }
            }else {
                //若没有右子树则直接让max记录左子树的索引
                max = 2*k;
            }

            //比较当前结点和较大结点的值
            if(!less(k,max)){
                //如果当前结点大于较大结点，则说明已经处于正确位置，直接结束循环
                break;
            }

            //若小于交换索引k和较大子节点max所代表的值
            exch(k,max);

            //变化k的值，让k进入较大子节点的索引，实际上k也是与max进行的交换，因此将k的值定位到max上也容易理解
            k = max;
        }
    }
}
```



堆排序

上面我们实现了堆的数据结构，接下来我们来实现下堆排序，所谓堆排序简而言之就是要完成如图所示的需求

![](WEBRESOURCE3666a103d8d6c598fb58d138a0410d78)

我们先来看看其API设计

![](WEBRESOURCE3f118489f17026c87048830e46225b7c)

这里我们要对第五个方法进行说明，这个范围是什么意思？其实是当我们对堆中元素进行动作的时候，实际上某些时候我们是不用对某些元素做下沉动作的，比如说只要我们把range定义到数组结尾的前一个元素，那么我们的下沉范围就不会对最后一个元素进行这个动作的，这样有助于我们提高某些时候的下沉效率

那么我们应该如何对数组实现堆排序呢？一个简单想法就是我们创建一个新数组，然后遍历原数组不断添加往新数组里添加元素，边添加边排序直到排序完毕，最后就能构造一个堆排序数组了，但是这样方法太简单，不适合我们，所以我们要用更加聪明的办法

![](WEBRESOURCEbf28fa4544ed3cf0a46e5022ca31b906)

这个办法就是我们先创建一个新数组，将原数组中的所有数据传到新数组的1~length处，然后对新数组长度的一半开始往1处进行下沉算法的动作，最后就能得到一个堆排序数组了，为什么是从新数组长度的一半开始扫描？这是因为对于堆里的完全二叉树而言的，其2k之后的数组都是其子树，那么数组长度的一半之后的结点都是叶结点，叶结点没有左右子树无法做下沉算法，因此对其进行下沉算法的过程是可以省略的，所以我们从新数组长度的一半往1索引处开始扫描

来看看图示吧

![](WEBRESOURCE246777466ec17aff9e7f5f28bf419737)

接下来是第二张

![](WEBRESOURCE5278f6bf42762a054d4dcc8fcbdaf4ac)

经过上面的过程，我们就成功创建了一个有序堆，但是我们的需求是将数组按堆的方式从小到大排序，而堆是从大到小排序，现在我们的实现的排序和我们所需要的正好反过来了，那我们应该怎么办呢？有一个简单想法就是利用栈来达成我们的需求，但是这种方式效率不是很高，所以我们要用另外一个更加聪明的办法

先来看看这个方法的步骤

![](WEBRESOURCEe524bb0bf2cbbd0caadbb6532522ddd7)

首先我们都知道在堆里是按照父子节点由大到小的方式来排序的

那我们就可以先将根结点与最大索引处的元素交换位置，之后对根结点进行下沉算法，此时我们将最大值放到的最大索引处，那么进行下沉算法时，我们就不对最后一个元素进行下沉了，下沉完毕之后在根结点里的元素必然是次大元素，接着重复执行上述过程，那么就会在次大索引处理放上次大值，接着不断执行这个过程最后我们就能实现数组中元素的大小按从小到大排序，来看看其图示过程吧

![](WEBRESOURCE671cb45b169b7075b2136933a3509f74)

只放一个就行了，不放太多图了，咱们这里以小见大好吧

根据API设计和上述的讲解我们可以构造代码如下

```javascript
package cn.itcast.algorithm.heap;

public class HeapSort {
    //判断heap堆中索引i处的元素是否小于索引j处的元素
    private static boolean less(Comparable[] heap, int i, int j) {
        return heap[i].compareTo(heap[j])<0;
    }

    //交换heap堆中i索引和j索引的值，这里与此前不同的是这里还要将数组也传入给该方法用于比较
    private static void exch(Comparable[] heap,int i, int j) {
        Comparable tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
    }

    //根据原数组source，构造出堆heap
    private static void createHeap(Comparable[] source,Comparable[] heap) {
        //把source中的元素赋值到heap中，heap中的元素是一个无序堆
        //调用API进行数组的复制，传入对应的值
        System.arraycopy(source,0,heap,1,source.length);

        //对堆中元素做下沉(从长度的一半处开始，往索引1处扫描)
        for (int i = (heap.length)/2; i > 0 ; i--) {
            sink(heap,i,heap.length-1);
            //范围之所以定位长度-1，是因为对于堆底部的数组而言，一开始是多创建了一个空间的，这是因为
            //我们将0位置的元素废弃了的缘故，但我们比较时是从1开始的，因此我们传入的范围需要-1，代表
            //堆中最大索引的范围，这行代码的意思也是说下沉算法的边界就在最大索引处的意思
        }
    }

    //对source数组中的数据从小到大排序
    public static void sort(Comparable[] source) {
        //构建堆，给其指定的空间+1，因为我们废弃了0位置处的空间，从1处开始添加元素，因为指定的空间要+1
        Comparable[] heap = new Comparable[source.length+1];
        createHeap(source,heap);//调用创造排序堆的方法
        //代码执行到此说明已经产生了有序堆
        //定义用于记录未排序元素最大索引的变量
        int N = heap.length-1;//N最开始定义到最大索引处
        while (N!=1){//只要索引没到1说明元素的交换没有到根结点处，那就继续进行交换
            //交换最大索引与最小索引的值
            exch(heap,1,N);
            //排序交换最大元素所在的索引，并令其不参加下沉
            N--;//直接减少N的值，这样N定义到次大索引处
            //对索引1处的元素执行下沉算法，传入N代表的边界值，N此时所代表的边界值就是我们所需要的边界值
            sink(heap,1,N);
        }

        //把heap中的数据赋值到原数组source中
        System.arraycopy(heap,1,source,0,source.length);
    }

    /*
     * 这个下沉算法与我们之前学习的下沉算法的代码逻辑只有细微区别，就不再赘述了
     * 不过有所不同的是这里我们比较的边界值range，而我们每次都要传入用于下
     * 沉算法的索引target，如果其二倍大于range，说明没有符合条件的子树，那么就
     * 跳出循环。其他代码没啥不同，不多说了
     */
    //在heap堆中，对target处的元素做下沉，范围是0~range
    private static void sink(Comparable[] heap,int target,int range) {
        while (2*target<=range){
            //找出当前结点的较大的子结点
            int max;
            if(2*target+1<=range){
                if(less(heap,2*target,2*target+1)){
                    max = 2*target+1;
                }else {
                    max = 2*target;
                }
            }else {
                max = 2*target;
            }

            //比较当前结点的值与较大子节点的值
            if(!less(heap,target,max)){
                break;
            }

            exch(heap,target,max);

            target = max;
        }
    }
}
```

