本章节我们来学习我们的三层框架里的最后一个内容，SpringMVC。

- SpringMVC概述

首先我们来先讲下什么是SrpingMVC，这就要先从我们的三层架构中讲起了，我们传统的开发里有三层架构，分别是数据层、业务层以及表现层

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9e4ff858e762f21827b0b9473ddf0344.png)

我们的数据层的技术，我们学习过的有JDBC、MyBatis以及Spring，业务层目前则只学习过Spring，而在表现层中，我们则有Servlet、HTML...以及Spring

而今天我们要学习的SrpingMVC，其就是表现层的一种技术。首先我们来介绍下什么是MVC

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3db4557c7d576af73720ba91a99f5be5.png)

首先MVC是Model View Controller的简称，是一种用于设计和创建web应用程序表现层的模式。其中M，代表Model，也就是模型，其是一种数据模型，用于封装数据。而V则代表View，意为页面视图，用于展示数据。而C则代表Controller，其为控制器，是处理用户交互的调度器，用于根据需求处理程序逻辑。

我们一般的需求响应的过程很简单，浏览器向客户端发送请求erquest，然后在客户端中，模型和视图由Controller进行组装并形成一个具有对应数据的视图然后进一步组装成响应对象response返回给浏览器。我们之前是使用Servlet帮我们完成这一项工作的，而现在我们学习的SpringMVC就是帮助我们做这一项工作的。

最后我们来看看其优点以及其简单的介绍

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEd1cb7edf108103f352f0d08deade172c.png)

- 入门案例制作

经过了好多天的摸鱼之后，终于重新开始学习了，这次摸鱼真的玩爽了，不过也大概有整整一星期没有对技术栈进行学习了吧。只能说这次五一假期是我又爽又痛苦的一次经历，另外这次五一的假期，足足让我花了一千有余，以后如果还想继续过这样的舒服日子，肯定要有足够多的钱，而这些钱都只能靠未来的我去自己赚来，所以我们更加是要去努力学习，好好读书，这样以后自己能赚大把大把钱，然后我们才有能力继续去过这种我理想中的好生活

然后这里我们之所以卡顿，有一点的原因是因为我们在导入依赖时 ，我们的依赖总是无法正确导入或者被正确使用而产生的问题，最后经过排查发现问题在于我们在一个项目中引入了太多的模块，而他们又是使用同一个资源库的，这就会不可避免地产生依赖冲突的问题，解决方案也很简单，新创建一个工程就完了。

那么在正式学习我们的入门案例之前，我们先来介绍下我们的入门案例的环境，首先我们来看看我们的pom文件的依赖

```
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.example</groupId>
  <artifactId>Test</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>Test Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <!-- servlet3.1规范的坐标 -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <!--jsp坐标-->
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.1</version>
      <scope>provided</scope>
    </dependency>
    <!--spring的坐标-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.1.9.RELEASE</version>
    </dependency>
    <!--spring web的坐标-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>5.1.9.RELEASE</version>
    </dependency>
    <!--springmvc的坐标-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.1.9.RELEASE</version>
    </dependency>

  </dependencies>

  <!--构建-->
  <build>
    <!--设置插件-->
    <plugins>
      <!--具体的插件配置-->
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.1</version>
        <configuration>
          <port>80</port>
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>

```

在我们的pom文件中，我们引入了我们的工程所需要的依赖，分别是servlet的，这些是必要的，而后面的一些则是我们制作案例所需要用得上依赖，分别是spring、springweb和springmvc的依赖，后续我们还引入了一个插件，这个插件就是tomcat7的插件，在该插件里，我们设置了对应的服务器的端口号80以及其虚拟路径，然后我们要使用该tomcat的话，就要用maven中的插件来使用tomcat服务，而不能直接用我们配置的tomcat服务

如果我们想要使用maven中的tomcat服务的话，我们有两种方式，第一种方式是直接配置，我们先点击上面的启动方式的下选栏目，然后选择edit选项，然后进入对应的窗口，选择左上角的+号然后我们选择其中的maven，接着在对应的Command里选择我们需要启动的功能，这里我们选择启动tomcat服务器，就是tomcat7:run

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEf610b63fc5c96a1f7334152b42800136.png)

然后我们选择ok或者是apply之后就可以直接通过上面的播放符号开启对应的maven服务，来开启我们的tomcat服务了，非常方便。

我们的第二种方式是通过右边的maven，点击之后选择我们对应的模块，然后点击plugin然后选择对应的启动tomcat的功能就可以了。

然后我们创建了一个Uservlet类，该类完成的功能是接受一个请求，并打印一句话，然后往响应里添加一个新的页面地址，接着返回这个响应。这里是牵扯到了很久之前我们学习过的servlet的对应知识，实话我也忘得七七八八了，具体有什么不懂的回去重新复习吧

```
package com.itheima.web;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class UserServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("user servlet is running...");
        req.getRequestDispatcher("success.jsp").forward(req,resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }
}

```

我们顺便来看看我们的响应的界面

```
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>
<html>
<body>
<h1>第一个spring-mvc页面</h1>
</body>
</html>
```

再来看看我们的默认界面

```
<html>
<body>
<h2>Hello World!</h2>
</body>
</html>

```

然后我们当然需要在对应的xml配置文件下进行对应的配置以及映射，具体代码如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa2b1c0798fc68b77fcc2c8ec673801b1.png)

然后我们启动tomcat服务，来看看效果，会发现我们的服务启动地非常成功，此时就说明我们的应用配置好了。然后我们就来进行我们的案例的制作了

首先我们创建一个UserController类并写入一个save方法，方法里就写入一个打印语句运行就执行这语句就完了，然后我们接下来就要将我们的之前UserServlet类中的功能搬到这里去并用springMVC来进行实现，当然我们这里也避免不了要进行对应的资源配置，首先我们要做的配置是让我们的扫描加载器所有的控制类，这里的内容其实跟我们之前的案例环境的代码是一样，实际上不做改动也可以，但我们的做springmvc时我们总是推荐将springmvc和spring分开，因此我们会创建一个springmvc.xml的文件，同时我们写入其代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--扫描加载所有的控制类类-->
    <context:component-scan base-package="com.itheima"/>

</beans>
```

然后我们既然扫描了这里的所有控制类，接着我们要做的事情就是将我们要加载的类放置于springmvc容器中，所以我们在我们刚刚创建的UserController类中我们可以写入component注解，当然，我们这里为了合乎规范，我们这里使用其衍生注解Controller，作用一样，名字不同而已

接着我们要思考的事情是，我们将我们的类放置到springmvc里了，接着就要做对于请求的处理了，我们在之前的servlet中我们是通过令其实现HttpServlet的接口的方式以及通过配置文件的方式结合起来完成的处理，我们在springmvc中也是这样做，首先我们先来对我们的配置文件进行处理，这里我们处理的位置是webapp文件夹下的web.xml文件，我们写入其代码如下

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
        http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0">

  <servlet>
    <servlet-name>DispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath*:spring-mvc.xml</param-value>
    </init-param>
  </servlet>
  <servlet-mapping>
    <servlet-name>DispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

</web-app>

```

我们这里配置servlet标签，传入的class文件是我们的DispatcherServlet的全路径，这是我们的引入的依赖的某一个类的路径，然后我们取名为DispatcherServlet，接着我们在映射里也配置对应的名字，接着我们配置拦截的路径，我们这里配置全拦截，也就是所有请求都会经过这个拦截并执行我们所配置的方法，同时我们这里需要加载我们的springmvc-xml的文件，因此我们这里还配置了初始化的代码，具体体现在第11-14行

然后我们既然已经配置了对应的核心配置的代码，接着我们还有配置对应请求的具体处理的代码，这里我们直接进入实现类中，在对应的方法上加入RequestMapping注解，其代表我们的请求的地址，然后在括号内添加对应的访问名称，也就是我们在浏览器中输入的地址的名称，名称可以随便取，但是我们一般会添加和方法名一样的名字

```
package com.itheima.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
//设置当前类为Spring的控制器类
@Controller
public class UserController {
    //设定当前方法的访问映射地址
    @RequestMapping("/save")
    //设置当前方法返回值类型为String，用于指定请求完成后跳转的页面
    public String save(){
        System.out.println("user mvc controller is running ...");
        //设定具体跳转的页面
        return "success.jsp";
    }
}

```

然后我们要令其跳转到我们指定的页面，我们这里令我们的方法返回一个字符串，这个字符串就是我们的要跳转页面的名字，其会根据这个名字查到对应要跳转的页面并进入该页面

然后我们经过测试会发现这个程序是没问题的，这里值得一提的是，我们这里使用的服务器启动了是不会自动弹窗的，所以我们要手动进入对应的网址

那么到此为止我们的案例就制作好了，最后我们来讲解下这个案例的原理。

当我们的服务器启动的时候，其首先会先读取我们的web.xml，也就是核心配置文件，首先其会加载DispatcherServlet，其为springmvc的核心控制类，该类需要传入一个springmvc的配置文件才可以使用，关于这个类的原理我们先按下不表，我们在该配置文件里加载了所有的springmvc的bean类。

然后当其接受到一个save请求时，由核心配置文件下的mapping映射配置中知道其要过滤所有请求，那么其就会取走DispatcherServlet对象，然后去配置文件也就是spring-mvc.xml中配置的路径中去扫描看看哪个类的哪个被RequestMapping标注的方法下有对应的操作名，有的话就执行该操作名下的方法，然后按照return回来的字符串来寻找要通过要返回的页面，将该页面作为响应返回到用户的浏览器中。简单来说就是通过DispatcherServlet来进行控制，对所有请求进行拦截，然后结合RequestMapping注解来执行对应的请求处理

到此为止，我们的入门案例就制作完了，最后我们可以做一个总结

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8091d1ed7fcdb22bf7bbe2cffc1b2226.png)

- SpringMVC技术架构图

接着我们就来具体讲讲我们SpringMVC的技术架构，关于这个架构，我们其实可以通过看病来进行类比，首先我们来看看看病的过程

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE07bd330f40df06b1c352dd8d50032deb.png)

现在我们来讲解下springmvc的具体流程，首先是我们的请求发出到我们的前端控制器DispatcherServelt，前端控制器只负责指挥，其自身并不做具体的工作，真正执行工作的是我们的Handler，也就是处理器。我们的前端控制器接受到请求后想处理器映射器发送一个请求查询，查询该请求具体由哪个Handler来处理，然后我们的之前在请求中也学习过类似于过滤的操作，因此其会返回一个处理器链，将操作排成一排来让我们的过滤操作正确执行，实际上到了处理器的环节之后也可能存在其他操作需要处理，这时也依赖于我们的处理器链。然后我们前端控制器会向处理器适配器也就是HandlerAdapter发送一个请求执行，处理器适配器不是最终负责执行处理的内容，其工作是分配我们的请求到对应的处理器上去执行处理。然后其会返回两个由数据和视图组成的ModelAndView对象，到处理器适配器，适配器会继续返回到前端控制器。前端控制器接受到该对象后会将其发送到视图解析器ViewResolver，该对象会将对象解析成View对象，但是对象，用户是不能直接看的，最后还是由它来渲染视图，最后生成返回的jsp文件，然后通过响应返回给用户

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE630e29e046ddd4b9491a5197e2331c1d.png)

最后我们可以将上面的图简化中我们的重点来，分别是前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器（Handler）、处理器适配器（HandlAdapter）、视图解析器（View Resolver）、view（视图）。

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE8020374b71ce3f38eb9f0c7e7d95e848.png)

最后我们这里只有我们的处理器映射器、处理器以及对应的视图是需要我们自己编写的，其他的内容我们都可以直接拿来用

