到这一个章节，我们来进行对贪心算法的更进一步的学习，上一节我们学会了用贪心的思维来思考问题，并且可以采用范围的方式来思考问题，而非每次取最大，本章我们来运用这些知识来解出更多的题目

- 加油站

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE584ebcc30c471cb409c7e0d3517fef15.png)

首先提一下我们这题其实可以用暴力做出来的啊，但是没什么含金量，我就不提了

我们这题，我们容易想到的贪心思路是我们每次从最大起点中具有最大汽油量的地方出发，然后查看能不能到达目的地，如果能，我们就返回对应的坐标，若不能，就返回-1。根据这个思路我们容易写出其代码如下

```
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int val = gas[0]-cost[0];
        Deque<Integer> list = new ArrayDeque<>();
        list.add(0);
        for (int i = 0; i < cost.length; i++) {
            int num = gas[i] - cost[i];
            if(num > val){
                list.clear();
                list.add(i);
                val=num;
            }else if(val==num){
                list.add(i);
            }
        }
        while (!list.isEmpty()){
            int index = list.pop();
            int size = gas.length;
            int now = 0;
            boolean judge = true;
            for (int i = index; size > 0; i++,size--) {
                if(i==gas.length){
                    i=0;
                }
                now+=gas[i];
                if(now>=cost[i]){
                    now-=cost[i];
                }else{
                    judge=false;
                    break;
                }
            }
            if(judge){
                return index;
            }
        }
        return -1;
    }
}
```

但是这个代码是行不通的，第32个例子过不去，因为实际上我们并不是从最拥有最多汽油量的地方出发就能到达目标位置，这就说明我们最开始的贪心思路，其实就是错误的，那么我们得寻找其他的贪心思路

首先我们可以确保的是，如果我们的总油量就是负数的，那么无论我们怎么走，都不可能绕一圈，这是大前提。其次是，我们可以从0开始累加计算其总油量，如果总油量到达了0，那么其我们的起始位置必然在其下标之后，这是当然的，因为前面的坐标无论怎么加到这个下标的油量一定会小于0，即无法到达，所以必然在其之和，而通过判断总油量是否大于0又可以判断出是否存在绕一圈的下标，两相结合，我们最终就可以通过这种方式来得到我们的目标下标

那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置。

最终我们可以写入我们的代码如下

```
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0,now = 0;
        int index = 0;
        for (int i = 0; i < gas.length; i++) {
            sum+=gas[i]-cost[i];
            now+=gas[i]-cost[i];
            if(now<0){
                index=i+1;
                now=0;
            }
        }
        if(sum<0){
            return -1;
        }
        return index;
    }
}
```

- 分发糖果

现在我们来做一道重量级题目，来到困难题提提神，别总是做简单题目

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE120f96d88707f5679ec7a58f5b9d20b0.png)

那么这题我们的思路很简单，我们首先找到所有最小的值，该值肯定是要放置1颗糖果的，然后我们从该值开始往左赋值，并且往右赋值，然后统计数量，最后遍历所有结果，找到最小的值，该值就是符合结果的值

按照这个思路，我们容易写出我们的代码如下

```
class Solution {
    public int candy(int[] ratings) {
        int sum = ratings[0];
        int index = 0;
        for (int i = 0; i < ratings.length; i++) {
            if(ratings[i]<sum){
                sum=ratings[i];
                index=i;
            }
        }
        int ans = 1;
        int num = 1;
        //往左前进
        for (int i = index-1; i >= 0; i--) {
            if(ratings[i]>ratings[i+1]){
                ans+=num+1;
                num++;
            }else {
                ans++;
                num=1;
            }
        }
        num=1;
        //往右前进
        for (int i = index+1; i < ratings.length; i++) {
            if(ratings[i]>ratings[i-1]){
                ans+=num+1;
                num++;
            }else {
                ans++;
                num=1;
            }
        }
        return ans;
    }
}
```

然而，答案的结果是寄，我们结果最终无法通过一些例子，这些例子的显著特征是，左右两边具有至少一个相同的值，换言之，我们往左走贪心得到的结果是一边，往右走又是一边，但是最终得到的结果并不是需要的最小结果，因为总是会有一个一边走的方向最终得到的结果是少于一个的，没能让正确大于两边的值获得更多的糖果

后续即使我们稍微对我们的代码进行了修改，也只是治标不治本，我们只能通过更多的一些例子而已，然后就无了

所以说我们的思路一开始就出现的问题，需要修改。

不过还是有好事的，虽然我们的思路有问题，但是起码分两边处理我们是没搞错的，虽然结果不对，起码思路有些接近了，我们将本题分为两种情况处理

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE22191e68eabbdd49f7e0565e697f7d9d.png)

其遍历并分发糖果的过程如图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEdf2b4cf758c1d0c6d0d64d47ddd974a6.png)

然后我们再来确定第二种情况

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc4dcf5341f6fc9f396cd48ef57cd58bd.png)

其实吧，这里为什么一定要从右往左遍历而不能从左往右遍历，说实话我现在也搞不太懂，我个人猜测是因为如果我们再来一次从左往右遍历，那么我们最终得到的结果还是跟之前一样的，这没啥意义。

我们需要的是跟之前不一样的，因此我们这里就需要利用前面定义的值，我们从右往左遍历，每次都取出当前值和当前值的前一个值+1进行对比，每次获得其最大值，这样我们就可以让我们的最终得到的分发糖果值符合我们的最终需求

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE527ed1ed8efbe54f77d3ceebf09a63fd.png)

那么最终我们可以写入我们的代码如下

```
class Solution {
    public int candy(int[] ratings) {
        int[] arr = new int[ratings.length];
        arr[0]=1;
        //从左往右
        for (int i = 1; i < ratings.length; i++) {
            if(ratings[i]>ratings[i-1]){
                arr[i]=arr[i-1]+1;
            }else {
                arr[i]=1;
            }
        }

        //从右往左
        for (int i = ratings.length-2; i >= 0; i--) {
            if(ratings[i]>ratings[i+1]){
                arr[i]=Math.max(arr[i],arr[i+1]+1);
            }
        }

        int ans = 0;
        for (int i : arr) {
            ans+=i;
        }
        return ans;
    }
}
```

当然说实话吧，这个原理我属实不是很懂，比如我个人就不是很明白为啥他就能保证这样做一定能获得最终所需要的值，最让我不明白的是凭啥他能设置最开始的那个就是1然后执行运算就能得到正确结果？

这玩意简单来说就是右遍历一遍左遍历一遍然后取两次结果最大值就是正确答案，我倒是不难理解这个算法，我难以理解的是凭啥他就知道这样做就是正确的啊？目前我们还不太懂，就先记着吧

另外值得一提的是，这题居然还是2021.8.21网易互联网笔试的第三道题，不过题目给成了围成一圈形成环，因此我们最后来看看围成环我们的解题算法

```
class Solution {
    public static int candy(int[] ratings) {
        //边界
        if(ratings == null || ratings.length == 0) return 0;
        if(ratings.length == 1) return 1;
        //左右规则数组
        int[] left = new int[ratings.length];
        int[] right = new int[ratings.length];
        //至少一个元素
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        //统计结果
        int count = 0;
        //左遍历，保证左规则，即当前元素大于左边元素，就分配+1
        for (int i = 0; i < ratings.length; i++) {
            if (i == 0) {
                if (ratings[i] > ratings[ratings.length - 1]) left[i] = left[ratings.length - 1] + 1;
            } else {
                if (ratings[i] > ratings[i - 1]) left[i] = left[i - 1] + 1;
            }
        }
        //右遍历，保证右规则，即当前元素大于右边元素，就分配+1
        for (int i = ratings.length - 1; i >= 0; i--) {
            if (i == ratings.length - 1) {
                if (ratings[i] > ratings[0]) right[i] = right[0] + 1;
            } else {
                if (ratings[i] > ratings[i + 1]) right[i] = right[i + 1] + 1;
            }
            //满足左右规则最大值，则为最少分配糖果数
            count += Math.max(left[i], right[i]);
        }
        return count;
    }
}
```

可以看到其实本质上还是差不多的，成环了我们的解题过程无非是在左遍历时对0进行特殊处理，让0坐标下的值与倒数第一位坐标的值进行比较，然后其他做坐标我们照样处理

接着右遍历时我们对第一位的坐标进行特殊处理，令其与第一位比较，接着其他位置的值就照常比较即可

最终得到的最大值的结果就是我们所需要的结果

- 柠檬水找零

再做完一道难题之后，我们来做一道简单的题目练练手吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1fd268a2ea082a7ddcc2b1d3dace0ebd.png)

这个没啥特别值得说的啊，就是找零的时候我们优先找大面额的给顾客就行了，无非就是多了些分情况讨论而已

```
class Solution {
    int[] arr = new int[21];
    public boolean lemonadeChange(int[] bills) {
        for (int bill : bills) {
            if (bill == 5) {
                arr[5]++;
            } else if (bill == 10) {
                arr[10]++;
                if (arr[5] == 0) {
                    return false;
                }
                arr[5]--;
            } else {
                arr[20]++;
                if (arr[10] == 0) {
                    if (arr[5] < 3) {
                        return false;
                    }
                    arr[5] -= 3;
                } else {
                    arr[10]--;
                    if (arr[5] == 0) {
                        return false;
                    }
                    arr[5]--;
                }
            }
        }
        return true;
    }
}
```

- 根据身高重建队列

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE56b6fb4484d1c2f11e864369465ff58c.png)

这个贪心题目其实考的是我们的一个全新的知识面，那就是需要进行预处理，然后再使用我们的贪心法求解

我们首先我们要分情况讨论，先从一个维度去考虑，先确定一个维度，再去确定另外一个维度，如果两个维度一起考虑一定会顾此失彼。

那么本体我们到底是先确定哪个维度呢？是身高呢？还是排序呢？我们可以用这两个排序都试试，如果我们用排序k来进行排序，我们会发现排完之后好像啥也没变，没啥用处

但是如果我们用h来排序，那么身高就一定是从大到小排，如果身高一致，那么k小的站前面，这样我们就可以让高个子站在前面，这其实也符合我们的案例，虽然其不是严格按身高从大到小排序的，但是其大致上是遵从这个规律的

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE2df14a84efb582c45bc383a19449e928.png)

而且，哪怕只是从最简单的现实案例中来思考也是这样的，我们既然要插入按身高和前面人数的对应集合序列，那最高的不久应当在最前面吗？这样最高的那个才是只有0位在他前面的呀

综上所述我们决定让我们的数组按身高进行排序，如果身高一致则k值小的排前面

当然，只是让高个子站在前面并没有什么卵用，我们这里之所以这样排序，是为了给我们后面做铺垫，起码现在我们已经确定了一个维度了，这个维度能够让我们的身高从大到小排

接着我们要做的事情是，按照对象中的people的k来插入，最终中完成的我们所需要的集合

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5aec0cd1ef59b21262a9b24defdae523.png)

那么我们容易写出其代码如下

```
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (o1, o2) -> {
            if(o2[0]==o1[0]){
                return o1[1]-o2[1];
            }
            return o2[0]-o1[0];
        });
        List<int[]> list = new LinkedList<>();
        for (int i = 0; i < people.length; i++) {
            list.add(people[i][1],people[i]);
        }
        return list.toArray(new int[list.size()][]);
    }
}
```

可以看到我们这里首先对我们的数组进行排序，让优先让身高高的排前面，若身高相同，则k值小的排前面

然后我们创建了一个list集合，内部存放int[]数组对象，然后我们遍历该集合，调用集合中在对应下标中添加的方法，其中第一个代表的是下表，第二个代表的是存放的对象，那么我们每次往里面存入对应的对象都是按照当前对象的第二个k的所代表的下标的顺序来插入的，最终得到的结果就是我们所需要的

最后我们调用list内部的转换为数组的方法即可，内部我们new一个我们要转换成的数组对象，大小直接设置成当前集合的大小即可，最终就能得到我们想要的二维数组

具体的插入过程请看下图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3226997bea0d0722fc40fc0b686e1215.png)

当然，我承认这有点抽象，刚开始可能想不到，但是我们学习了之后以后我们就要想到这个方法了是吧，第一次想不到大伙们都理解