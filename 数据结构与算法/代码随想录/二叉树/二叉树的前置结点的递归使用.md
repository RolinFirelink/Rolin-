本节我们来学习二叉树的进阶递归，学习递归的进阶用法。第一题我们先来看看一道比较常规的和本节内容关系不大的题目，先来小试牛刀。

- 二叉搜索树中的搜索

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE1969401513f79a6b1ac314fa612c0a16.png)

这个题目还是非常简单的，首先我们来看看递归

```
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root==null){
            return null;
        }
        if(root.val==val){
            return root;
        }
        if(root.val>val){
            return searchBST(root.left,val);
        }else {
            return searchBST(root.right,val);
        }
    }
}
```

然后我们来看看迭代，这里我们是使用完成的前序遍历达成目的

```
class Solution {
    // 迭代，普通二叉树
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.add(root);
        while (!deque.isEmpty()) {
            TreeNode node = deque.pollLast();
            if (node.val == val) {
                return node;
            }
            if (node.right != null) {
                deque.add(node.right);
            }
            if (node.left != null) {
                deque.add(node.left);
            }
        }
        return null;
    }
}
```

最后其实我们可以使用简单的迭代完成本体，连栈都不需要，只需要我们利用二叉搜索树的性质就可以了。

```
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root==null) return null;
        while (root!=null){
            if(root.val>val){
                root=root.left;
            }else if(root.val<val){
                root=root.right;
            }else {
                return root;
            }
        }
        return null;
    }
}
```

- 验证二叉搜索树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE16fa7e82d5810df999c81bc8c1f65f79.png)

到这里我们就正式进入我们的进阶递归的学习，我们这里要学习的一个经典方法就是通过在成员变量中定义一个结点类，然后每次递归令其保存上一个结点，通过上一个结点与递归进入的当前结点进行比较来达成我们的比较目的。我们先来分析下本题

初次做本题，我们容易陷入一个误区，就是我们只是单纯地比较当前结点的左右子树的逻辑是否成立，如何全部成立我们就认为其是二叉搜索树，否则就不是，这个思路看起来似乎没有问题，但实际是不可行的。具体请看下图的例子

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE78f4298c83ef551b3ff2142f877b4a67.png)

可以看到上面的二叉树完全符合我们的逻辑，但其实它不是一颗二叉搜索树。那么我们应该如何解决这题呢？其实我们可以使用二叉搜索树的逻辑，我们总是先向左前进，一旦前进到底部，我们就开始保存上一个结点的值，只要上一个结点有值，我们就将上一个结点与当前结点进行比较，如果我们的上一个结点比我们的当前结点还要大或者是相等，那么就说明其不是二叉搜索树，按照这种基本逻辑遍历完整棵树就可以了，同时每次到了最左的结点并处理完后，我们就往右子树上前进一位，通过这种方式来实现所有的结点的遍历，且我们的基本逻辑总是定在上一个结点和左边的结点的比较上。这种想法有点类似于我们的中序遍历的迭代法的思路，实际上我们本题用迭代法来做的时候还真的就是用中序遍历的迭代代码来做。

那么最后我们还要解决一个问题，那就是空树是二叉搜索树吗？答案是肯定的，二叉搜索树可以为空

那么我们可以写入我们的递归代码如下

```
class Solution {
    TreeNode node;
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        boolean left = isValidBST(root.left);
        if(node!=null && node.val>=root.val){
            return false;
        }
        node=root;
        boolean right = isValidBST(root.right);
        return  left && right;
    }
}
```

我们来看看我们的递归代码，我们首先是定义了一个名为node的成员变量用于记录上一个结点。然后我们的终止条件是当结点为空时，我们返回true。然后我们每次都先往左子树上前进，先前进到底部，然后一旦底部没有值，我们就返回true，然后程序回到第一个结点，也就是最左边的结点，到达最左节点时，我们的node是没有值的，会跳过比较，然后会给对应的结点记录上该结点的值，这里我们的node设置在比较之后的含金量就体现出来了。然后往右搜索，接着同样会进行先往左子结点前进的动作，这时我们的的往先往左递归的代码的含金量也体现出来了，到了第二个最左结点之后会进行同样的比较。然后我们在最后判断左右的两个判断是否同时为真，若有一个不为真就说明这不是二叉搜索树，此时结束递归。

不过我们这份代码其实可以优化，最简单的来说，如果我们的左边的判断已经不为真了，那么我们就没必要继续进行递归的判断，因此我们可以将我们的代码修改如下

```
class Solution {
    TreeNode node;
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        boolean left = isValidBST(root.left);
        if(!left){
            return false;
        }
        if(node!=null && node.val>=root.val){
            return false;
        }
        node=root;
        boolean right = isValidBST(root.right);
        return right;
    }
}
```

上面这份代码就相当于是做了简单的一个剪枝，但是这一份代码其实还可以做进一步的简化，具体请看下面的究极简化后的版本

```
class Solution {
    TreeNode node;
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        boolean left = isValidBST(root.left);
        if(!left) return false;
        if(node!=null && node.val>=root.val) return false;
        node=root;
        return isValidBST(root.right);
    }
}
```

值得一提的是这一份代码的逻辑我们要牢牢记住，后续的题目我们还会用到这种逻辑来解题。接下来我们来看看迭代的版本的代码，我们这里总是先往左前进，然后往右边走，这其实就对应我们迭代里的中序遍历的代码，所以我们这里就用中序遍历的代码来完成本题，请看代码

```
class Solution {
    TreeNode node;
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        while (root!=null || !deque.isEmpty()){
            if(root!=null){
                deque.add(root);
                root=root.left;
            }else {
                root=deque.pollLast();
                if(node!=null && node.val>=root.val){
                    return false;
                }
                node=root;
                root=root.right;
            }
        }
        return true;
    }
}
```

基本逻辑和递归的差不多，这里就不再赘述了

- 二叉搜索树的最小绝对差

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9fb12b00a057f9aedd5ce831bfa6c407.png)

那么经过了上一题的学习之后，我们就拿这一题来小试牛刀，首先我们来看看我们递归的代码

```
class Solution {
    TreeNode node;
    int ans = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        dfs(root);
        return ans;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        dfs(root.left);
        if(node!=null && root.val-node.val<ans){
            ans=root.val-node.val;
        }
        node=root;
        dfs(root.right);
    }
}
```

可以看到我们这里递归的主体思路跟上一题的一样，不过我们这里对我们的逻辑进行了进一步的简化，我们让我们的递归比较只通过上一个结点和这个节点的差值进行比较，最终得到我们想要的结果。不过实际上我们这份代码还能再改良，具体如下

```
class Solution {
    TreeNode node;
    int ans = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        if(root==null){
            return 0;
        }
        getMinimumDifference(root.left);
        if(node!=null && root.val-node.val<ans){
            ans=root.val-node.val;
        }
        node=root;
        getMinimumDifference(root.right);
        return ans;
    }
}
```

可以看到我们这个代码变得更加简洁了，我们这里采用的方法就是不获得其对应的返回值，利用这种方式来实现我们的目的。

最后我们来看看我们的迭代的代码

```
class Solution {
    TreeNode node;
    int ans = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        Deque<TreeNode> deque = new ArrayDeque<>();
        while (root!=null || !deque.isEmpty()){
            if(root!=null){
                deque.add(root);
                root=root.left;
            }else {
                root=deque.pollLast();
                if(node!=null && root.val-node.val<ans){
                    ans=root.val-node.val;
                }
                node=root;
                root=root.right;
            }
        }
        return ans;
    }
}
```

- 二叉搜索树中的众数

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4b369356c2cdaffdd936606b2fe626d8.png)

本节我们来学习我们的前置结点的递归使用的进一步使用法，首先关于这一题，我们的一个简单想法就是直接记录我们树中的结点数，然后遍历出出现次数最多的结点，然后将这些结点返回，那么我们可以构造其代码如下

```
class Solution {
    Map<Integer,Integer> map = new HashMap<>();
    public int[] findMode(TreeNode root) {
        dfs(root);
        List<Integer> list = new ArrayList<>();
        int max = Integer.MIN_VALUE;
        for (Integer i:map.keySet()) {
            if(map.get(i)>max){
                list=new ArrayList<>();
                list.add(i);
                max=map.get(i);
            }else if(map.get(i)==max){
                list.add(i);
            }
        }
        int[] arr = new int[list.size()];
        int index = 0;
        for (Integer i:list) {
            arr[index++]=i;
        }
        return arr;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        map.put(root.val,map.getOrDefault(root.val,0)+1);
        dfs(root.left);
        dfs(root.right);
    }
}
```

这份代码的好处是只要是二叉树就可以使用，但是其缺点是它的效率属实不算高，我们这里其实还给了其为二叉搜索树的条件的，因此我们需要使用我们其特点，结合前置结点递归法来实现一次遍历就达成目的的算法，请看其代码

```
class Solution {
    TreeNode node;
    int maxC;
    int count;
    List<Integer> list = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        dfs(root);
        int[] arr = new int[list.size()];
        for (int i = 0; i < arr.length; i++) {
            arr[i]=list.get(i);
        }
        return arr;
    }

    private void dfs(TreeNode root) {
        if(root==null){
            return;
        }
        dfs(root.left);
        if(node!=null && node.val!=root.val){
            count=1;
        }else {
            count++;
        }
        if(count>maxC){
            list.clear();
            list.add(root.val);
            maxC=count;
        }else if(count==maxC){
            list.add(root.val);
        }
        node=root;
        dfs(root.right);
    }
}
```

我们这里其实也可以对我们的前置结点递归法进行一个总结了，前置节点法的核心思想在于回溯，我们总是会让我们的结点先进入到我们的尾部，在回溯的过程中我们对其处理，这个过程里，我们有一些流程是固定的，首先，我们总是会先放置我们的递归结束的条件判断代码，这个代码一般是结点为null时结束方法，然后总是会优先往左递归，接着进行对应的处理，处理时我们总是会运用到node!=null作为我们的比较条件之一，然后在处理结束后我们总是让我们的node去记录上一个结点，然后让我们的结点往右子树上前进一位。

那么我们接着要解决的问题就是如何进行对应的处理，在这个过程中我们首先需要一些用于判断的变量，这些变量我们都会将其放置到我们的成员变量中，这样便于我们的调用。我们这里注意看我们的处理过程，我们这里是判断当我们的node==null或者是我们记录的值和当前值不想等时，我们重置我们的计数，当其相等时，我们就令其增加一位。这里精妙的一点在于如果前置结点没有记录时，我们就立刻让我们的计数增加1，其动作代表的意义是我们将当前结点记录下来，这样结合下面的代码就可以实现对首次进入的结点的处理。我们以后的思路的一个重要一点也在于此，就是我们要确定我们的node不存在时，也就是我们第一次进入结点时我们的处理方式

最后我们的处理是进行对当前计数和最大计数的比较，如果超越最大计数我们就调用我们的集合的清空方法来清空我们的集合，然后我们将该值添加到集合中，接着更新最大计数，如果相等我们就继续再集合里添加我们对应的值。

这里我们的一个重要的思想在于，我们是一边统计一边添加的，不断更新维护对应的值，而不是数到最大之后我们才进行添加，这一点是我们的核心思想。

最后我们来看看我们的迭代的代码，这里用到了中序遍历，但是逻辑是一样的，这里就不赘述了

```
class Solution {
    TreeNode node;
    int maxC;
    int count;
    List<Integer> list = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        Deque<TreeNode> deque = new ArrayDeque<>();
        while (root!=null || !deque.isEmpty()){
            while (root!=null){
                deque.add(root);
                root=root.left;
            }
            root = deque.pollLast();
            if(node!=null && node.val!= root.val){
                count=1;
            }else {
                count++;
            }
            if(count>maxC){
                list.clear();
                list.add(root.val);
                maxC=count;
            }else if(count==maxC){
                list.add(root.val);
            }
            node=root;
            root=root.right;
        }

        int[] arr = new int[list.size()];
        for (int i = 0; i < arr.length; i++) {
            arr[i]=list.get(i);
        }
        return arr;
    }
}
```

最后我们不妨来总结下我们学习过的这么多的树的异同

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5eb67722b8a173df4c9967c76131a530.png)

