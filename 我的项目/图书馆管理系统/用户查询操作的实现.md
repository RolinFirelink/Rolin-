此前我们将用户进行了持久化操作，接下来我们就要做一个查询操作，将存放的数据查出来并展示到界面中

这里我们还是要利用分层的思想，由于我们是要跟持久化的数据打交道，因此这里我们创建一个DAO层

首先我们在主包下创建一个dao包，在dao包下创建一个用户相关的dao接口称之为UserDao，那么我们要思考我们这个接口里写什么方法，注意当初我们将对象写入到硬盘中时，我们是以集合的形式写入的，那么我们读取时，自然也是以集合来读取比较好，因此我们可以将接口类定义如下

```javascript
package com.bjpowernode.dao;

import com.bjpowernode.bean.User;

import java.util.List;

public interface UserDao {
    List<User> select();
}

```

那么现在接口写好了，接着我们要写他的实现类，我们在dao下创建一个字包叫impl（其实就是implements的缩写），这个子包下写该接口的实现类，而且接口就放到dao包下

那么我们创建名为UserDaoImpl的实现类，然后可以写入代码如下

```javascript
/**
 * 用户Dao层
 */
public class UserDaoImpl implements UserDao {

    /**
     * 从硬盘文件中读取数据
     * @return
     */
    @Override
    public List<User> select() {
        //创建对象输入流
        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PathConstant.USER_PATH))){
            List<User> list = (List<User>) ois.readObject();
            return list;
        }catch (Exception e) {
            e.printStackTrace();
        }
        //如果出现了异常则返回一个空的新创建的list对象
        return new ArrayList<>();
    }
}
```

这里我们之所以没有关闭流的原因是因为我们采用了try()语法，这个语法简而言之就是，括号内的流会自动关闭，因此我们不必手动关闭流

那么到此为止，我们的Dao层就实现完毕了，接着按照代码分层的思想，我们现在来实现Service层

在这里Service包已经是有了的，那么我们只要在对应的Service包下创建对应的接口和实现其调用Dao层的代码就完了

首先我们在Service包下创建接口代码如下

```javascript
package com.bjpowernode.service;

import com.bjpowernode.bean.User;

import java.util.List;

public interface UserService {
    List<User> select();
}

```

可以看到跟Dao层的接口一模一样，这是为什么？因为我们实际上是从Service里调用Dao层的方法的，Dao层的接口是怎么样的我们就怎么写就行了，代表的意思就是实现这个接口的类就可以调用Dao层的方法

接着我们来实现这个Service层，我们可以创建一个实现类并构造代码如下

```javascript
/**
 * 用户服务类
 */
public class UserServiceImpl implements UserService {

    //利用多态机制创建一个UserDao对象并令其作为当前类的成语变量
    private UserDao userDao = new UserDaoImpl();

    /**
     * 查询
     * @return
     */
    @Override
    public List<User> select() {
        return userDao.select();
    }
}
```

可以看到我们这里对实现类里定义代码就是创建了一个UserDao对象然后就调用了里面的对应方法并返回就没了，我个人猜测这也是调用的定义之一，就是调用就是直接创建一个对应的对象，然后调用该对象内部的方法，而调用类里是总是拥有被调用类的对象的，正是因此所以其可以调用被调用类的方法

按照代码分层的思想，现在我们只剩下controller层等待实现了，我们要实现controller层，就要在controller类里调用对应的service类，这里我们的controller层早就已经定义好了，其就是位于module包下的user包下的UserViewCtrl类，这里按照我们之前说过的调用方式，我们同样要在该类下定义Uservice的成员变量并调用其Uservice的方法，返回的是存放User对象的集合，我们将集合添加到展示台中（这里对应的动作是往UserViewCtrl类下的users里添加用户对象，全部添加完毕之后，会自动在展示台上展示，之所以能自动展示是因为我们之前已经实现过自动展示的代码了）

那么我们可以改造这一部分的代码如下

```javascript
ObservableList<User> users = FXCollections.observableArrayList();
//定义调用Service层的方法的动作
private UserService userService = new UserServiceImpl();

@Override
public void initialize(URL location, ResourceBundle resources) {
    //调用Service层查询数据并返回一个List集合
    List<User> userList = userService.select();

    users.addAll(userList);//往展示集合里添加所有之前保存的user对象
    c1.setCellValueFactory(new PropertyValueFactory<>("id"));
    c2.setCellValueFactory(new PropertyValueFactory<>("name"));
    c3.setCellValueFactory(new PropertyValueFactory<>("money"));
    c4.setCellValueFactory(new PropertyValueFactory<>("status"));
    userTableView.setItems(users);

}
```

删除了原先我们手动定义的张三李四王五，因为我们不需要这些玩意。

最后我们还剩下一个问题，就是当初我们所实现序列化接口里我们没有给予其序列化版本号，这样的话我们的User类里如果哪天修改了的话，会出现类无法找到异常，因此我们不要忘了给对应的User类里赋予其指定的序列化版本号

最后我们回顾一下我们实现用户查询操作的过程，我们首先按照代码分层的思想先实现Dao层，然后实现调用层Service层和controller层，这里我们不管实现哪一层我们一般采用的方式都是在对应的包下创建对应接口类，然后创建对应的实现包类，接着在包下创建对应的实现类

调用类里要含有被调用的对象，调用类里直接创建被调用的对象然后调用对象内的方法

从Dao层开始实现还是从controller层开始实现都是一样的，都是允许的，但是我们还是建立从Dao层开始实现，因为从底部实现比较好理解，也容易上手

最后是序列化的对象要实现可序列化接口，然后我们一定要给予其指定的为一序列号

