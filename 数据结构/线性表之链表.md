学习完顺序表之后，我们现在就来学习链表

我们之前说过了，顺序表底层其实是数组结构，而数据结构的缺点在于其增删元素时都容易涉及到数组的复制操作，这样效率就比较低，而链表结构则没有这个缺点，因此我们来学习链表这个数据结构

链表的插入与删除元素如图所示

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEfa5e470c5e88612b09be1ff4b496a2ea.png)

这个JavaSe里已经学习过了，不多提

接着我们来看看节点的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE82673f7c3e5578c951518864f9579767.png)

可以看到其API里有一个构造方法，调用该构造方法需要传入一个数据类型，然后需要传入一个内存地址，该地址就是节点指向的下一个节点的内存地址

这里我们将next简单称之为指针，指向下一个指点

根据其API设计，我们可以实现其节点如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE115dc66dc0817af6e6a285fec5142564.png)

根据上面这个节点的实现类，我们可以在主方法里这样生成链表

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE9bc6fd44ec99d205c608fbf034fc6f70.png)



单向链表

接下来我们先学习单向链表，先来看看其结构

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc7ae5b240f9a3b0718da37844cf2adfa.png)

单向链表有多个结点，每个结点都由一个数据域和一个指针域构成，数据域用来存储数据，而指针域用来存储指向下一个结点的引用

值得一提的是链表的头结点不存储数据，其指针域指向第一个真正存储数据的结点

接下来我们看看其API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEbad9b27c34c177f0009325ad1dd9d590.png)

由API可以实现单项链表如下，这里我们还把遍历的方式也实现了

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class LinkList<T> implements Iterable<T>{
    //记录头结点
    private Node head;
    //记录链表的长度
    private int N;

    //结点类
    private class Node {
        //存储元素
        T item;
        //指向下一个结点
        Node next;

        public Node(T item, Node next){
            this.item=item;
            this.next=next;
        }
    }

    //单向链表的构造方法
    public LinkList() {
        //初始化头结点,头结点不存储数据，因此item是null，头结点刚初始化也不指向谁，因此next也是null
        this.head=new Node(null,null);
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear() {
        head.next=null;
        this.N=0;
        //清空链表，直接让头结点不指向下一个结点，这样结点由于没有指向，会被垃圾回收器回收，达到清空链表的目的
    }

    //获取链表的长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //获取指定位置i处的元素
    public T get(int i) {

        //通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = head.next;//先创造一个结点n并赋予其头结点的引用
        for (int index = 0; index < i; index++) {
            n=n.next;//每次循环令n变为其结点的引用，循环i次就正好到自己想要到的结点的位置
        }

        return n.item;
    }

    //向链表中添加元素t
    public void insert(T t) {
        //先找到当前最后一个结点

        Node n = head;//先定义一个结点n令其等于头结点
        while (n.next!=null){
            n=n.next;
            //利用while循环来将n的next循环到指向结尾位置
        }

        //创建新结点，保存元素t
        Node newNode = new Node(t,null);
        //让当前最后一个结点指向新结点
        n.next=newNode;
        //元素的个数+1
        N++;
    }

    //向指定位置i处，添加元素t
    //要想添加元素就要找到想添加元素的位置的前/后各一个结点
    public void insert(int i,T t) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
            //循环i-1次，正好到i位置的前一个结点
        }

        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点要指向原来i位置的结点
        Node newNode = new Node(t,curr);
        //原来i位置的前一个结点指向新结点
        pre.next=newNode;
        //元素的个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回被删除的元素
    //要删除指定位置的i处的元素，同样要先找到该元素的一个前后元素
    public T remove(int i) {
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index <= i-1; index++) {
            pre=pre.next;
        }
        //要找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //前一个结点指向下一个结点
        pre.next = nextNode;
        //元素个数-1
        N--;
        return curr.item;
    }

    //查找元素t在链表中第一次出现的位置
    public int indexof(T t){
        //从头结点开始，依次找到每一个结点，取出item和t比较，相同则返回下标
        Node n = head;
        for (int i = 0;n.next!=null; i++) {
            //循环继续条件为n.next!=null，这样就可以达到遍历到底的效果
            n=n.next;
            if(n.item.equals(t)){
                return i;
            }
        }
        return -1;//代码执行到此说明链表里没有目标元素，因此返回-1
    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
        //该方法的重写要求返回一个iterator对象
        //但是iterator是接口，无法直接创造对象
        //因此创建一个内部类来实现iterator接口
        //通过创建该内部类的方式来返回有相同作用的对象
    }

    //实现iterator接口需要重写hasNext和Next方法
    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
            //该方法用于判断当前指针指向还有没有下一个元素
            //用n.next!=null的判断代码可以通过判断其指针域是否为空来进行判断
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
            //先让指针指向下一个结点，接着返回该结点的数据内容
        }
    }
}
```

通过测试发现这个代码没毛病



双向链表

接着我们来学习双向链表，先来看看双向链表的结构图

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE3427e54a3596a9328de1acca49fcbccc.png)

接着我们来看看双向链表的结点的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE10aff105e688a8e8dfa39eff2aeec6b1.png)

接着来看看双向链表的API设计

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEa38f5a5edaf7985b7de0346147fcb99d.png)

由API我们可以设计对应方法如下，同样也已经先实现好了遍历方法

```javascript
package algorithm.sort;

import java.util.Iterator;

//给链表提供遍历方式，因此要实现Iterable接口，要求重写iterator方法
public class  TwoWayLinkList<T> implements Iterable<T> {
    //首结点
    private Node head;
    //最后一个结点
    private Node last;

    //链表的长度
    private int N;

    //结点类
    private class Node{
        //存储数据
        public T item;
        public Node pre;
        public Node next;

        public Node(T item,Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
    }

    public TwoWayLinkList(){
        //初始化头结点的尾结点
        this.head = new Node(null,null,null);
        this.last = null;//此时尾结点还不存在，因此赋予null
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear(){
        //要实现清空链表的效果，只要做两件事情，第一件是令头结点不再指向任何结点
         this.head.next=null;
         this.head.pre=null;//这个可写可不写
         this.head.item=null;//同上
        //第二件是让最后一个尾结点为null，让尾结点不存储任何东西
        this.last=null;
        //最后让记录N的长度的变量为0
        this.N=0;
    }

    //获取链表长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //获取第一个元素
    public T getFist(){
        //先判断头结点是否为空，即头结点有无指向下一个结点
        if (isEmpty()){
            return null;//若为空则返回null
        }
        //若不为空则返回头结点的下一个结点的内容
        return head.next.item;
    }

    //获取最后一个元素
    public T getLast(){
        //先判断头结点是否为空，即头结点有无指向下一个结点
        if (isEmpty()){
            return null;//若为空则返回null
        }
        //若不为空则返回尾结点的内容
        return last.item;
    }

    //插入元素t
    public void insert(T t){
        //链表为空的情况
        if(isEmpty()){
            //先创建新的结点，该头指针域指向头结点，尾指针域为空
            Node newNode = new Node(t,head,null);
            //让新结点成为尾结点，这也是其尾指针域为空的原因
            last=newNode;
            //让头结点的尾指针域指向尾结点
            head.next=last;
        }else {
            //如果链表不为空的情况
            //先将为结点用oldLast来保存
            Node oldLast = last;

            //创建新的结点，让该结点的头指针域指向原先的尾结点
            Node newNode = new Node(t,oldLast,null);

            //让当前的尾结点的尾指针域指向新结点
            oldLast.next=newNode;

            //让新结点成为尾结点
            last = newNode;
        }

        //元素个数+1
        N++;

    }

    //向指定位置插入元素t
    public void insert(int i,T t){
        //找到i位置的前一个结点,先定义pre结点存储这个节点的引用
        //将pre定义为head并循环i次可以定义到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre=pre.next;
        }
        //手动找到i位置的结点，定义curr结点存储i位置结点的引用
        Node curr = pre.next;
        //创建新结点
        Node newNode = new Node(t,pre,curr);
        //令原先i位置的前一个结点的尾指针域指向新结点
        pre.next=newNode;
        //让i位置的结点的头指针域指向新结点
        curr.pre=newNode;
        //元素个数+1
        N++;
    }

    //获取指定位置i处的元素
    public T get(int i){
        //将n定义为首结点的下一个结点，循环i次能正好定义到位置处的结点
        Node n = head.next;
        for (int index = 0; index < i; index++) {
            n=n.next;
        }
        //定义到i位置之后取出该位置的数据
        return n.item;
    }

    //找到元素t在链表中第一个出现的位置
    public int indexOf(T t){
        Node n = head;
        for (int i = 0; n.next!=null; i++) {
            n=n.next;
            if(n.next.equals(t)){
                return i;
            }
        }
        return -1;
    }

    //删除i位置的元素，并返回该元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index < i; index++) {
            pre=pre.next;
        }
        //找到i位置的结点，并用结点curr暂时保存其引用
        Node curr = pre.next;
        //找到i位置的下一个结点，并用nextNode保存其引用
        Node nextNode = curr.next;
        //让原先i位置的前一个结点的尾指针域指向i位置的下一个结点
        pre.next=nextNode;
        //让原先i位置的下一个结点的头指针域指向i位置的前一个结点
        nextNode.pre=pre;
        //元素的个数-1
        N--;
        //返回被删除的元素的数据内容
        return curr.item;
    }

    //继承Iterable接口重写的Iterator方法
    @Override
    public Iterator<T> iterator() {
        return new TIterator();
        //返回以实现方式实现的内部类，其作用等同于Iterator
    }

    //实现Iterator接口的类要重写hasNext和next方法
    private class TIterator implements Iterator{
        private Node n;//先定义一个结点
        public TIterator(){
            this.n=head;
            //令该结点获得head结点的引用
        }
        
        @Override
        public boolean hasNext() {
            return n.next!=null;
            //只要其结点的尾指针域不为空则表示还有下一个
        }

        @Override
        public Object next() {
            n=n.next;//令n进入下一个结点
            return n.item;//取出该结点的数据
        }
    }
}
```

双向链表在java中早已在LinkedList类里实现过了，我们现在来查看其源码，我们查看源码的目标有以下几点

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEb1d73114586a3af63600de1de44e6bec.png)

当然，我们实际查看会发现真的有，没啥毛病。不同的是源码里是没有不存放数据的头结点的，而是直接用first和last来保存头结点和尾结点并利用这两者来进行增删，这里的具体过程在JavaSe里已经学过了，这里不再赘述，了解下就行了

最后我们照例来研究下其各种方法的时间复杂度，这里我们直接上结论吧

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEe0f8b904363f8d0624c3bf54015629aa.png)

虽然说其时间复杂度都是O(n);但是链表数据结构涉及到增删时仍然比数组结构要好得多，主要是链表数据结构里不涉及元素的交换，而且不需要指定一块连续的空间，其主要花费的时间在于for循环的遍历来定位结点上

相比较于顺序表，链表的查询操作性能可能会比较低，因此当我们程序中查询操作比较多的时候，建议使用顺序表，而如果增删操作比较多，则建议使用链表



