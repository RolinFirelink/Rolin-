- 从中序与后序遍历序列构造二叉树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE4b6b83a1448719ed3ac065b8300bcedc.png)

这题我们要解，就要利用中序遍历与后序遍历得到的结果数组来构造我们所需要的二叉树，我们的思路如下

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCEc0f13a593e5b7c1da2a9f2430e58c921.png)

可以看到我们这里最重要的思想就是分割我们的数组，将我们的两个数组进行一定规则的切割，最后构造我们所需要的二叉树。这里我们最需要注意的是，由于我们递归处理时会产生非常多的区间，那么就会存在边界值的问题，我们要小心处理这些边界值问题，不然就会产生各种各样的问题，我们在本题中一律采用左闭右开的方式来处理我们的区间

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE08de0e8bb8db72a283f10fd0f4473dcc.png)

这里我们先切割中序数组，之所以要切割中序数组，是因为切割点在后续数组的最后一个元素，我们使用这个元素来切割中序数组的，所以我们要先切割中序数组。最后我们可以构造我们的代码如下

```
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return dfs(inorder,0,inorder.length,postorder,0,postorder.length);
    }

    private TreeNode dfs(int[] inorder, int inLeft, int inRight, int[] postorder, int poLeft, int poRight) {
        if(inRight-inLeft<1){
            return null;
        }
        if(inRight-inLeft==1){
            return new TreeNode(inorder[inLeft]);
        }
        int val = postorder[poRight-1];
        TreeNode root = new TreeNode(val);
        int index = inLeft;
        for (int i = inLeft+1; i < inRight; i++) {
            if(val==inorder[i]){
                index=i;
                break;
            }
        }
        root.left = dfs(inorder,inLeft,index,postorder,poLeft,poLeft+(index-inLeft));
        root.right = dfs(inorder,index+1,inRight,postorder,poLeft+(index-inLeft),poRight-1);
        return root;
    }
}
```

我们这里重点要学习的是我们构建我们代码的思路，首先我们要构建新的递归函数，然后我们前面要给予其对应的处理方法，首先是当左右边界根本就不包含结点时，我们令其返回null，然后是当只有一个值时，我们让其返回对应的中序遍历的数组的第一个值，此时说明我们中序遍历的数组正好只有一个值，而那个值就是要返回的值。

每次递归我们创建后序遍历的数组的最后一个值作为结点，然后用该值去寻找在中序数组里的对应下标，接着对其进行分割，递归处理这些区间。这里我们可以看到我们循环遍历查找对应值的方式，我们默认第一个值就是我们所需要的值，然后我们进行遍历，我们这里起始的值+1是因为第一个值我们不需要进行遍历，而我们的i的值为inLeft，结尾总是inRight是因为我的边界是动态变化的，所以我们寻找值的区间也要进行一个动态的变化，如果传入0或者是其他的固定值，会报错。

我们可以看到我们令我们的结点的左子树为同时处理中序和后序切分后的左区间，而右子树为右区间。这里我们要着重讲一下我们递归传入的参数里面的学问，首先我们每次传入中序的数组之和，我们inLeft传入，这是没问题的，之后其边界值传入的index，这里是因为我们采用了左闭右开的形式因此我们可以这么做，index是不会被使用到的，接着我们后序数组的起始区间是poLeft+(index-inLeft)，这里poLeft是我们的起始位置，而后面的index-inLeft则是我们通过指定下标减去其起始位置得到的，我们得到结尾的方式是开头边界加上中间距离得到的。而其下的第二个分割的右子树的区间，我们的index之所以要+1，是因为我们是左闭右开，左边的边界会被用到，而用于分割的下标是不能被重复使用的，因为其已经被生成结点了，我们不能使用，后面的inRight就是其中序数组的右边界值。而后面的后序数组，我们传入的左边界就是我们前一个的边界值，然后右边界就是最开始的边界-1，这是以为最开始的值我们已经用于创建结点了，所以这里的值也不能用了，这很好理解。

当然，的确这种代码要我们去想到，有点为难人，但是起码这种分割思路我们可以学习，比如说最前面的对边界的处理和传入边界时的细节处理等，后续我们还会有题目用到这个思路。

而至于左闭右闭的代码，各位有兴趣就自己去实现了，这里就不去演示了（其实是因为自己试了试也写不出来）

- 从前序与中序遍历序列构造二叉树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE413107dbab137f198a2b2e9ed039212b.png)

这题是上一题的进阶题目，其思路本质上和上一题的大差不差的，不同的是这里需要使用左闭右闭的方式来进行代码的构造会比较好，实际上我个人去尝试了使用左闭右开去构造，但是属实构造不出来，寄了

- 最大二叉树

![](D:/Rolin的学习笔记/youdaonote-pull/youdaonote/youdaonote-images/WEBRESOURCE5798b12124fe66430dde8c6b5ec4e128.png)

解决这题的方法和我们上面的思路是十分相同的，也是通过不断划分区间最后构造出我们想要的二叉树，具体的构造规则题目都已经告诉我们了，所以说其实这个还是挺好做的。

先来看看递归代码

```
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return dfs(nums,0, nums.length-1);
    }

    private TreeNode dfs(int[] nums, int start, int end) {
        if(end < start){
            return null;
        }
        if(end==start){
            return new TreeNode(nums[start]);
        }
        int index = start;
        int target = nums[start];
        for (int i = start+1; i <= end; i++) {
            if(nums[i]>target){
                target=nums[i];
                index=i;
            }
        }
        TreeNode root = new TreeNode(target);
        root.left = dfs(nums,start,index-1);
        root.right = dfs(nums,index+1,end);
        return root;
    }
}
```

这份代码本身挺简单的，没啥值得说的，自己看看应该也能看明白了。本题使用迭代来做的难度比较高，因此这里就不带着大家用迭代做一遍了。