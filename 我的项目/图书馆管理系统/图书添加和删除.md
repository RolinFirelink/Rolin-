现在我们来实现添加和删除方法，这一块的内容其实和之前我们用户里的添加和删除差不多，唯一有区别的在于图书添加的框目是有类型的选择的下拉框的，而且会有更多的条目需要用户去填充

同样先来分析添加的界面代码

```javascript
<Button mnemonicParsing="false" prefHeight="54.0" prefWidth="100.0" onMouseClicked="#bookAddView" styleClass="btn-primary" text="添加" />
```

点击鼠标事件

```javascript
/*
    添加
 */
@FXML
private void bookAddView() {
    try {
        initStage(null);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

点进去看看initStage方法的情况

```javascript
    /*
        初始化stage
     */
    private void initStage(Book book) throws IOException {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(App.class.getResource("/com/bjpowernode/module/book/BookHandleView.fxml"));
        StackPane target = (StackPane) loader.load();
        //Scene scene1 = App.getDecorator().getScene();
        Scene scene = new Scene(target);


        Stage stage = new Stage();//创建舞台；
        BookHandleViewCtrl controller = (BookHandleViewCtrl)loader.getController();
        controller.setStage(stage);
        controller.setBooks(books);
        controller.setBook(book);
        controller.setBookTableView(bookTableView);
//        stage.setResizable(false);
        stage.setHeight(800);
        stage.setWidth(700);
        //设置窗口图标
        stage.getIcons().add(new Image("icon.png"));
        stage.initModality(Modality.APPLICATION_MODAL);
        stage.setScene(scene); //将场景载入舞台；
        stage.show(); //显示窗口；
    }
}
```

这里同样是先将界面加载出来，然后展示

我们之前很多框目的代码都看过了，但是这里有新的代码，就是下拉框的代码，我们来看看这个新代码

```javascript
<ComboBox fx:id="typeField" GridPane.columnIndex="1" GridPane.rowIndex="4" prefHeight="30.0" prefWidth="179.0" >
    <items>
        <FXCollections fx:factory="observableArrayList" >
            <String fx:value="计算机" />
            <String fx:value="文学" />
            <String fx:value="经济" />
            <String fx:value="管理" />
        </FXCollections>
    </items>
    <value>
        <String fx:value="计算机"/>
    </value>
</ComboBox>
```

上面就是下拉框的界面代码了，最上面是界面显示代码，而下面各种不同的字符串则对应下拉框的内容

而最下面还有一个“计算机”的字符串，其代表的意义是默认选中的计算机类型的属性

讲完了这些，我们进入controller层里对应的添加代码

```javascript
/*
    添加或修改数据
 */
@FXML
private void addOrEditBook() {
    try {
        String id = bookIdField.getText();
        if ("".equals(id) || null == id) {
            //添加操作
            Book book = new Book();
            populate(book);
            book.setStatus(Constant.STATUS_STORAGE);
            books.add(book);
        }else {
            //修改操作
            populate(this.book);
            //刷新
            bookTableView.refresh();
        }

        stage.close();
        Alerts.success("成功", "操作成功");
    } catch (Exception e) {
        e.printStackTrace();
        Alerts.error("失败","操作失败");
    }
}
```

可以看到其跟用户差不多，都是把修改和添加方法放一起的，也是通过判断id和名字是否为空来进行是添加还是修改的判断，不过这里有一个populate方法，我们点进去看看

```javascript
private void populate(Book book) {
    book.setBookName(bookNameField.getText());
    book.setAuthor(authorField.getText());
    book.setIsbn(isbnField.getText());
    book.setPublisher(publisherField.getText());
    book.setType(typeField.getSelectionModel().getSelectedItem().toString());
}
```

可以看到，这个代码作用就是将获取用户在界面框里输入的信息并设置到对应的书籍对象上，第6行代码获取的是下拉框的内容，所以并不是欧通的获取文本方法

我们同样先来实现添加方法，同样利用代码分层的思想，先在Dao层接口添加方法

```javascript
void add(Book book);
```

实现方法

```javascript
/**
 * 图书添加
 * @param book
 */
@Override
public void add(Book book) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.BOOK_PATH));
        List<Book> list = (List<Book>) ois.readObject();
        if(list!=null){
            Book lastBook = list.get(list.size()-1);
            book.setId(lastBook.getId() + 1);
            list.add(book);
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.BOOK_PATH));
            oos.writeObject(list);
            oos.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    } finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

service层接口添加方法

```javascript
void add(Book book);
```

实现方法

```javascript
@Override
public void add(Book book) {
    bookDao.add(book);
}
```

controller层调用service层方法

```javascript
bookService.add(book);
```

只添加这个代码就可以了



图书删除

依葫芦画瓢实现图书删除

先添加Dao层接口方法

```javascript
void delete(int id);
```

实现方法

```javascript
/**
 * 图书删除
 * @param id
 */
@Override
public void delete(int id) {
    ObjectInputStream ois = null;
    ObjectOutputStream oos = null;
    try {
        ois = new ObjectInputStream(new FileInputStream(PathConstant.BOOK_PATH));
        List<Book> list = (List<Book>) ois.readObject();
        if(list!=null){
            Book book = list.stream().filter(b -> b.getId()==id).findFirst().get();
            list.remove(book);
            oos = new ObjectOutputStream(new FileOutputStream(PathConstant.BOOK_PATH));
            oos.writeObject(list);
            oos.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
    }finally {
        if(ois!=null){
            try {
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(oos!=null){
            try {
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

service层接口添加方法

```javascript
void delete(int id);
```

实现方法

```javascript
@Override
public void delete(int id) {
    bookDao.delete(id);
}
```

找到controller层的删除方法并调用service层删除方法就完了

```javascript
@FXML
private void deleteBook() {
    try {
        Book book = this.bookTableView.getSelectionModel().getSelectedItem();
        if (book == null){
            Alerts.warning("未选择","请先选择要删除的数据");
            return;
        }
        bookService.delete(book.getId());
        this.books.remove(book);
        Alerts.success("成功", "图书修改成功");
    } catch (Exception e) {
        e.printStackTrace();
        Alerts.error("失败","图书修改失败");
    }
}
```

这里我们在第9行调用了方法

那么到此为止，我们图书添加和删除的功能就实现完毕了